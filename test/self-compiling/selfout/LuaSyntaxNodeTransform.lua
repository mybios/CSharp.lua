-- Generated by CSharp.lua Compiler
--[[
Copyright 2017 YANG Huan (sy.yanghuan@gmail.com).

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
]]
local System = System
local Linq = System.Linq.Enumerable
local MicrosoftCodeAnalysis = Microsoft.CodeAnalysis
local MicrosoftCodeAnalysisCSharp = Microsoft.CodeAnalysis.CSharp
local MicrosoftCodeAnalysisCSharpSyntax = Microsoft.CodeAnalysis.CSharp.Syntax
local MicrosoftCodeAnalysisText = Microsoft.CodeAnalysis.Text
local SystemCollectionsImmutable = System.Collections.Immutable
local SystemLinq = System.Linq
local SystemText = System.Text
local SystemTextRegularExpressions = System.Text.RegularExpressions
local SystemThreading = System.Threading
local CSharpLua
local CSharpLuaLuaAst
System.usingDeclare(function (global)
  CSharpLua = global.CSharpLua
  CSharpLuaLuaAst = CSharpLua.LuaAst
end)
System.namespace("CSharpLua", function (namespace)
  namespace.class("LuaSyntaxNodeTransform", function (namespace)
    namespace.class("MethodInfo", function (namespace)
      local __ctor1__, __ctor2__
      __ctor1__ = function (this, symbol)
        this.Symbol = symbol
        this.RefOrOutParameters = System.Array.Empty(CSharpLuaLuaAst.LuaExpressionSyntax)
      end
      __ctor2__ = function (this, symbol, refOrOutParameters)
        this.Symbol = symbol
        this.RefOrOutParameters = refOrOutParameters
      end
      return {
        __ctor__ = {
          __ctor1__,
          __ctor2__
        }
      }
    end)
    namespace.class("TypeDeclarationInfo", function (namespace)
      local CheckTypeName, __ctor__
      __ctor__ = function (this, typeSymbol, luaTypeDeclarationSyntax)
        this.TypeSymbol = typeSymbol
        this.TypeDeclaration = luaTypeDeclarationSyntax
      end
      CheckTypeName = function (this, getNameTypeSymbol, name)
        if getNameTypeSymbol:Equals(this.TypeSymbol) then
          this.TypeDeclaration.IsClassUsed = true
          name = CSharpLuaLuaAst.LuaIdentifierNameSyntax.Class
          return true, name
        end
        name = nil
        return false, name
      end
      return {
        CheckTypeName = CheckTypeName,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("MethodDeclarationResult", function (namespace)
      return {
        IsPrivate = false
      }
    end)
    namespace.class("BlockCommonNode", function (namespace)
      local CompareTo, Contains, CheckBlankLine, Visit, CheckInsertLuaCodeTemplate, class, __init__, __ctor1__, 
      __ctor2__
      __init__ = function (this)
        this.SyntaxTrivia = System.default(MicrosoftCodeAnalysis.SyntaxTrivia)
        this.LineSpan = System.default(MicrosoftCodeAnalysis.FileLinePositionSpan)
      end
      __ctor1__ = function (this, syntaxTrivia)
        __init__(this)
        this.SyntaxTrivia = syntaxTrivia:__clone__()
        this.LineSpan = syntaxTrivia:getSyntaxTree():GetLineSpan(syntaxTrivia:getSpan(), System.default(SystemThreading.CancellationToken))
      end
      __ctor2__ = function (this, statement)
        __init__(this)
        this.SyntaxNode = statement
        this.LineSpan = statement:getSyntaxTree():GetLineSpan(statement:getSpan(), System.default(SystemThreading.CancellationToken))
      end
      CompareTo = function (this, other)
        return this.LineSpan:getStartLinePosition():CompareTo(other.LineSpan:getStartLinePosition())
      end
      Contains = function (this, other)
        local otherLineSpan = other.LineSpan
        return MicrosoftCodeAnalysisText.LinePosition.op_GreaterThan(otherLineSpan:getStartLinePosition(), this.LineSpan:getStartLinePosition()) and MicrosoftCodeAnalysisText.LinePosition.op_LessThan(otherLineSpan:getEndLinePosition(), this.LineSpan:getEndLinePosition())
      end
      CheckBlankLine = function (this, lastLine)
        local statement = nil
        if lastLine ~= - 1 then
          if MicrosoftCodeAnalysis.SyntaxTrivia.op_Inequality(this.SyntaxTrivia, nil) and MicrosoftCodeAnalysisCSharp.CSharpExtensions.Kind(this.SyntaxTrivia) == 8546 --[[SyntaxKind.DisabledTextTrivia]] then
            lastLine = lastLine + 1
          end
          local count = this.LineSpan:getStartLinePosition():getLine() - lastLine - 1
          if count > 0 then
            statement = CSharpLuaLuaAst.LuaBlankLinesStatement(count)
          end
        end
        lastLine = this.LineSpan:getEndLinePosition():getLine()
        return statement, lastLine
      end
      Visit = function (this, transfor)
        if this.SyntaxNode ~= nil then
          local default, extern = System.try(function ()
            local node = this.SyntaxNode:Accept(transfor, CSharpLuaLuaAst.LuaSyntaxNode)
            if node == nil then
              System.throw(CSharpLua.InvalidOperationException())
            end
            return true, node
          end, function (default)
            if System.is(default, CSharpLua.CompilationErrorException) then
              local e = default
              if e.SyntaxNode == nil then
                System.throw(CSharpLua.CompilationErrorException:new(2, this.SyntaxNode, e:getMessage()))
              end
              System.throw(e)
            else
              local e = default
              System.throw(System.Exception(("Compiler has a bug, thanks to commit issue at https://github.com/yanghuan/CSharp.lua/issue, {0}"):Format(CSharpLua.Utility.GetLocationString(this.SyntaxNode)), e))
            end
          end)
          if default then
            return extern
          end
        else
          local content = this.SyntaxTrivia:ToString()
          repeat
            local ref = MicrosoftCodeAnalysisCSharp.CSharpExtensions.Kind(this.SyntaxTrivia)
            if ref == 8541 --[[SyntaxKind.SingleLineCommentTrivia]] then
              do
                local commentContent = content:Substring(2 --[[kCommentCharCount]])
                return CSharpLuaLuaAst.LuaShortCommentStatement(commentContent)
              end
            elseif ref == 8542 --[[SyntaxKind.MultiLineCommentTrivia]] then
              do
                local commentContent = content:Substring(2 --[[kCommentCharCount]], #content - 2 --[[kCommentCharCount]] - 2 --[[kCommentCharCount]])
                local codeStatement
                local out
                out, codeStatement = CheckInsertLuaCodeTemplate(this, commentContent)
                if out then
                  return codeStatement
                end
                return CSharpLuaLuaAst.LuaLongCommentStatement(commentContent)
              end
            elseif ref == 8544 --[[SyntaxKind.SingleLineDocumentationCommentTrivia]] or ref == 8546 --[[SyntaxKind.DisabledTextTrivia]] then
              do
                return CSharpLuaLuaAst.LuaStatementSyntax.Empty
              end
            elseif ref == 8552 --[[SyntaxKind.RegionDirectiveTrivia]] or ref == 8553 --[[SyntaxKind.EndRegionDirectiveTrivia]] then
              do
                return CSharpLuaLuaAst.LuaShortCommentStatement(content)
              end
            else
              System.throw(CSharpLua.InvalidOperationException())
            end
          until 1
        end
      end
      CheckInsertLuaCodeTemplate = function (this, commentContent, statement)
        statement = nil

        local openBracket = ("[" --[[Tokens.OpenBracket]]):get(0)
        local index = commentContent:IndexOf(openBracket)
        if index ~= - 1 then
          local equals = ("=" --[[Tokens.Equals]]):get(0)
          local count = 0
          index = index + 1
          while commentContent:get(index) == equals do
            index = index + 1
            count = count + 1
          end
          if commentContent:get(index) == openBracket then
            local closeToken = ("]" --[[Tokens.CloseBracket]] .. System.String(equals, count)) .. "]" --[[Tokens.CloseBracket]]
            local begin = index + 1
            local end_ = commentContent:IndexOf(closeToken, begin)
            if end_ ~= - 1 then
              local start = begin + #closeToken
              local code = commentContent:Substring(start, end_ - start)
              statement = CSharpLua.Utility.ToStatement(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, code:Trim()))
              return true, statement
            end
          end
        end

        return false, statement
      end
      class = {
        __inherits__ = function (global)
          return {
            System.IComparable_1(class)
          }
        end,
        CompareTo = CompareTo,
        Contains = Contains,
        CheckBlankLine = CheckBlankLine,
        Visit = Visit,
        __ctor__ = {
          __ctor1__,
          __ctor2__
        }
      }
      return class
    end)
    namespace.class("LuaSyntaxSearcher", function (namespace)
      namespace.class("FoundException", function (namespace)
        local __ctor__
        __ctor__ = function (this)
          this.__base__.__ctor__(this)
        end
        return {
          __inherits__ = function (global)
            return {
              System.Exception
            }
          end,
          __ctor__ = __ctor__
        }
      end)
      local Found, Find, class
      Found = function (this)
        System.throw(class.FoundException())
      end
      Find = function (this, root)
        local default, extern = System.try(function ()
          this:Visit(root)
        end, function (default)
          if System.is(default, class.FoundException) then
            return true, true
          else
            return 1, default
          end
        end)
        if default then
          return extern
        end
        return false
      end
      class = {
        __inherits__ = function (global)
          return {
            Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker
          }
        end,
        Found = Found,
        Find = Find
      }
      return class
    end)
    namespace.class("LocalVarSearcher", function (namespace)
      local VisitParameter, VisitVariableDeclarator, __ctor__
      __ctor__ = function (this, name)
        this.__base__.__ctor__(this)
        this.name_ = name
      end
      VisitParameter = function (this, node)
        if node:getIdentifier():getValueText() == this.name_ then
          this:Found()
        end
      end
      VisitVariableDeclarator = function (this, node)
        if node:getIdentifier():getValueText() == this.name_ then
          this:Found()
        end
      end
      return {
        __inherits__ = function (global)
          return {
            global.CSharpLua.LuaSyntaxNodeTransform.LuaSyntaxSearcher
          }
        end,
        VisitParameter = VisitParameter,
        VisitVariableDeclarator = VisitVariableDeclarator,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("ContinueSearcher", function (namespace)
      local VisitContinueStatement
      VisitContinueStatement = function (this, node)
        this:Found()
      end
      return {
        __inherits__ = function (global)
          return {
            global.CSharpLua.LuaSyntaxNodeTransform.LuaSyntaxSearcher
          }
        end,
        VisitContinueStatement = VisitContinueStatement
      }
    end)
    namespace.class("ReturnStatementSearcher", function (namespace)
      local VisitReturnStatement
      VisitReturnStatement = function (this, node)
        this:Found()
      end
      return {
        __inherits__ = function (global)
          return {
            global.CSharpLua.LuaSyntaxNodeTransform.LuaSyntaxSearcher
          }
        end,
        VisitReturnStatement = VisitReturnStatement
      }
    end)
    namespace.interface("IQueryRangeVariable", function ()
      return {}
    end)
    namespace.class("QueryIdentifier", function (namespace)
      local AddPackCount, getHasPack, getName, GetIdentifierName, __init__, __ctor__
      __init__ = function (this)
        this.Identifier = System.default(MicrosoftCodeAnalysis.SyntaxToken)
      end
      __ctor__ = function (this, identifier, name)
        __init__(this)
        this.Identifier = identifier:__clone__()
        this.name_ = name
      end
      AddPackCount = function (this)
        this.packCount_ = this.packCount_ + 1
      end
      getHasPack = function (this)
        return this.packCount_ > 0
      end
      getName = function (this)
        if getHasPack(this) then
          System.throw(CSharpLua.InvalidOperationException())
        end
        return this.name_
      end
      GetIdentifierName = function (this)
        local name = this.name_
        do
          local i = 0
          while i < this.packCount_ do
            name = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Placeholder, name, false)
            i = i + 1
          end
        end
        return name
      end
      return {
        __inherits__ = function (global)
          return {
            global.CSharpLua.LuaSyntaxNodeTransform.IQueryRangeVariable
          }
        end,
        packCount_ = 0,
        AddPackCount = AddPackCount,
        getHasPack = getHasPack,
        getName = getName,
        GetIdentifierName = GetIdentifierName,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("QueryPackVariable", function (namespace)
      local getName, AddPackCount, __ctor__
      __ctor__ = function (this, x1, x2)
        this.x1_ = x1
        this.x2_ = x2
        AddPackCount(this)
      end
      getName = function (this)
        return CSharpLuaLuaAst.LuaIdentifierNameSyntax.Placeholder
      end
      AddPackCount = function (this)
        this.x1_:AddPackCount()
        this.x2_:AddPackCount()
      end
      return {
        __inherits__ = function (global)
          return {
            global.CSharpLua.LuaSyntaxNodeTransform.IQueryRangeVariable
          }
        end,
        getName = getName,
        AddPackCount = AddPackCount,
        __ctor__ = __ctor__
      }
    end)
    local getIsGetInheritTypeName, operatorTokenMapps_, getXmlMetaProvider, GetOperatorToken, GetOperatorToken1, getIsLuaNewest, getCurCompilationUnit, getCurType, 
    getCurTypeSymbol, getCurTypeDeclaration, getCurFunction, getCurFunctionOrNull, getCurMethodInfoOrNull, PushFunction, PopFunction, getCurBlock, 
    getCurBlockOrNull, VisitCompilationUnit, VisitNamespaceDeclaration, BuildTypeMembers, CheckBaseTypeGenericKind, CheckSpeaicalGenericArgument, BuildTypeDeclaration, CheckTypeDeclaration, 
    VisitTypeDeclaration, AcceptPartialType, GetTypeDeclarationName, VisitClassDeclaration, VisitStructDeclaration, VisitInterfaceDeclaration, VisitEnumDeclaration, VisitDelegateDeclaration, 
    VisitYield, BuildMethodDeclaration, VisitMethodDeclaration, GetPredefinedValueTypeDefaultValue, GetTempIdentifier, BuildDefaultValue, VisitBaseFieldDeclarationSyntax, VisitFieldDeclaration, 
    GetFieldValueExpression, AddField, VisitPropertyDeclaration, IsReadOnlyProperty, VisitEventDeclaration, VisitEventFieldDeclaration, VisitEnumMemberDeclaration, VisitIndexerDeclaration, 
    VisitBracketedParameterList, VisitParameterList, BuildParameterList, VisitParameter, VisitTriviaAndNode, VisitBlock, VisitReturnStatement, VisitExpressionStatement, 
    BuildCommonAssignmentExpression, BuildCommonAssignmentExpression1, BuildDelegateAssignmentExpression, BuildBinaryInvokeAssignmentExpression, BuildBinaryInvokeAssignmentExpression1, BuildIntegerDivAssignmentExpression, BuildLuaSimpleAssignmentExpression, BuildLuaAssignmentExpression, 
    BuildBitAssignmentExpression, InternalVisitAssignmentExpression, IsInlineAssignment, VisitAssignmentExpression, BuildInvokeRefOrOut, CheckCodeTemplateInvocationExpression, BuildInvocationArguments, CheckInvocationExpression, 
    VisitInvocationExpression, BuildExtensionMethodInvocation, GetDeafultParameterValue, CheckInvocationDeafultArguments, CheckInvocationDeafultArguments1, CheckPrevIsInvokeStatement, BuildMemberAccessTargetExpression, BuildMemberAccessExpression, 
    CheckMemberAccessCodeTemplate, InternalVisitMemberAccessExpression, IsDelegateInvoke, VisitMemberAccessExpression, BuildStaticFieldName, IsInternalNode, VisitFieldOrEventIdentifierName, GetMethodNameExpression, 
    GetFieldNameExpression, VisitIdentifierName, VisitQualifiedName, FillInvocationArgument, BuildArgumentList, BuildArgumentList1, VisitArgumentList, VisitArgument, 
    VisitLiteralExpression, VisitLocalDeclarationStatement, VisitVariableDeclaration, VisitVariableDeclarator, VisitEqualsValueClause, VisitPredefinedType, WriteStatementOrBlock, VisitIfStatement, 
    VisitElseClause, VisitSwitchStatement, VisitSwitchSection, VisitCaseSwitchLabel, BuildSwitchLabelWhenClause, VisitCasePatternSwitchLabel, VisitWhenClause, VisitConstantPattern, 
    VisitBreakStatement, WrapStringConcatExpression, BuildStringConcatExpression, BuildStringConcatExpression1, BuildBinaryInvokeExpression, BuildIntegerDivExpression, BuildBinaryExpression, BuildBitExpression, 
    VisitBinaryExpression, IsSingleLineUnary, BuildPrefixUnaryExpression, BuildPropertyPrefixUnaryExpression, GetTempUnaryExpression, GetTempPropertyUnaryExpression, VisitPrefixUnaryExpression, BuildPostfixUnaryExpression, 
    BuildPropertyPostfixUnaryExpression, VisitPostfixUnaryExpression, VisitContinueStatement, VisitLoopBody, CheckForeachCast, VisitForEachStatement, VisitForEachVariableStatement, VisitWhileStatement, 
    VisitForStatement, VisitDoStatement, VisitYieldStatement, VisitParenthesizedExpression, VisitConditionalExpression, VisitGotoStatement, VisitLabeledStatement, VisitEmptyStatement, 
    VisitCastExpression, BuildCastExpression, GetCastToNumberExpression, VisitCheckedStatement, VisitCheckedExpression, codeTemplateRegex_, IsLocalVarExists, FindFromCur, 
    FindParent, FindParent1, FindParent2, GetUniqueIdentifier, CheckLocalBadWord, AddLocalVariableMapping, CheckLocalVariableName, CheckLocalSymbolName, 
    GetConstructorIndex, IsContinueExists, IsReturnExists, GetCaseLabelIndex, BuildCodeTemplateExpression, BuildCodeTemplateExpression1, BuildCodeTemplateExpression2, AddCodeTemplateExpression, 
    InternalBuildCodeTemplateExpression, AddExportEnum, IsPropertyField, IsEventFiled, IsInternalMember, BuildEmptyArray, BuildArray, BuildArray1, 
    GetLiteralExpression, GetConstLiteralExpression, GetConstLiteralExpression1, GetConstExpression, BuildStringLiteralTokenExpression, BuildStringLiteralExpression, BuildVerbatimStringExpression, GetCallerAttributeKind, 
    GetCallerAttributeKind1, CheckCallerAttribute, CheckUsingStaticNameSyntax, MayBeFalse, MayBeNull, MayBeNullOrFalse, ImportTypeName, GetTypeShortName, 
    GetTypeName, BuildFieldOrPropertyMemberAccessExpression, VisitAttributeList, VisitAttributeArgument, VisitNameColon, VisitAttributeArgumentList, VisitNameEquals, BuildObjectCreationInvocation, 
    VisitAttribute, BuildAttributes, TryAddStructDefaultMethod, CheckValueTypeClone, BuildDocumentationComment, BuildInheritTypeName, VisitTypeParameterList, FillExternalTypeParameters, 
    BuildTypeParameters, CheckFieldNameOfProtobufnet, GetMemberName, AddInnerName, RemoveNilArgumentsAtTail, TryRemoveNilArgumentsAtTail, PushChecked, PopChecked, 
    getIsCurChecked, CheckConversion, GetOperatorMemberAccessExpression, BuildConversionExpression, GerUserDefinedOperatorExpression, IsNumericalForVariableMatch, IsNumericalForLess, IsNumericalForGreater, 
    GetNumericalForStatement, GetValueTupleDefaultExpression, GetDefaultValueExpression, BuildDeconstructExpression, BuildDeconstructExpression1, VisitObjectCreationExpression, BuildObjectInitializerExpression, VisitAnonymousObjectMemberDeclarator, 
    VisitAnonymousObjectCreationExpression, VisitInitializerExpression, VisitBracketedArgumentList, VisitImplicitElementAccess, VisitGenericName, VisitOmittedArraySizeExpression, VisitArrayRankSpecifier, VisitArrayType, 
    FillMultiArrayInitializer, BuildArrayCreationExpression, VisitArrayCreationExpression, BuildArrayTypeFromInitializer, VisitImplicitArrayCreationExpression, BuildCallBaseConstructor, BuildCallBaseConstructor1, VisitConstructorDeclaration, 
    VisitSimpleBaseType, VisitLambdaExpression, VisitSimpleLambdaExpression, VisitParenthesizedLambdaExpression, VisitAnonymousMethodExpression, VisitTypeParameter, VisitTypeOfExpression, VisitThrowStatement, 
    VisitThrowExpression, VisitCatchFilterClause, VisitCatchClause, VisitCatchDeclaration, VisitTryCatchesExpress, BuildCheckReturnInvocationExpression, VisitFinallyClause, VisitTryStatement, 
    VisitUsingStatement, VisitThisExpression, CheckBaseVisitType, VisitBaseExpression, VisitConditionalAccessExpression, VisitMemberBindingExpression, VisitElementBindingExpression, VisitDefaultExpression, 
    VisitElementAccessExpression, VisitInterpolatedStringExpression, VisitInterpolation, VisitInterpolatedStringText, VisitAliasQualifiedName, BuildOperatorMethodDeclaration, VisitConversionOperatorDeclaration, VisitOperatorDeclaration, 
    VisitSizeOfExpression, VisitStackAllocArrayCreationExpression, VisitUnsafeStatement, VisitFixedStatement, VisitLockStatement, VisitArrowExpressionClause, VisitLocalFunctionStatement, VisitDeclarationExpression, 
    VisitDiscardDesignation, VisitSingleVariableDesignation, VisitIsPatternExpression, VisitDeclarationPattern, VisitRefExpression, VisitTupleType, BuildValueTupleCreateExpression, VisitTupleExpression, 
    VisitParenthesizedVariableDesignation, AddRangeIdentifier, GetRangeIdentifierName, VisitQueryExpression, VisitFromClause, VisitWhereClause, VisitQueryBody, VisitSelectClause, 
    VisitQueryContinuation, VisitLetClause, VisitJoinClause, VisitJoinIntoClause, BuildQueryWhere, BuildOrdering, BuildQueryOrderBy, BuildQuerySelect, 
    BuildGroupClause, CreateQueryAnonymousType, IsSpecialQueryNode, BuildFromClause, BuildLetClause, BuildQueryJoin, BuildJoinClause, BuildQueryBody, 
    BuildQueryContinuation, class, __staticCtor__, __init__, __ctor__
    __staticCtor__ = function (this)
      operatorTokenMapps_ = System.create(System.Dictionary(System.String, System.String)(), function (default)
        default:set("!=", "~=" --[[Tokens.NotEquals]])
        default:set("!", "not" --[[Keyword.Not]])
        default:set("&&", "and" --[[Keyword.And]])
        default:set("||", "or" --[[Keyword.Or]])
        default:set("??", "or" --[[Keyword.Or]])
        default:set("^", "~" --[[Tokens.BitXor]])
      end)
      codeTemplateRegex_ = SystemTextRegularExpressions.Regex([[(,?\s*)\{(\*?[\w|^]+)\}]], 8 --[[RegexOptions.Compiled]])
    end
    __init__ = function (this)
      this.compilationUnits_ = System.Stack(CSharpLuaLuaAst.LuaCompilationUnitSyntax)()
      this.typeDeclarations_ = System.Stack(class.TypeDeclarationInfo)()
      this.functions_ = System.Stack(CSharpLuaLuaAst.LuaFunctionExpressionSyntax)()
      this.methodInfos_ = System.Stack(class.MethodInfo)()
      this.blocks_ = System.Stack(CSharpLuaLuaAst.LuaBlockSyntax)()
      this.ifStatements_ = System.Stack(CSharpLuaLuaAst.LuaIfStatementSyntax)()
      this.switchs_ = System.Stack(CSharpLuaLuaAst.LuaSwitchAdapterStatementSyntax)()
      this.localReservedNames_ = System.Dictionary(MicrosoftCodeAnalysis.ISymbol, CSharpLuaLuaAst.LuaIdentifierNameSyntax)()
      this.checkeds_ = System.Stack(System.Boolean)()
      this.conditionalTemps_ = System.Stack(CSharpLuaLuaAst.LuaIdentifierNameSyntax)()
      this.queryIdentifiers_ = System.List(class.QueryIdentifier)()
    end
    __ctor__ = function (this, generator, semanticModel)
      __init__(this)
      this.__base__.__ctor__(this)
      this.generator_ = generator
      this.semanticModel_ = semanticModel
    end
    getIsGetInheritTypeName = function (this)
      return this.inheritNameNodeCounter_ > 0
    end
    getXmlMetaProvider = function (this)
      return this.generator_.XmlMetaProvider
    end
    GetOperatorToken = function (operatorToken)
      local token = operatorToken:getValueText()
      return CSharpLua.Utility.GetOrDefault1(operatorTokenMapps_, token, token, System.String, System.String)
    end
    GetOperatorToken1 = function (token)
      return CSharpLua.Utility.GetOrDefault1(operatorTokenMapps_, token, token, System.String, System.String)
    end
    getIsLuaNewest = function (this)
      return this.generator_.Setting.IsNewest
    end
    getCurCompilationUnit = function (this)
      return this.compilationUnits_:Peek()
    end
    getCurType = function (this)
      return this.typeDeclarations_:Peek().TypeDeclaration
    end
    getCurTypeSymbol = function (this)
      return this.typeDeclarations_:Peek().TypeSymbol
    end
    getCurTypeDeclaration = function (this)
      local default
      if #this.typeDeclarations_ > 0 then
        default = this.typeDeclarations_:Peek()
      else
        default = nil
      end
      return default
    end
    getCurFunction = function (this)
      return this.functions_:Peek()
    end
    getCurFunctionOrNull = function (this)
      local default
      if #this.functions_ > 0 then
        default = this.functions_:Peek()
      else
        default = nil
      end
      return default
    end
    getCurMethodInfoOrNull = function (this)
      local default
      if #this.methodInfos_ > 0 then
        default = this.methodInfos_:Peek()
      else
        default = nil
      end
      return default
    end
    PushFunction = function (this, function_)
      this.functions_:Push(function_)
      this.localMappingCounter_ = this.localMappingCounter_ + 1
    end
    PopFunction = function (this)
      this.functions_:Pop()
      this.localMappingCounter_ = this.localMappingCounter_ - 1
      if this.localMappingCounter_ == 0 then
        this.localReservedNames_:Clear()
      end
    end
    getCurBlock = function (this)
      return this.blocks_:Peek()
    end
    getCurBlockOrNull = function (this)
      local default
      if #this.blocks_ > 0 then
        default = this.blocks_:Peek()
      else
        default = nil
      end
      return default
    end
    VisitCompilationUnit = function (this, node)
      local compilationUnit = CSharpLuaLuaAst.LuaCompilationUnitSyntax(node:getSyntaxTree():getFilePath())
      this.compilationUnits_:Push(compilationUnit)

      local statements = VisitTriviaAndNode(this, node, node:getMembers(), false)
      for _, statement in System.each(statements) do
        local typeeDeclaration = statement
        if System.is(typeeDeclaration, CSharpLuaLuaAst.LuaTypeDeclarationSyntax) then
          local ns = CSharpLuaLuaAst.LuaNamespaceDeclarationSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Empty, false)
          ns:AddStatement(typeeDeclaration)
          compilationUnit:AddStatement(ns)
        else
          compilationUnit:AddStatement(statement)
        end
      end

      this.compilationUnits_:Pop()
      return compilationUnit
    end
    VisitNamespaceDeclaration = function (this, node)
      local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, node, System.default(SystemThreading.CancellationToken))
      local isContained = MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8842 --[[SyntaxKind.NamespaceDeclaration]])
      local default
      if isContained then
        default = symbol:getName()
      else
        default = symbol:ToString()
      end
      local name = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, default)
      local namespaceDeclaration = CSharpLuaLuaAst.LuaNamespaceDeclarationSyntax(name, isContained)
      local statements = VisitTriviaAndNode(this, node, node:getMembers(), true)
      namespaceDeclaration:AddStatements(statements)
      return namespaceDeclaration
    end
    BuildTypeMembers = function (this, typeDeclaration, node)
      if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node, 8857 --[[SyntaxKind.InterfaceDeclaration]]) then
        for _, member in System.each(node:getMembers()) do
          local newMember = member:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
          local kind = member:Kind()
          if kind >= 8855 --[[SyntaxKind.ClassDeclaration]] and kind <= 8858 --[[SyntaxKind.EnumDeclaration]] then
            typeDeclaration:AddStatement(System.cast(CSharpLuaLuaAst.LuaTypeDeclarationSyntax, newMember))
          end
        end
      end
    end
    CheckBaseTypeGenericKind = function (this, hasExtendSelf, typeSymbol, baseType)
      if not hasExtendSelf then
        if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(baseType, 8865 --[[SyntaxKind.SimpleBaseType]]) then
          local baseNode = System.cast(MicrosoftCodeAnalysisCSharpSyntax.SimpleBaseTypeSyntax, baseType)
          if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(baseNode:getType(), 8618 --[[SyntaxKind.GenericName]]) then
            local baseGenericNameNode = System.cast(MicrosoftCodeAnalysisCSharpSyntax.GenericNameSyntax, baseNode:getType())
            local baseTypeSymbol = System.cast(MicrosoftCodeAnalysis.INamedTypeSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, baseGenericNameNode, System.default(SystemThreading.CancellationToken)):getType())
            hasExtendSelf = CSharpLua.Utility.IsExtendSelf(typeSymbol, baseTypeSymbol)
          end
        end
      end
      return hasExtendSelf
    end
    CheckSpeaicalGenericArgument = function (this, typeSymbol)
      local interfaceType = SystemLinq.ImmutableArrayExtensions.FirstOrDefault(typeSymbol:getInterfaces(), function (i)
        return CSharpLua.Utility.IsGenericIEnumerableType(i)
      end, MicrosoftCodeAnalysis.INamedTypeSymbol)
      if interfaceType ~= nil then
        local isBaseImplementation = typeSymbol:getBaseType() ~= nil and SystemLinq.ImmutableArrayExtensions.Any(typeSymbol:getBaseType():getAllInterfaces(), function (i)
          return CSharpLua.Utility.IsGenericIEnumerableType(i)
        end, MicrosoftCodeAnalysis.INamedTypeSymbol)
        if not isBaseImplementation then
          local argumentType = CSharpLua.Utility.First(interfaceType:getTypeArguments(), MicrosoftCodeAnalysis.ITypeSymbol)
          local typeName = GetTypeName(this, argumentType)
          return System.create(CSharpLuaLuaAst.LuaSpeaicalGenericType(), function (default)
            default.Name = CSharpLuaLuaAst.LuaIdentifierNameSyntax.GenericT
            default.Value = typeName
            default.IsLazy = argumentType:getKind() ~= 17 --[[SymbolKind.TypeParameter]] and CSharpLua.Utility.IsFromCode(argumentType)
          end)
        end
      end
      return nil
    end
    BuildTypeDeclaration = function (this, typeSymbol, node, typeDeclaration)
      this.typeDeclarations_:Push(class.TypeDeclarationInfo(typeSymbol, typeDeclaration))

      local comments = BuildDocumentationComment(this, node)
      typeDeclaration:AddDocument(comments)

      local attributes = BuildAttributes(this, node:getAttributeLists())
      typeDeclaration:AddClassAttributes(attributes)

      BuildTypeParameters(this, typeSymbol, node, typeDeclaration)
      if node:getBaseList() ~= nil then
        local hasExtendSelf = false
        local baseTypes = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)()
        for _, baseType in System.each(node:getBaseList():getTypes()) do
          local baseTypeName = BuildInheritTypeName(this, baseType)
          baseTypes:Add(baseTypeName)
          hasExtendSelf = CheckBaseTypeGenericKind(this, hasExtendSelf, typeSymbol, baseType)
        end
        local genericArgument = CheckSpeaicalGenericArgument(this, typeSymbol)
        typeDeclaration:AddBaseTypes(baseTypes, genericArgument)
        if hasExtendSelf and not CSharpLua.Utility.HasStaticCtor(typeSymbol) then
          typeDeclaration:SetStaticCtorEmpty()
        end
      end

      BuildTypeMembers(this, typeDeclaration, node)
      CheckTypeDeclaration(this, typeSymbol, typeDeclaration)

      this.typeDeclarations_:Pop()
      getCurCompilationUnit(this):AddTypeDeclarationCount()
    end
    CheckTypeDeclaration = function (this, typeSymbol, typeDeclaration)
      if typeDeclaration:getIsNoneCtros() then
        local bseTypeSymbol = typeSymbol:getBaseType()
        if bseTypeSymbol ~= nil then
          local isNeedCallBase
          if typeDeclaration:getIsInitStatementExists() then
            isNeedCallBase = not bseTypeSymbol:getConstructors():getIsEmpty()
          else
            isNeedCallBase = this.generator_:HasStaticCtor(bseTypeSymbol) or Linq.Count(bseTypeSymbol:getConstructors()) > 1
          end
          if isNeedCallBase then
            local baseCtorInvoke = BuildCallBaseConstructor1(this, typeSymbol)
            if baseCtorInvoke ~= nil then
              local function_ = CSharpLuaLuaAst.LuaConstructorAdapterExpressionSyntax()
              function_:AddParameter1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This)
              function_:AddStatement1(baseCtorInvoke)
              typeDeclaration:AddCtor(function_, false)
            end
          end
        end
      elseif typeSymbol:getIsValueType() then
        local function_ = CSharpLuaLuaAst.LuaConstructorAdapterExpressionSyntax()
        function_:AddParameter1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This)
        typeDeclaration:AddCtor(function_, true)
      end

      if typeSymbol:getIsValueType() then
        TryAddStructDefaultMethod(this, typeSymbol, typeDeclaration)
      end

      if typeDeclaration:getIsIgnoreExport() then
        this.generator_:AddIgnoreExportType(typeSymbol)
      end
    end
    VisitTypeDeclaration = function (this, typeSymbol, node, typeDeclaration)
      if CSharpLua.Utility.IsPartial(node:getModifiers()) then
        if typeSymbol:getDeclaringSyntaxReferences():getLength() > 1 then
          this.generator_:AddPartialTypeDeclaration(typeSymbol, node, typeDeclaration, getCurCompilationUnit(this))
          typeDeclaration.IsPartialMark = true
        else
          BuildTypeDeclaration(this, typeSymbol, node, typeDeclaration)
        end
      else
        BuildTypeDeclaration(this, typeSymbol, node, typeDeclaration)
      end
      return typeSymbol
    end
    AcceptPartialType = function (this, major, typeDeclarations)
      this.compilationUnits_:Push(major.CompilationUnit)
      this.typeDeclarations_:Push(class.TypeDeclarationInfo(major.Symbol, major.TypeDeclaration))

      local attributes = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)()
      for _, typeDeclaration in System.each(typeDeclarations) do
        this.semanticModel_ = this.generator_:GetSemanticModel(typeDeclaration.Node:getSyntaxTree())
        local document = BuildDocumentationComment(this, typeDeclaration.Node)
        major.TypeDeclaration:AddDocument(document)

        local expressions = BuildAttributes(this, typeDeclaration.Node:getAttributeLists())
        attributes:AddRange(expressions)
      end
      major.TypeDeclaration:AddClassAttributes(attributes)

      BuildTypeParameters(this, major.Symbol, major.Node, major.TypeDeclaration)
      local baseTypes = System.List(MicrosoftCodeAnalysisCSharpSyntax.BaseTypeSyntax)()
      local baseSymbols = System.HashSet(MicrosoftCodeAnalysis.ITypeSymbol)()
      for _, typeDeclaration in System.each(typeDeclarations) do
        if typeDeclaration.Node:getBaseList() ~= nil then
          for _, baseTypeSyntax in System.each(typeDeclaration.Node:getBaseList():getTypes()) do
            local semanticModel = this.generator_:GetSemanticModel(baseTypeSyntax:getSyntaxTree())
            local baseTypeSymbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(semanticModel, baseTypeSyntax:getType(), System.default(SystemThreading.CancellationToken)):getType()
            if baseSymbols:Add(baseTypeSymbol) then
              baseTypes:Add(baseTypeSyntax)
            end
          end
        end
      end

      if #baseTypes > 0 then
        if #baseTypes > 1 then
          local baseTypeIndex = baseTypes:FindIndex(System.bind(this.generator_, this.generator_.IsBaseType))
          if baseTypeIndex > 0 then
            local baseType = baseTypes:get(baseTypeIndex)
            baseTypes:RemoveAt(baseTypeIndex)
            baseTypes:Insert(0, baseType)
          end
        end

        local hasExtendSelf = false
        local baseTypeExpressions = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)()
        for _, baseType in System.each(baseTypes) do
          this.semanticModel_ = this.generator_:GetSemanticModel(baseType:getSyntaxTree())
          local baseTypeName = BuildInheritTypeName(this, baseType)
          baseTypeExpressions:Add(baseTypeName)
          hasExtendSelf = CheckBaseTypeGenericKind(this, hasExtendSelf, major.Symbol, baseType)
        end
        local genericArgument = CheckSpeaicalGenericArgument(this, major.Symbol)
        major.TypeDeclaration:AddBaseTypes(baseTypeExpressions, genericArgument)
        if hasExtendSelf and not CSharpLua.Utility.HasStaticCtor(major.Symbol) then
          major.TypeDeclaration:SetStaticCtorEmpty()
        end
      end

      for _, typeDeclaration in System.each(typeDeclarations) do
        this.semanticModel_ = this.generator_:GetSemanticModel(typeDeclaration.Node:getSyntaxTree())
        BuildTypeMembers(this, major.TypeDeclaration, typeDeclaration.Node)
      end

      CheckTypeDeclaration(this, major.Symbol, major.TypeDeclaration)
      this.typeDeclarations_:Pop()
      this.compilationUnits_:Pop()

      major.TypeDeclaration.IsPartialMark = false
      major.CompilationUnit:AddTypeDeclarationCount()
    end
    GetTypeDeclarationName = function (this, typeDeclaration, name, typeSymbol)
      typeSymbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, typeDeclaration, System.default(SystemThreading.CancellationToken))
      name = this.generator_:GetTypeDeclarationName(typeSymbol)
      return name, typeSymbol
    end
    VisitClassDeclaration = function (this, node)
      local name
      local typeSymbol
      name, typeSymbol = GetTypeDeclarationName(this, node)
      local classDeclaration = CSharpLuaLuaAst.LuaClassDeclarationSyntax(name)
      VisitTypeDeclaration(this, typeSymbol, node, classDeclaration)
      return classDeclaration
    end
    VisitStructDeclaration = function (this, node)
      local name
      local typeSymbol
      name, typeSymbol = GetTypeDeclarationName(this, node)
      local structDeclaration = CSharpLuaLuaAst.LuaStructDeclarationSyntax(name)
      VisitTypeDeclaration(this, typeSymbol, node, structDeclaration)
      return structDeclaration
    end
    VisitInterfaceDeclaration = function (this, node)
      local name
      local typeSymbol
      name, typeSymbol = GetTypeDeclarationName(this, node)
      local interfaceDeclaration = CSharpLuaLuaAst.LuaInterfaceDeclarationSyntax(name)
      local symbol = VisitTypeDeclaration(this, typeSymbol, node, interfaceDeclaration)
      return interfaceDeclaration
    end
    VisitEnumDeclaration = function (this, node)
      local name
      local typeSymbol
      name, typeSymbol = GetTypeDeclarationName(this, node)
      local enumDeclaration = CSharpLuaLuaAst.LuaEnumDeclarationSyntax(typeSymbol:ToString(), name, getCurCompilationUnit(this))
      this.typeDeclarations_:Push(class.TypeDeclarationInfo(typeSymbol, enumDeclaration))
      local document = BuildDocumentationComment(this, node)
      enumDeclaration:AddDocument(document)
      for _, member in System.each(node:getMembers()) do
        local statement = System.cast(CSharpLuaLuaAst.LuaKeyValueTableItemSyntax, member:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        enumDeclaration:Add(statement)
      end
      this.typeDeclarations_:Pop()
      this.generator_:AddEnumDeclaration(enumDeclaration)
      return enumDeclaration
    end
    VisitDelegateDeclaration = function (this, node)
      return CSharpLuaLuaAst.LuaStatementSyntax.Empty
    end
    VisitYield = function (this, returnType, function_)
      assert(function_.HasYield)

      local retrurnTypeSymbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, returnType, System.default(SystemThreading.CancellationToken)):getType()
      local name = "yield" --[[Tokens.Yield]] .. retrurnTypeSymbol:getName()
      local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.System1, CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name), false)
      local invokeExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess)
      local wrapFunction = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()

      local parameters = function_.ParameterList.Parameters
      wrapFunction.ParameterList.Parameters:AddRange(parameters)
      wrapFunction:AddStatements(function_.Body.Statements)
      invokeExpression:AddArgument(wrapFunction)
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(returnType, 8618 --[[SyntaxKind.GenericName]]) then
        local genericNameSyntax = System.cast(MicrosoftCodeAnalysisCSharpSyntax.GenericNameSyntax, returnType)
        local typeName = genericNameSyntax:getTypeArgumentList():getArguments():First()
        local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, typeName:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        invokeExpression:AddArgument(expression)
      else
        invokeExpression:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Object)
      end
      invokeExpression.ArgumentList.Arguments:AddRange(Linq.Select(parameters, function (i)
        return CSharpLuaLuaAst.LuaArgumentSyntax(i.Identifier)
      end, CSharpLuaLuaAst.LuaArgumentSyntax))

      local returnStatement = CSharpLuaLuaAst.LuaReturnStatementSyntax(invokeExpression)
      function_.Body.Statements:Clear()
      function_:AddStatement(returnStatement)
    end
    BuildMethodDeclaration = function (this, node, attributeLists, parameterList, typeParameterList, body, expressionBody, returnType)
      local symbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, MicrosoftCodeAnalysis.ModelExtensions.GetDeclaredSymbol(this.semanticModel_, node, System.default(SystemThreading.CancellationToken)))
      local refOrOutParameters = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)()
      local methodInfo = class.MethodInfo:new(2, symbol, refOrOutParameters)
      this.methodInfos_:Push(methodInfo)

      local methodName
      if symbol:getMethodKind() == 17 --[[MethodKind.LocalFunction]] then
        methodName = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, symbol:getName())
        methodName = CheckLocalVariableName(this, methodName, node)
      else
        methodName = GetMemberName(this, symbol)
      end
      local function_ = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      PushFunction(this, function_)

      local document = BuildDocumentationComment(this, node)
      local isPrivate = CSharpLua.Utility.IsPrivate(symbol) and symbol:getExplicitInterfaceImplementations():getIsEmpty()
      if not symbol:getIsStatic() then
        function_:AddParameter1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This)
        if isPrivate and this.generator_:IsMonoBehaviourSpeicalMethod(symbol) then
          isPrivate = false
        end
      elseif CSharpLua.Utility.IsMainEntryPoint(symbol) then
        isPrivate = false
        local success = this.generator_:SetMainEntryPoint(symbol)
        if not success then
          System.throw(CSharpLua.CompilationErrorException:new(2, node, "has more than one entry point"))
        end
      end

      if not CSharpLua.Utility.IsPrivate(symbol) then
        local attributes = BuildAttributes(this, attributeLists:__clone__())
        getCurType(this):AddMethodAttributes(methodName, attributes)
      end

      for _, parameterNode in System.each(parameterList:getParameters()) do
        local parameter = System.cast(CSharpLuaLuaAst.LuaParameterSyntax, parameterNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        function_:AddParameter(parameter)
        if CSharpLua.Utility.IsOutOrRef(parameterNode:getModifiers()) then
          refOrOutParameters:Add(parameter.Identifier)
        end
      end

      if typeParameterList ~= nil then
        local typeParameters = System.cast(CSharpLuaLuaAst.LuaParameterListSyntax, typeParameterList:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        function_:AddParameters(typeParameters.Parameters)
      end

      if body ~= nil then
        local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, body:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        function_:AddStatements(block.Statements)
      else
        this.blocks_:Push(function_.Body)
        local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, expressionBody:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        this.blocks_:Pop()
        function_:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(expression))
      end

      if function_.HasYield then
        VisitYield(this, returnType, function_)
      else
        if symbol:getReturnsVoid() and #refOrOutParameters > 0 then
          local returnStatement = CSharpLuaLuaAst.LuaMultipleReturnStatementSyntax()
          returnStatement.Expressions:AddRange(refOrOutParameters)
          function_:AddStatement(returnStatement)
        end
      end

      PopFunction(this)
      this.methodInfos_:Pop()
      return System.create(class.MethodDeclarationResult(), function (default)
        default.Symbol = symbol
        default.Name = methodName
        default.Function = function_
        default.IsPrivate = isPrivate
        default.Document = document
      end)
    end
    VisitMethodDeclaration = function (this, node)
      if not CSharpLua.Utility.IsAbstract(node:getModifiers()) then
        local result = BuildMethodDeclaration(this, node, node:getAttributeLists(), node:getParameterList(), node:getTypeParameterList(), node:getBody(), node:getExpressionBody(), node:getReturnType())
        getCurType(this):AddMethod(result.Name, result.Function, result.IsPrivate, result.Document)
        return result.Function
      end
      return this.__base__.VisitMethodDeclaration(this, node)
    end
    GetPredefinedValueTypeDefaultValue = function (typeSymbol)
      repeat
        local default = typeSymbol:getSpecialType()
        if default == 0 --[[SpecialType.None]] then
          do
            if typeSymbol:getTypeKind() == 5 --[[TypeKind.Enum]] then
              return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.Zero
            elseif CSharpLua.Utility.IsTimeSpanType(typeSymbol) then
              return BuildDefaultValue(CSharpLuaLuaAst.LuaIdentifierNameSyntax.TimeSpan)
            end
            return nil
          end
        elseif default == 7 --[[SpecialType.System_Boolean]] then
          do
            return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.False)
          end
        elseif default == 8 --[[SpecialType.System_Char]] then
          do
            return CSharpLuaLuaAst.LuaCharacterLiteralExpression(0 --[['\0']] --[[default(char)]])
          end
        elseif default == 9 --[[SpecialType.System_SByte]] or default == 10 --[[SpecialType.System_Byte]] or default == 11 --[[SpecialType.System_Int16]] or default == 12 --[[SpecialType.System_UInt16]] or default == 13 --[[SpecialType.System_Int32]] or default == 14 --[[SpecialType.System_UInt32]] or default == 15 --[[SpecialType.System_Int64]] or default == 16 --[[SpecialType.System_UInt64]] then
          do
            return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.Zero
          end
        elseif default == 18 --[[SpecialType.System_Single]] or default == 19 --[[SpecialType.System_Double]] then
          do
            return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.ZeroFloat
          end
        elseif default == 33 --[[SpecialType.System_DateTime]] then
          do
            return BuildDefaultValue(CSharpLuaLuaAst.LuaIdentifierNameSyntax.DateTime)
          end
        else
          return nil
        end
      until 1
    end
    GetTempIdentifier = function (this, node)
      local default = getCurFunction(this)
      local extern = default.TempIndex
      default.TempIndex = extern + 1
      local index = extern
      local name = CSharpLua.Utility.GetOrDefault(CSharpLuaLuaAst.LuaSyntaxNode.TempIdentifiers, index, nil, System.String)
      if name == nil then
        System.throw(CSharpLua.CompilationErrorException:new(2, node, ("Your code is startling,{0} temporary variables is not enough"):Format(#CSharpLuaLuaAst.LuaSyntaxNode.TempIdentifiers)))
      end
      return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name)
    end
    BuildDefaultValue = function (typeExpression)
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.SystemDefault, typeExpression)
    end
    VisitBaseFieldDeclarationSyntax = function (this, node)
      if not CSharpLua.Utility.IsConst(node:getModifiers()) then
        local isStatic = CSharpLua.Utility.IsStatic(node:getModifiers())
        local isPrivate = CSharpLua.Utility.IsPrivate1(node:getModifiers())
        local isReadOnly = CSharpLua.Utility.IsReadOnly(node:getModifiers())

        local type = node:getDeclaration():getType()
        local typeSymbol = System.cast(MicrosoftCodeAnalysis.ITypeSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, type, System.default(SystemThreading.CancellationToken)):getSymbol())
        local isImmutable = CSharpLua.Utility.IsImmutable(typeSymbol)
        for _, variable in System.each(node:getDeclaration():getVariables()) do
          local continue
          repeat
            local variableSymbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, variable, System.default(SystemThreading.CancellationToken))
            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node, 8874 --[[SyntaxKind.EventFieldDeclaration]]) then
              local eventSymbol = System.cast(MicrosoftCodeAnalysis.IEventSymbol, variableSymbol)
              if not IsEventFiled(this, eventSymbol) then
                local eventName = GetMemberName(this, eventSymbol)
                local innerName = AddInnerName(this, eventSymbol)
                local default = variable:getInitializer()
                if default ~= nil then
                  default = default.getValue()
                end
                local valueIsLiteral
                local extern
                extern, valueIsLiteral = GetFieldValueExpression(this, type, typeSymbol, default)
                local valueExpression = extern
                local typeExpression = nil
                if isStatic then
                  typeExpression = GetTypeName(this, eventSymbol:getContainingType())
                end
                getCurType(this):AddEvent(eventName, innerName, valueExpression, isImmutable and valueIsLiteral, isStatic, isPrivate, typeExpression)
                continue = true
                break
              end
            else
              if not isStatic and isPrivate then
                local name = variable:getIdentifier():getValueText()
                local ref
                ref, name = CheckFieldNameOfProtobufnet(this, name, variableSymbol:getContainingType())
                local success = ref
                if success then
                  local out = variable:getInitializer()
                  if out ~= nil then
                    out = out.getValue()
                  end
                  AddField(this, CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name), typeSymbol, type, out, isImmutable, isStatic, isPrivate, isReadOnly, node:getAttributeLists())
                  continue = true
                  break
                end
              end
            end
            local fieldName = GetMemberName(this, variableSymbol)
            local try = variable:getInitializer()
            if try ~= nil then
              try = try.getValue()
            end
            AddField(this, fieldName, typeSymbol, type, try, isImmutable, isStatic, isPrivate, isReadOnly, node:getAttributeLists())
            continue = true
          until 1
          if not continue then
            break
          end
        end
      else
        local isPrivate = CSharpLua.Utility.IsPrivate1(node:getModifiers())
        local type = node:getDeclaration():getType()
        local typeSymbol = System.cast(MicrosoftCodeAnalysis.ITypeSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, type, System.default(SystemThreading.CancellationToken)):getSymbol())
        if typeSymbol:getSpecialType() == 20 --[[SpecialType.System_String]] then
          for _, variable in System.each(node:getDeclaration():getVariables()) do
            local constValue = this.semanticModel_:GetConstantValue(variable:getInitializer():getValue(), System.default(SystemThreading.CancellationToken))
            assert(constValue:getHasValue())
            local v = System.cast(System.String, constValue:getValue())
            if #v > 15 --[[LuaSyntaxNodeTransform.kStringConstInlineCount]] then
              local variableSymbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, variable, System.default(SystemThreading.CancellationToken))
              local fieldName = GetMemberName(this, variableSymbol)
              AddField(this, fieldName, typeSymbol, type, variable:getInitializer():getValue(), true, true, isPrivate, true, node:getAttributeLists())
            end
          end
        end
      end
    end
    VisitFieldDeclaration = function (this, node)
      VisitBaseFieldDeclarationSyntax(this, node)
      return this.__base__.VisitFieldDeclaration(this, node)
    end
    GetFieldValueExpression = function (this, type, typeSymbol, expression, valueIsLiteral)
      local valueExpression = nil
      valueIsLiteral = false
      if expression ~= nil and not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expression, 8754 --[[SyntaxKind.NullLiteralExpression]]) then
        valueExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        valueIsLiteral = System.is(expression, MicrosoftCodeAnalysisCSharpSyntax.LiteralExpressionSyntax)
      end

      if valueExpression == nil then
        if typeSymbol:getIsValueType() and not CSharpLua.Utility.IsNullableType(typeSymbol) then
          local defalutValue = GetPredefinedValueTypeDefaultValue(typeSymbol)
          if defalutValue ~= nil then
            valueExpression = defalutValue
            valueIsLiteral = true
          else
            valueExpression = GetDefaultValueExpression(this, typeSymbol)
          end
        end
      end
      return valueExpression, valueIsLiteral
    end
    AddField = function (this, name, typeSymbol, type, expression, isImmutable, isStatic, isPrivate, isReadOnly, attributeLists)
      if not (isStatic and isPrivate) then
        local attributes = BuildAttributes(this, attributeLists:__clone__())
        getCurType(this):AddFieldAttributes(name, attributes)
      end
      local valueIsLiteral
      local default
      default, valueIsLiteral = GetFieldValueExpression(this, type, typeSymbol, expression)
      local valueExpression = default
      getCurType(this):AddField(name, valueExpression, isImmutable and valueIsLiteral, isStatic, isPrivate, isReadOnly)
    end
    VisitPropertyDeclaration = function (this, node)
      if not CSharpLua.Utility.IsAbstract(node:getModifiers()) then
        local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, node, System.default(SystemThreading.CancellationToken))
        local isStatic = symbol:getIsStatic()
        local isPrivate = CSharpLua.Utility.IsPrivate(symbol)
        local hasGet = false
        local hasSet = false
        local propertyName = GetMemberName(this, symbol)
        if node:getAccessorList() ~= nil then
          for _, accessor in System.each(node:getAccessorList():getAccessors()) do
            if accessor:getBody() ~= nil or accessor:getExpressionBody() ~= nil then
              local isGet = MicrosoftCodeAnalysis.CSharpExtensions.IsKind(accessor, 8896 --[[SyntaxKind.GetAccessorDeclaration]])
              local functionExpression = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
              if not isStatic then
                functionExpression:AddParameter1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This)
              end
              PushFunction(this, functionExpression)
              if accessor:getBody() ~= nil then
                local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, accessor:getBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
                functionExpression:AddStatements(block.Statements)
              else
                this.blocks_:Push(functionExpression.Body)
                local bodyExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, accessor:getExpressionBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
                this.blocks_:Pop()
                if isGet then
                  functionExpression:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(bodyExpression))
                else
                  functionExpression:AddStatement1(bodyExpression)
                end
              end
              PopFunction(this)
              local name = CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax:new(1, true, propertyName)
              getCurType(this):AddMethod(name, functionExpression, isPrivate)
              if isGet then
                assert(not hasGet)
                hasGet = true
              else
                assert(not hasSet)
                functionExpression:AddParameter1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Value)
                name.IsGetOrAdd = false
                hasSet = true
              end

              if not isPrivate then
                local attributes = BuildAttributes(this, accessor:getAttributeLists())
                getCurType(this):AddMethodAttributes(name, attributes)
              end
            end
          end
        else
          assert(not hasGet)
          local name = CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax:new(1, true, propertyName)

          local functionExpression = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
          PushFunction(this, functionExpression)
          this.blocks_:Push(functionExpression.Body)
          local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpressionBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          this.blocks_:Pop()
          PopFunction(this)

          if not isStatic then
            functionExpression:AddParameter1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This)
          end
          local returnStatement = CSharpLuaLuaAst.LuaReturnStatementSyntax(expression)
          functionExpression:AddStatement(returnStatement)
          getCurType(this):AddMethod(name, functionExpression, isPrivate)
          hasGet = true
        end

        if not hasGet and not hasSet then
          local typeSymbol = symbol:getType()
          local isImmutable = CSharpLua.Utility.IsImmutable(typeSymbol)
          local isField = IsPropertyField(this, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, node, System.default(SystemThreading.CancellationToken)))
          if isField then
            local isReadOnly = IsReadOnlyProperty(this, node)
            local default = node:getInitializer()
            if default ~= nil then
              default = default.getValue()
            end
            AddField(this, propertyName, typeSymbol, node:getType(), default, isImmutable, isStatic, isPrivate, isReadOnly, node:getAttributeLists())
          else
            if not isPrivate then
              local attributes = BuildAttributes(this, node:getAttributeLists())
              getCurType(this):AddFieldAttributes(propertyName, attributes)
            end
            local innerName = AddInnerName(this, symbol)
            local extern = node:getInitializer()
            if extern ~= nil then
              extern = extern.getValue()
            end
            local valueIsLiteral
            local ref
            ref, valueIsLiteral = GetFieldValueExpression(this, node:getType(), typeSymbol, extern)
            local valueExpression = ref
            local typeExpression = nil
            if isStatic then
              typeExpression = GetTypeName(this, symbol:getContainingType())
            end
            getCurType(this):AddProperty(propertyName, innerName, valueExpression, isImmutable and valueIsLiteral, isStatic, isPrivate, typeExpression)
          end
        else
          if not isPrivate then
            local attributes = BuildAttributes(this, node:getAttributeLists())
            getCurType(this):AddFieldAttributes(propertyName, attributes)
          end
        end
      end
      return this.__base__.VisitPropertyDeclaration(this, node)
    end
    IsReadOnlyProperty = function (this, node)
      return node:getAccessorList():getAccessors():getCount() == 1 and node:getAccessorList():getAccessors():get(0):getBody() == nil
    end
    VisitEventDeclaration = function (this, node)
      if not CSharpLua.Utility.IsAbstract(node:getModifiers()) then
        local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, node, System.default(SystemThreading.CancellationToken))
        local isStatic = symbol:getIsStatic()
        local isPrivate = CSharpLua.Utility.IsPrivate(symbol)
        local eventName = GetMemberName(this, symbol)
        for _, accessor in System.each(node:getAccessorList():getAccessors()) do
          local functionExpression = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
          if not isStatic then
            functionExpression:AddParameter1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This)
          end
          functionExpression:AddParameter1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Value)
          PushFunction(this, functionExpression)
          local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, accessor:getBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          PopFunction(this)
          functionExpression:AddStatements(block.Statements)
          local name = CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax:new(1, false, eventName)
          getCurType(this):AddMethod(name, functionExpression, isPrivate)
          if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(accessor, 8899 --[[SyntaxKind.RemoveAccessorDeclaration]]) then
            name.IsGetOrAdd = false
          end

          if not isPrivate then
            local attributes = BuildAttributes(this, accessor:getAttributeLists())
            getCurType(this):AddMethodAttributes(name, attributes)
          end
        end
      end
      return this.__base__.VisitEventDeclaration(this, node)
    end
    VisitEventFieldDeclaration = function (this, node)
      VisitBaseFieldDeclarationSyntax(this, node)
      return this.__base__.VisitEventFieldDeclaration(this, node)
    end
    VisitEnumMemberDeclaration = function (this, node)
      local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, node, System.default(SystemThreading.CancellationToken))
      assert(symbol:getHasConstantValue())
      local identifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText())
      local value = CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, symbol:getConstantValue():ToString())
      return CSharpLuaLuaAst.LuaKeyValueTableItemSyntax(CSharpLuaLuaAst.LuaTableLiteralKeySyntax(identifier), value)
    end
    VisitIndexerDeclaration = function (this, node)
      if not CSharpLua.Utility.IsAbstract(node:getModifiers()) then
        local Fill
        local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, node, System.default(SystemThreading.CancellationToken))
        local isPrivate = CSharpLua.Utility.IsPrivate(symbol)
        local indexName = GetMemberName(this, symbol)
        local parameterList = System.cast(CSharpLuaLuaAst.LuaParameterListSyntax, node:getParameterList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))

        Fill = function (action)
          local function_ = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
          function_:AddParameter1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This)
          function_.ParameterList.Parameters:AddRange(parameterList.Parameters)
          local name = CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax:new(1, true, indexName)
          PushFunction(this, function_)
          action(function_, name)
          PopFunction(this)
          getCurType(this):AddMethod(name, function_, isPrivate)
        end

        if node:getAccessorList() ~= nil then
          for _, accessor in System.each(node:getAccessorList():getAccessors()) do
            Fill(function (function_, name)
              local isGet = MicrosoftCodeAnalysis.CSharpExtensions.IsKind(accessor, 8896 --[[SyntaxKind.GetAccessorDeclaration]])
              if accessor:getBody() ~= nil then
                local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, accessor:getBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
                function_:AddStatements(block.Statements)
              else
                local bodyExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, accessor:getExpressionBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
                if isGet then
                  function_:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(bodyExpression))
                else
                  function_:AddStatement1(bodyExpression)
                end
              end
              if not isGet then
                function_:AddParameter1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Value)
                name.IsGetOrAdd = false
              end
            end)
          end
        else
          Fill(function (function_, name)
            local bodyExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpressionBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            function_:AddStatement1(bodyExpression)
          end)
        end
      end
      return this.__base__.VisitIndexerDeclaration(this, node)
    end
    VisitBracketedParameterList = function (this, node)
      return BuildParameterList(this, node:getParameters())
    end
    VisitParameterList = function (this, node)
      return BuildParameterList(this, node:getParameters())
    end
    BuildParameterList = function (this, parameters)
      local parameterList = CSharpLuaLuaAst.LuaParameterListSyntax()
      for _, parameter in System.each(parameters) do
        local newNode = System.cast(CSharpLuaLuaAst.LuaParameterSyntax, parameter:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        parameterList.Parameters:Add(newNode)
      end
      return parameterList
    end
    VisitParameter = function (this, node)
      local identifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText())
      identifier = CheckLocalVariableName(this, identifier, node)
      return CSharpLuaLuaAst.LuaParameterSyntax(identifier)
    end
    VisitTriviaAndNode = function (this, rootNode, nodes, isCheckBlank)
      return System.yieldIEnumerable(function (this, rootNode, nodes, isCheckBlank)
        local syntaxTrivias = Linq.Where(rootNode:DescendantTrivia(nil, false), function (i)
          return CSharpLua.Utility.IsExportSyntaxTrivia(i, rootNode)
        end)
        local syntaxTriviaNodes = Linq.Select(syntaxTrivias, function (i)
          return class.BlockCommonNode:new(1, i:__clone__())
        end, class.BlockCommonNode)

        local list = Linq.ToList(Linq.Select(nodes, function (i)
          return class.BlockCommonNode:new(2, i)
        end, class.BlockCommonNode))
        local hasComments = false
        for _, comment in System.each(syntaxTriviaNodes) do
          local isContains = Linq.Any(list, function (i)
            return i:Contains(comment)
          end)
          if not isContains then
            list:Add(comment)
            hasComments = true
          end
        end
        if hasComments then
          list:Sort()
        end

        local lastLine = - 1
        for _, common in System.each(list) do
          if isCheckBlank then
            local default
            default, lastLine = common:CheckBlankLine(lastLine)
            local black = default
            if black ~= nil then
              System.yieldReturn(black)
            end
          end
          System.yieldReturn(System.cast(CSharpLuaLuaAst.LuaStatementSyntax, common:Visit(this)))
        end
      end, CSharpLuaLuaAst.LuaStatementSyntax, this, rootNode, nodes, isCheckBlank)
    end
    VisitBlock = function (this, node)
      local block = CSharpLuaLuaAst.LuaBlockStatementSyntax()
      this.blocks_:Push(block)

      local statements = VisitTriviaAndNode(this, node, node:getStatements(), true)
      block.Statements:AddRange(statements)

      this.blocks_:Pop()
      return block
    end
    VisitReturnStatement = function (this, node)
      if System.is(getCurFunction(this), CSharpLuaLuaAst.LuaCheckReturnFunctionExpressionSyntax) then
        local returnStatement = CSharpLuaLuaAst.LuaMultipleReturnStatementSyntax()
        returnStatement.Expressions:Add(CSharpLuaLuaAst.LuaIdentifierNameSyntax.True)
        if node:getExpression() ~= nil then
          local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          returnStatement.Expressions:Add(expression)
        end
        return returnStatement
      else
        local curMethodInfo = getCurMethodInfoOrNull(this)
        if curMethodInfo ~= nil and curMethodInfo.RefOrOutParameters:getCount() > 0 then
          local returnStatement = CSharpLuaLuaAst.LuaMultipleReturnStatementSyntax()
          if node:getExpression() ~= nil then
            local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            returnStatement.Expressions:Add(expression)
          end
          returnStatement.Expressions:AddRange(curMethodInfo.RefOrOutParameters)
          return returnStatement
        else
          local default = node:getExpression()
          if default ~= nil then
            default = default:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
          end
          local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, default)
          return CSharpLuaLuaAst.LuaReturnStatementSyntax(expression)
        end
      end
    end
    VisitExpressionStatement = function (this, node)
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      if expression ~= CSharpLuaLuaAst.LuaExpressionSyntax.EmptyExpression then
        if System.is(expression, CSharpLuaLuaAst.LuaLiteralExpressionSyntax) then
          return CSharpLuaLuaAst.LuaShortCommentExpressionStatement(expression)
        end
        return CSharpLuaLuaAst.LuaExpressionStatementSyntax(expression)
      else
        return CSharpLuaLuaAst.LuaStatementSyntax.Empty
      end
    end
    BuildCommonAssignmentExpression = function (this, left, right, operatorToken, isRightParenthesized)
      local propertyAdapter = left
      if System.is(propertyAdapter, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax) then
        propertyAdapter.ArgumentList:AddArgument1(CSharpLuaLuaAst.LuaBinaryExpressionSyntax(propertyAdapter:GetCloneOfGet(), operatorToken, right))
        return propertyAdapter
      else
        if isRightParenthesized then
          right = CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(right)
        end
        return CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(left, CSharpLuaLuaAst.LuaBinaryExpressionSyntax(left, operatorToken, right))
      end
    end
    BuildCommonAssignmentExpression1 = function (this, leftNode, rightNode, operatorToken)
      local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, rightNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      return BuildCommonAssignmentExpression(this, left, right, operatorToken, System.is(rightNode, MicrosoftCodeAnalysisCSharpSyntax.BinaryExpressionSyntax))
    end
    BuildDelegateAssignmentExpression = function (this, left, right, isPlus)
      local operatorToken = isPlus and "+" --[[Tokens.Plus]] or "-" --[[Tokens.Sub]]
      local propertyAdapter = left
      if System.is(propertyAdapter, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax) then
        if propertyAdapter:getIsProperty() then
          propertyAdapter.ArgumentList:AddArgument1(CSharpLuaLuaAst.LuaBinaryExpressionSyntax(propertyAdapter:GetCloneOfGet(), operatorToken, right))
          return propertyAdapter
        else
          propertyAdapter:setIsGetOrAdd(isPlus)
          propertyAdapter.ArgumentList:AddArgument1(right)
          return propertyAdapter
        end
      else
        return CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(left, CSharpLuaLuaAst.LuaBinaryExpressionSyntax(left, operatorToken, right))
      end
    end
    BuildBinaryInvokeAssignmentExpression = function (this, left, right, methodName)
      local propertyAdapter = left
      if System.is(propertyAdapter, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax) then
        local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, methodName, propertyAdapter:GetCloneOfGet(), right)
        propertyAdapter.ArgumentList:AddArgument1(invocation)
        return propertyAdapter
      else
        local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, methodName, left, right)
        return CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(left, invocation)
      end
    end
    BuildBinaryInvokeAssignmentExpression1 = function (this, leftNode, rightNode, methodName)
      local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, rightNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      return BuildBinaryInvokeAssignmentExpression(this, left, right, methodName)
    end
    BuildIntegerDivAssignmentExpression = function (this, leftNode, rightNode, methodName)
      if getIsLuaNewest(this) then
        return BuildCommonAssignmentExpression1(this, leftNode, rightNode, "//" --[[Tokens.IntegerDiv]])
      else
        return BuildBinaryInvokeAssignmentExpression1(this, leftNode, rightNode, methodName)
      end
    end
    BuildLuaSimpleAssignmentExpression = function (this, left, right)
      local propertyAdapter = left
      if System.is(propertyAdapter, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax) then
        propertyAdapter:setIsGetOrAdd(false)
        propertyAdapter.ArgumentList:AddArgument1(right)
        return propertyAdapter
      else
        return CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(left, right)
      end
    end
    BuildLuaAssignmentExpression = function (this, leftNode, rightNode, kind)
      repeat
        local default = kind
        if default == 8714 --[[SyntaxKind.SimpleAssignmentExpression]] then
          do
            local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, rightNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(leftNode, 9040 --[[SyntaxKind.DeclarationExpression]]) or MicrosoftCodeAnalysis.CSharpExtensions.IsKind(leftNode, 8926 --[[SyntaxKind.TupleExpression]]) then
              if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(rightNode, 8926 --[[SyntaxKind.TupleExpression]]) then
                right = BuildDeconstructExpression1(this, rightNode, right)
              end
            end
            return BuildLuaSimpleAssignmentExpression(this, left, right)
          end
        elseif default == 8715 --[[SyntaxKind.AddAssignmentExpression]] then
          do
            local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, leftNode, System.default(SystemThreading.CancellationToken)):getType()
            if CSharpLua.Utility.IsStringType(leftType) then
              local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
              local right = WrapStringConcatExpression(this, rightNode)
              return BuildCommonAssignmentExpression(this, left, right, ".." --[[Tokens.Concatenation]], System.is(rightNode, MicrosoftCodeAnalysisCSharpSyntax.BinaryExpressionSyntax))
            else
              local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
              local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, rightNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))

              if CSharpLua.Utility.IsDelegateType(leftType) then
                return BuildDelegateAssignmentExpression(this, left, right, true)
              else
                return BuildCommonAssignmentExpression(this, left, right, "+" --[[Tokens.Plus]], System.is(rightNode, MicrosoftCodeAnalysisCSharpSyntax.BinaryExpressionSyntax))
              end
            end
          end
        elseif default == 8716 --[[SyntaxKind.SubtractAssignmentExpression]] then
          do
            local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, rightNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))

            local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, leftNode, System.default(SystemThreading.CancellationToken)):getType()
            if CSharpLua.Utility.IsDelegateType(leftType) then
              return BuildDelegateAssignmentExpression(this, left, right, false)
            else
              return BuildCommonAssignmentExpression(this, left, right, "-" --[[Tokens.Sub]], System.is(rightNode, MicrosoftCodeAnalysisCSharpSyntax.BinaryExpressionSyntax))
            end
          end
        elseif default == 8717 --[[SyntaxKind.MultiplyAssignmentExpression]] then
          do
            return BuildCommonAssignmentExpression1(this, leftNode, rightNode, "*" --[[Tokens.Multiply]])
          end
        elseif default == 8718 --[[SyntaxKind.DivideAssignmentExpression]] then
          do
            local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, leftNode, System.default(SystemThreading.CancellationToken)):getType()
            local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, rightNode, System.default(SystemThreading.CancellationToken)):getType()
            if CSharpLua.Utility.IsIntegerType(leftType) and CSharpLua.Utility.IsIntegerType(rightType) then
              local extern
              if CSharpLua.Utility.IsNullableType(leftType) or CSharpLua.Utility.IsNullableType(rightType) then
                extern = CSharpLuaLuaAst.LuaIdentifierNameSyntax.IntegerDivOfNull
              else
                extern = CSharpLuaLuaAst.LuaIdentifierNameSyntax.IntegerDiv
              end
              local methodName = extern
              return BuildIntegerDivAssignmentExpression(this, leftNode, rightNode, methodName)
            else
              return BuildCommonAssignmentExpression1(this, leftNode, rightNode, "/" --[[Tokens.Div]])
            end
          end
        elseif default == 8719 --[[SyntaxKind.ModuloAssignmentExpression]] then
          do
            if not getIsLuaNewest(this) then
              local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, leftNode, System.default(SystemThreading.CancellationToken)):getType()
              local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, rightNode, System.default(SystemThreading.CancellationToken)):getType()
              if CSharpLua.Utility.IsIntegerType(leftType) and CSharpLua.Utility.IsIntegerType(rightType) then
                local ref
                if CSharpLua.Utility.IsNullableType(leftType) or CSharpLua.Utility.IsNullableType(rightType) then
                  ref = CSharpLuaLuaAst.LuaIdentifierNameSyntax.IntegerModOfNull
                else
                  ref = CSharpLuaLuaAst.LuaIdentifierNameSyntax.IntegerMod
                end
                local methodName = ref
                return BuildBinaryInvokeAssignmentExpression1(this, leftNode, rightNode, methodName)
              end
            end
            return BuildCommonAssignmentExpression1(this, leftNode, rightNode, "%" --[[Tokens.Mod]])
          end
        elseif default == 8720 --[[SyntaxKind.AndAssignmentExpression]] then
          do
            return BuildBitAssignmentExpression(this, leftNode, rightNode, "and" --[[Keyword.And]], "&" --[[Tokens.BitAnd]], CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitAnd, CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitAndOfNull)
          end
        elseif default == 8721 --[[SyntaxKind.ExclusiveOrAssignmentExpression]] then
          do
            return BuildBitAssignmentExpression(this, leftNode, rightNode, "~=" --[[Tokens.NotEquals]], "~" --[[Tokens.BitXor]], CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitXor, CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitXorOfNull)
          end
        elseif default == 8722 --[[SyntaxKind.OrAssignmentExpression]] then
          do
            return BuildBitAssignmentExpression(this, leftNode, rightNode, "or" --[[Keyword.Or]], "|" --[[Tokens.BitOr]], CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitOr, CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitOrOfNull)
          end
        elseif default == 8723 --[[SyntaxKind.LeftShiftAssignmentExpression]] then
          do
            if getIsLuaNewest(this) then
              return BuildCommonAssignmentExpression1(this, leftNode, rightNode, "<<" --[[Tokens.LeftShift]])
            else
              local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, leftNode, System.default(SystemThreading.CancellationToken)):getType()
              local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, rightNode, System.default(SystemThreading.CancellationToken)):getType()
              local out
              if CSharpLua.Utility.IsNullableType(leftType) or CSharpLua.Utility.IsNullableType(rightType) then
                out = CSharpLuaLuaAst.LuaIdentifierNameSyntax.ShiftLeftOfNull
              else
                out = CSharpLuaLuaAst.LuaIdentifierNameSyntax.ShiftLeft
              end
              local methodName = out
              return BuildBinaryInvokeAssignmentExpression1(this, leftNode, rightNode, methodName)
            end
          end
        elseif default == 8724 --[[SyntaxKind.RightShiftAssignmentExpression]] then
          do
            if getIsLuaNewest(this) then
              return BuildCommonAssignmentExpression1(this, leftNode, rightNode, ">>" --[[Tokens.RightShift]])
            else
              local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, leftNode, System.default(SystemThreading.CancellationToken)):getType()
              local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, rightNode, System.default(SystemThreading.CancellationToken)):getType()
              local try
              if CSharpLua.Utility.IsNullableType(leftType) or CSharpLua.Utility.IsNullableType(rightType) then
                try = CSharpLuaLuaAst.LuaIdentifierNameSyntax.ShiftRightOfNull
              else
                try = CSharpLuaLuaAst.LuaIdentifierNameSyntax.ShiftRight
              end
              local methodName = try
              return BuildBinaryInvokeAssignmentExpression1(this, leftNode, rightNode, methodName)
            end
          end
        else
          System.throw(System.NotImplementedException())
        end
      until 1
    end
    BuildBitAssignmentExpression = function (this, leftNode, rightNode, boolOperatorToken, otherOperatorToken, methodName, methodNameOfNull)
      local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, leftNode, System.default(SystemThreading.CancellationToken)):getType()
      if leftType:getSpecialType() == 7 --[[SpecialType.System_Boolean]] then
        return BuildCommonAssignmentExpression1(this, leftNode, rightNode, boolOperatorToken)
      elseif not getIsLuaNewest(this) then
        local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, rightNode, System.default(SystemThreading.CancellationToken)):getType()
        if CSharpLua.Utility.IsNullableType(leftType) or CSharpLua.Utility.IsNullableType(rightType) then
          methodName = methodNameOfNull
        end
        return BuildBinaryInvokeAssignmentExpression1(this, leftNode, rightNode, methodName)
      else
        local operatorToken = GetOperatorToken1(otherOperatorToken)
        return BuildCommonAssignmentExpression1(this, leftNode, rightNode, operatorToken)
      end
    end
    InternalVisitAssignmentExpression = function (this, node)
      local assignments = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)()

      while true do
        local leftExpression = node:getLeft()
        local rightExpression = node:getRight()
        local kind = node:Kind()

        local assignmentRight = rightExpression
        if System.is(assignmentRight, MicrosoftCodeAnalysisCSharpSyntax.AssignmentExpressionSyntax) then
          assignments:Add(BuildLuaAssignmentExpression(this, leftExpression, assignmentRight:getLeft(), kind))
          node = assignmentRight
        else
          assignments:Add(BuildLuaAssignmentExpression(this, leftExpression, rightExpression, kind))
          break
        end
      end

      if #assignments == 1 then
        return CSharpLua.Utility.First(assignments, CSharpLuaLuaAst.LuaExpressionSyntax)
      else
        assignments:Reverse()
        local multipleAssignment = CSharpLuaLuaAst.LuaLineMultipleExpressionSyntax()
        multipleAssignment.Assignments:AddRange(assignments)
        return multipleAssignment
      end
    end
    IsInlineAssignment = function (node)
      local isInlineAssignment = false
      local kind = MicrosoftCodeAnalysisCSharp.CSharpExtensions.Kind(node:getParent())
      if kind == 8632 --[[SyntaxKind.ParenthesizedExpression]] then
        isInlineAssignment = true
      else
        repeat
          local default = kind
          if default == 8797 --[[SyntaxKind.ExpressionStatement]] or default == 8917 --[[SyntaxKind.ArrowExpressionClause]] then
            break
          else
            isInlineAssignment = true
            break
          end
        until 1
      end
      return isInlineAssignment
    end
    VisitAssignmentExpression = function (this, node)
      local assignment = InternalVisitAssignmentExpression(this, node)
      if IsInlineAssignment(node) then
        getCurBlock(this).Statements:Add(CSharpLua.Utility.ToStatement(assignment))
        local lineMultipleExpression = assignment
        if System.is(lineMultipleExpression, CSharpLuaLuaAst.LuaLineMultipleExpressionSyntax) then
          assignment = CSharpLua.Utility.Last(lineMultipleExpression.Assignments, CSharpLuaLuaAst.LuaExpressionSyntax)
        end
        local assignmentExpression = assignment
        if System.is(assignmentExpression, CSharpLuaLuaAst.LuaAssignmentExpressionSyntax) then
          assignment = assignmentExpression.Left
        else
          assignment = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getLeft():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        end
      end
      return assignment
    end
    BuildInvokeRefOrOut = function (this, node, invocation, refOrOutArguments)
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8797 --[[SyntaxKind.ExpressionStatement]]) then
        local multipleAssignment = CSharpLuaLuaAst.LuaMultipleAssignmentExpressionSyntax()
        local symbolInfo = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node, System.default(SystemThreading.CancellationToken))
        local symbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, symbolInfo:getSymbol())
        if not symbol:getReturnsVoid() then
          local temp = GetTempIdentifier(this, node)
          getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, temp))
          multipleAssignment.Lefts:Add(temp)
        end
        multipleAssignment.Lefts:AddRange(refOrOutArguments)
        multipleAssignment.Rights:Add(invocation)
        return multipleAssignment
      else
        local temp = GetTempIdentifier(this, node)
        local multipleAssignment = CSharpLuaLuaAst.LuaMultipleAssignmentExpressionSyntax()
        multipleAssignment.Lefts:Add(temp)
        multipleAssignment.Lefts:AddRange(refOrOutArguments)
        multipleAssignment.Rights:Add(invocation)

        getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, temp))
        getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(multipleAssignment))
        return temp
      end
    end
    CheckCodeTemplateInvocationExpression = function (this, symbol, node)
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getExpression(), 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) then
        local codeTemplate = getXmlMetaProvider(this):GetMethodCodeTemplate(symbol)
        if codeTemplate ~= nil then
          local argumentExpressions = System.List(MicrosoftCodeAnalysisCSharpSyntax.ExpressionSyntax)()
          local memberAccessExpression = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MemberAccessExpressionSyntax, node:getExpression())
          if symbol:getIsExtensionMethod() then
            argumentExpressions:Add(memberAccessExpression:getExpression())
            if CSharpLua.Utility.IsSystemLinqEnumerable(symbol:getContainingType()) then
              getCurCompilationUnit(this):ImportLinq()
            end
          end
          argumentExpressions:AddRange(Linq.Select(node:getArgumentList():getArguments(), function (i)
            return i:getExpression()
          end, MicrosoftCodeAnalysisCSharpSyntax.ExpressionSyntax))
          local invocationExpression = BuildCodeTemplateExpression2(this, codeTemplate, memberAccessExpression:getExpression(), argumentExpressions, symbol:getTypeArguments())
          local refOrOuts = Linq.Where(node:getArgumentList():getArguments(), function (i)
            return MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i:getRefOrOutKeyword(), 8360 --[[SyntaxKind.RefKeyword]]) or MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i:getRefOrOutKeyword(), 8361 --[[SyntaxKind.OutKeyword]])
          end)
          if Linq.Any(refOrOuts) then
            return BuildInvokeRefOrOut(this, node, invocationExpression, Linq.Select(refOrOuts, function (i)
              return (System.cast(CSharpLuaLuaAst.LuaArgumentSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))).Expression
            end, CSharpLuaLuaAst.LuaExpressionSyntax))
          else
            return invocationExpression
          end
        end
      end
      return nil
    end
    BuildInvocationArguments = function (this, symbol, node, refOrOutArguments)
      refOrOutArguments = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)()
      local arguments
      if symbol ~= nil then
        arguments = BuildArgumentList(this, symbol, symbol:getParameters(), node:getArgumentList(), refOrOutArguments)
        local ignoreGeneric = this.generator_.XmlMetaProvider:IsMethodIgnoreGeneric(symbol)
        if not ignoreGeneric then
          for _, typeArgument in System.each(symbol:getTypeArguments()) do
            local typeName = GetTypeName(this, typeArgument)
            arguments:Add(typeName)
          end
        end
        TryRemoveNilArgumentsAtTail(this, symbol, arguments)
      else
        arguments = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)()
        for _, argument in System.each(node:getArgumentList():getArguments()) do
          if argument:getNameColon() ~= nil then
            System.throw(CSharpLua.CompilationErrorException:new(2, argument, "named argument is not support at dynamic"))
          end
          FillInvocationArgument(this, arguments, argument, SystemCollectionsImmutable.ImmutableArray_1(MicrosoftCodeAnalysis.IParameterSymbol).Empty, refOrOutArguments)
        end
      end
      return arguments, refOrOutArguments
    end
    CheckInvocationExpression = function (this, symbol, node, expression)
      local invocation
      if symbol ~= nil and symbol:getIsExtensionMethod() then
        local memberAccess = expression
        if System.is(memberAccess, CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax) then
          if System.is(memberAccess.Name, CSharpLuaLuaAst.LuaInternalMethodExpressionSyntax) then
            invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess.Name)
            invocation:AddArgument(memberAccess.Expression)
          else
            invocation = BuildExtensionMethodInvocation(this, symbol:getReducedFrom(), memberAccess.Expression, node)
          end
        else
          invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, expression)
        end
      else
        local memberAccess = expression
        if System.is(memberAccess, CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax) then
          if System.is(memberAccess.Name, CSharpLuaLuaAst.LuaInternalMethodExpressionSyntax) then
            invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess.Name)
            invocation:AddArgument(memberAccess.Expression)
          else
            invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess)
          end
        else
          invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, expression)
          if System.is(expression, CSharpLuaLuaAst.LuaInternalMethodExpressionSyntax) then
            if not symbol:getIsStatic() then
              invocation:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This)
            end
          end
        end
      end
      return invocation
    end
    VisitInvocationExpression = function (this, node)
      local constExpression = GetConstExpression(this, node)
      if constExpression ~= nil then
        return constExpression
      end

      local symbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node, System.default(SystemThreading.CancellationToken)):getSymbol())
      if symbol ~= nil then
        local codeTemplateExpression = CheckCodeTemplateInvocationExpression(this, symbol, node)
        if codeTemplateExpression ~= nil then
          return codeTemplateExpression
        end
      end

      local refOrOutArguments
      local default
      default, refOrOutArguments = BuildInvocationArguments(this, symbol, node)
      local arguments = default
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local invocation = CheckInvocationExpression(this, symbol, node, expression)
      invocation:AddArguments(arguments)
      if #refOrOutArguments > 0 then
        return BuildInvokeRefOrOut(this, node, invocation, refOrOutArguments)
      else
        return invocation
      end
    end
    BuildExtensionMethodInvocation = function (this, reducedFrom, expression, node)
      local typeName = GetTypeName(this, reducedFrom:getContainingType())
      local methodName = GetMemberName(this, reducedFrom)
      local typeMemberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(typeName, methodName, false)
      local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, typeMemberAccess)
      invocation:AddArgument(expression)
      return invocation
    end
    GetDeafultParameterValue = function (this, parameter, node, isCheckCallerAttribute)
      assert(parameter:getHasExplicitDefaultValue())
      local default
      if isCheckCallerAttribute then
        default = CheckCallerAttribute(this, parameter, node)
      else
        default = nil
      end
      local defaultValue = default
      if defaultValue == nil then
        if parameter:getExplicitDefaultValue() == nil and parameter:getType():getIsValueType() then
          defaultValue = GetDefaultValueExpression(this, parameter:getType())
        else
          defaultValue = GetLiteralExpression(this, parameter:getExplicitDefaultValue())
        end
      end
      assert(defaultValue ~= nil)
      return defaultValue
    end
    CheckInvocationDeafultArguments = function (this, symbol, parameters, arguments, argumentNodeInfos, node, isCheckCallerAttribute)
      if parameters:getLength() > #arguments then
        local optionalParameters = Linq.Skip(parameters, #arguments)
        for _, parameter in System.each(optionalParameters) do
          if parameter:getIsParams() then
            local arrayType = System.cast(MicrosoftCodeAnalysis.IArrayTypeSymbol, parameter:getType())
            local baseType = GetTypeName(this, arrayType:getElementType())
            local emptyArray = BuildEmptyArray(this, baseType)
            arguments:Add(emptyArray)
          else
            local defaultValue = GetDeafultParameterValue(this, parameter, node, isCheckCallerAttribute)
            arguments:Add(defaultValue)
          end
        end
      elseif not parameters:getIsEmpty() then
        local last = CSharpLua.Utility.Last(parameters, MicrosoftCodeAnalysis.IParameterSymbol)
        if last:getIsParams() and CSharpLua.Utility.IsFromCode(symbol) then
          if parameters:getLength() == #arguments then
            local paramsArgument = CSharpLua.Utility.Last(argumentNodeInfos, System.Tuple)
            if paramsArgument[1] ~= nil then
              local name = paramsArgument[1]:getName():getIdentifier():getValueText()
              if name ~= last:getName() then
                paramsArgument = Linq.First(argumentNodeInfos, function (i)
                  return i[1] ~= nil and i[1]:getName():getIdentifier():getValueText() == last:getName()
                end)
              end
            end
            local paramsType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, paramsArgument[2], System.default(SystemThreading.CancellationToken)):getType()
            if paramsType:getTypeKind() ~= 1 --[[TypeKind.Array]] then
              local arrayTypeSymbol = System.cast(MicrosoftCodeAnalysis.IArrayTypeSymbol, last:getType())
              local array = BuildArray(this, arrayTypeSymbol:getElementType(), System.Array(CSharpLuaLuaAst.LuaExpressionSyntax)(CSharpLua.Utility.Last(arguments, CSharpLuaLuaAst.LuaExpressionSyntax)))
              arguments:set(#arguments - 1, array)
            end
          else
            local otherParameterCount = parameters:getLength() - 1
            local arrayTypeSymbol = System.cast(MicrosoftCodeAnalysis.IArrayTypeSymbol, last:getType())
            local paramsArguments = Linq.Skip(arguments, otherParameterCount)
            local array = BuildArray1(this, arrayTypeSymbol:getElementType(), paramsArguments)
            arguments:RemoveRange(otherParameterCount, #arguments - otherParameterCount)
            arguments:Add(array)
          end
        end
      end

      do
        local i = 0
        while i < #arguments do
          if arguments:get(i) == nil then
            local defaultValue = GetDeafultParameterValue(this, parameters:get(i), node, isCheckCallerAttribute)
            arguments:set(i, defaultValue)
          end
          i = i + 1
        end
      end
    end
    CheckInvocationDeafultArguments1 = function (this, symbol, parameters, arguments, node)
      local argumentNodeInfos = Linq.ToList(Linq.Select(node:getArguments(), function (i)
        return System.tuple(i:getNameColon(), i:getExpression())
      end, System.Tuple))
      CheckInvocationDeafultArguments(this, symbol, parameters:__clone__(), arguments, argumentNodeInfos, node:getParent(), true)
    end
    CheckPrevIsInvokeStatement = function (this)
      local curBlock = getCurBlockOrNull(this)
      if curBlock ~= nil then
        for i = #curBlock.Statements - 1, 0, - 1 do
          local statement = curBlock.Statements:get(i)
          if not (System.is(statement, CSharpLuaLuaAst.LuaBlankLinesStatement)) then
            local expressionStatement = statement
            if System.is(expressionStatement, CSharpLuaLuaAst.LuaExpressionStatementSyntax) then
              if System.is(expressionStatement.Expression, CSharpLuaLuaAst.LuaInvocationExpressionSyntax) then
                curBlock.Statements:Add(CSharpLuaLuaAst.LuaStatementSyntax.Colon)
              end
            end
            break
          end
        end
      end
    end
    BuildMemberAccessTargetExpression = function (this, targetExpression)
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, targetExpression:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local kind = targetExpression:Kind()
      if (kind >= 8749 --[[SyntaxKind.NumericLiteralExpression]] and kind <= 8754 --[[SyntaxKind.NullLiteralExpression]]) or (System.is(expression, CSharpLuaLuaAst.LuaLiteralExpressionSyntax)) then
        CheckPrevIsInvokeStatement(this)
        expression = CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(expression)
      end
      return expression
    end
    BuildMemberAccessExpression = function (this, symbol, node)
      local isExtensionMethod = symbol:getKind() == 9 --[[SymbolKind.Method]] and (System.cast(MicrosoftCodeAnalysis.IMethodSymbol, symbol)):getIsExtensionMethod()
      if isExtensionMethod then
        return System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      else
        return BuildMemberAccessTargetExpression(this, node)
      end
    end
    CheckMemberAccessCodeTemplate = function (this, symbol, node)
      if symbol:getKind() == 6 --[[SymbolKind.Field]] then
        local fieldSymbol = System.cast(MicrosoftCodeAnalysis.IFieldSymbol, symbol)
        if fieldSymbol:getContainingType():getIsTupleType() then
          local elementIndex = CSharpLua.Utility.GetTupleElementIndex(fieldSymbol)
          local targetExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          return CSharpLuaLuaAst.LuaTableIndexAccessExpressionSyntax(targetExpression, CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(2, elementIndex))
        end

        local codeTemplate = getXmlMetaProvider(this):GetFieldCodeTemplate(fieldSymbol)
        if codeTemplate ~= nil then
          return BuildCodeTemplateExpression(this, codeTemplate, node:getExpression())
        end

        if fieldSymbol:getHasConstantValue() then
          return GetConstLiteralExpression(this, fieldSymbol)
        end
      elseif symbol:getKind() == 15 --[[SymbolKind.Property]] then
        local propertySymbol = System.cast(MicrosoftCodeAnalysis.IPropertySymbol, symbol)
        local isGet = not CSharpLua.Utility.IsAssignment(MicrosoftCodeAnalysisCSharp.CSharpExtensions.Kind(node:getParent()))
        local codeTemplate = getXmlMetaProvider(this):GetProertyCodeTemplate(propertySymbol, isGet)
        if codeTemplate ~= nil then
          local result = BuildCodeTemplateExpression(this, codeTemplate, node:getExpression())
          if codeTemplate:get(0) == 35 --[['#']] and MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent():getParent(), 8634 --[[SyntaxKind.InvocationExpression]]) then
            result = CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(result)
          end
          return result
        end
      end
      return nil
    end
    InternalVisitMemberAccessExpression = function (this, symbol, node)
      local codeTemplateExpression = CheckMemberAccessCodeTemplate(this, symbol, node)
      if codeTemplateExpression ~= nil then
        return codeTemplateExpression
      end

      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getExpression(), 8746 --[[SyntaxKind.ThisExpression]]) then
        return System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      end

      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getExpression(), 8747 --[[SyntaxKind.BaseExpression]]) then
        local baseExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        local nameExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        if symbol:getKind() == 15 --[[SymbolKind.Property]] or symbol:getKind() == 5 --[[SymbolKind.Event]] then
          local propertyMethod = nameExpression
          if System.is(propertyMethod, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax) then
            if baseExpression ~= CSharpLuaLuaAst.LuaIdentifierNameSyntax.This then
              propertyMethod.ArgumentList:AddArgument1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This)
            end
            propertyMethod:Update(baseExpression, true)
            return propertyMethod
          else
            return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(baseExpression, nameExpression, false)
          end
        else
          if baseExpression == CSharpLuaLuaAst.LuaIdentifierNameSyntax.This then
            return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(baseExpression, nameExpression, symbol:getKind() == 9 --[[SymbolKind.Method]])
          else
            local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(baseExpression, nameExpression, false)
            return CSharpLuaLuaAst.LuaInternalMethodExpressionSyntax(memberAccess)
          end
        end
      end

      if symbol:getIsStatic() and MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getExpression(), 8616 --[[SyntaxKind.IdentifierName]]) and getCurTypeSymbol(this) == symbol:getContainingSymbol() then
        local isOnlyName = false
        if symbol:getKind() == 9 --[[SymbolKind.Method]] then
          isOnlyName = true
        elseif symbol:getKind() == 15 --[[SymbolKind.Property]] or symbol:getKind() == 5 --[[SymbolKind.Event]] then
          if not this.generator_:IsPropertyFieldOrEventFiled(symbol) then
            isOnlyName = true
          end
        end
        if isOnlyName then
          return System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        end
      end

      local expression = BuildMemberAccessExpression(this, symbol, node:getExpression())
      local name = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      if symbol:getKind() == 15 --[[SymbolKind.Property]] or symbol:getKind() == 5 --[[SymbolKind.Event]] then
        return BuildFieldOrPropertyMemberAccessExpression(this, expression, name, symbol:getIsStatic())
      end

      if symbol:getKind() == 9 --[[SymbolKind.Method]] then
        if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8634 --[[SyntaxKind.InvocationExpression]]) then
          if not IsInternalMember(this, node:getName(), symbol) then
            name = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, name, false)
          end
          return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.DelegateBind, expression, name)
        elseif IsDelegateInvoke(symbol, node:getName()) then
          return expression
        end
      end

      return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, name, not symbol:getIsStatic() and symbol:getKind() == 9 --[[SymbolKind.Method]])
    end
    IsDelegateInvoke = function (symbol, name)
      return CSharpLua.Utility.IsDelegateType(symbol:getContainingType()) and name:getIdentifier():getValueText() == "Invoke"
    end
    VisitMemberAccessExpression = function (this, node)
      local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node, System.default(SystemThreading.CancellationToken)):getSymbol()
      if symbol == nil then
        -- dynamic
        local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        local name = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getName():getIdentifier():getValueText())
        return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, name, MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8634 --[[SyntaxKind.InvocationExpression]]))
      end

      if symbol:getKind() == 11 --[[SymbolKind.NamedType]] then
        local expressionSymbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node:getExpression(), System.default(SystemThreading.CancellationToken)):getSymbol()
        if expressionSymbol:getKind() == 12 --[[SymbolKind.Namespace]] then
          return node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
        end
      end

      local luaExpression = InternalVisitMemberAccessExpression(this, symbol, node)
      luaExpression = CheckConversion(this, node, luaExpression)
      return luaExpression
    end
    BuildStaticFieldName = function (this, symbol, isReadOnly, node)
      assert(symbol:getIsStatic())
      local name = GetMemberName(this, symbol)
      if not CSharpLua.Utility.IsPrivate(symbol) then
        if isReadOnly then
          if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8714 --[[SyntaxKind.SimpleAssignmentExpression]]) then
            local assignmentExpression = System.cast(MicrosoftCodeAnalysisCSharpSyntax.AssignmentExpressionSyntax, node:getParent())
            if assignmentExpression:getLeft() == node then
              getCurType(this):AddStaticReadOnlyAssignmentName(name)
            end
          end
          local newExpression
          local default
          default, newExpression = CheckUsingStaticNameSyntax(this, symbol, node, name)
          if default then
            return newExpression
          end
        else
          if IsInternalNode(this, node) then
            local ctor = getCurFunctionOrNull(this)
            if System.is(ctor, CSharpLuaLuaAst.LuaConstructorAdapterExpressionSyntax) and ctor.IsStatic then
              return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, name, false)
            else
              local typeName = GetTypeName(this, symbol:getContainingType())
              return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(typeName, name, false)
            end
          else
            local newExpression
            local extern
            extern, newExpression = CheckUsingStaticNameSyntax(this, symbol, node, name)
            if extern then
              return newExpression
            end
          end
        end
      end
      return name
    end
    IsInternalNode = function (this, node)
      local parentNode = node:getParent()
      repeat
        local default = MicrosoftCodeAnalysisCSharp.CSharpExtensions.Kind(parentNode)
        if default == 8689 --[[SyntaxKind.SimpleMemberAccessExpression]] then
          do
            local parent = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MemberAccessExpressionSyntax, parentNode)
            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(parent:getExpression(), 8746 --[[SyntaxKind.ThisExpression]]) then
              return true
            elseif parent:getExpression() == node then
              return true
            end
            return false
          end
        elseif default == 8707 --[[SyntaxKind.MemberBindingExpression]] or default == 8852 --[[SyntaxKind.NameEquals]] then
          do
            return false
          end
        elseif default == 8714 --[[SyntaxKind.SimpleAssignmentExpression]] then
          do
            local parent = System.cast(MicrosoftCodeAnalysisCSharpSyntax.AssignmentExpressionSyntax, parentNode)
            if parent:getRight() ~= node then
              if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(parent:getParent(), 8644 --[[SyntaxKind.ObjectInitializerExpression]]) then
                return false
              end
            end
            break
          end
        end
      until 1
      return true
    end
    VisitFieldOrEventIdentifierName = function (this, node, symbol, isProperty)
      local isField, isReadOnly
      if isProperty then
        local propertySymbol = System.cast(MicrosoftCodeAnalysis.IPropertySymbol, symbol)
        isField = IsPropertyField(this, propertySymbol)
        isReadOnly = propertySymbol:getIsReadOnly()
      else
        local eventSymbol = System.cast(MicrosoftCodeAnalysis.IEventSymbol, symbol)
        isField = IsEventFiled(this, eventSymbol)
        isReadOnly = false
      end

      if isField then
        if symbol:getIsStatic() then
          return BuildStaticFieldName(this, symbol, isReadOnly, node)
        else
          local fieldName = GetMemberName(this, symbol)
          if IsInternalNode(this, node) then
            return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, fieldName, false)
          else
            return fieldName
          end
        end
      else
        local name = GetMemberName(this, symbol)
        local identifierName = CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax:new(1, isProperty, name)
        if symbol:getIsStatic() then
          local identifierExpression = CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax:new(1, identifierName)
          local newExpression
          local default
          default, newExpression = CheckUsingStaticNameSyntax(this, symbol, node, identifierExpression)
          if default then
            return newExpression
          end
          return identifierExpression
        else
          if IsInternalMember(this, node, symbol) then
            local propertyAdapter = CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax:new(1, identifierName)
            propertyAdapter.ArgumentList:AddArgument1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This)
            return propertyAdapter
          else
            if IsInternalNode(this, node) then
              return CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, identifierName, true)
            else
              return CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax:new(1, identifierName)
            end
          end
        end
      end
    end
    GetMethodNameExpression = function (this, symbol, node)
      local methodName = GetMemberName(this, symbol)
      if symbol:getIsStatic() then
        local outExpression
        local default
        default, outExpression = CheckUsingStaticNameSyntax(this, symbol, node, methodName)
        if default then
          return outExpression
        end
        if IsInternalMember(this, node, symbol) then
          return CSharpLuaLuaAst.LuaInternalMethodExpressionSyntax(methodName)
        end
        return methodName
      else
        if IsInternalMember(this, node, symbol) then
          if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) and not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8634 --[[SyntaxKind.InvocationExpression]]) then
            return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.DelegateBind, CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, methodName)
          end
          return CSharpLuaLuaAst.LuaInternalMethodExpressionSyntax(methodName)
        else
          if IsInternalNode(this, node) then
            if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) and not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8634 --[[SyntaxKind.InvocationExpression]]) then
              return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.DelegateBind, CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, methodName, false))
            end

            local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, methodName, true)
            return memberAccess
          end
        end
      end
      return methodName
    end
    GetFieldNameExpression = function (this, symbol, node)
      if symbol:getIsStatic() then
        if symbol:getHasConstantValue() then
          if symbol:getType():getSpecialType() == 20 --[[SpecialType.System_String]] then
            if #(System.cast(System.String, symbol:getConstantValue())) <= 15 --[[LuaSyntaxNodeTransform.kStringConstInlineCount]] then
              return GetConstLiteralExpression(this, symbol)
            end
          else
            return GetConstLiteralExpression(this, symbol)
          end
        end
        return BuildStaticFieldName(this, symbol, symbol:getIsReadOnly(), node)
      else
        if IsInternalNode(this, node) then
          if CSharpLua.Utility.IsPrivate(symbol) and CSharpLua.Utility.IsFromCode(symbol) then
            local symbolName = symbol:getName()
            local default
            default, symbolName = CheckFieldNameOfProtobufnet(this, symbolName, symbol:getContainingType())
            local success = default
            if success then
              return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, symbolName), false)
            end
          end
          return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, GetMemberName(this, symbol), false)
        else
          return GetMemberName(this, symbol)
        end
      end
    end
    VisitIdentifierName = function (this, node)
      local function GetSampleName(nodeSymbol) 
        local nameIdentifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, nodeSymbol:getName())
        nameIdentifier = CheckLocalSymbolName(this, nodeSymbol, nameIdentifier)
        return nameIdentifier
      end

      local symbolInfo = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node, System.default(SystemThreading.CancellationToken))
      local symbol = symbolInfo:getSymbol()
      assert(symbol ~= nil)
      local identifier
      repeat
        local default = symbol:getKind()
        if default == 8 --[[SymbolKind.Local]] then
          do
            local localSymbol = System.cast(MicrosoftCodeAnalysis.ILocalSymbol, symbol)
            if localSymbol:getIsConst() then
              if localSymbol:getType():getSpecialType() == 20 --[[SpecialType.System_String]] then
                if #(System.cast(System.String, localSymbol:getConstantValue())) <= 15 --[[LuaSyntaxNodeTransform.kStringConstInlineCount]] then
                  return GetConstLiteralExpression1(this, localSymbol)
                end
              else
                return GetConstLiteralExpression1(this, localSymbol)
              end
            end

            identifier = GetSampleName(symbol)
            identifier = CheckValueTypeClone(this, localSymbol:getType(), node, identifier)
            break
          end
        elseif default == 13 --[[SymbolKind.Parameter]] then
          do
            local parameterSymbol = System.cast(MicrosoftCodeAnalysis.IParameterSymbol, symbol)
            identifier = GetSampleName(symbol)
            identifier = CheckValueTypeClone(this, parameterSymbol:getType(), node, identifier)
            break
          end
        elseif default == 16 --[[SymbolKind.RangeVariable]] then
          do
            identifier = GetRangeIdentifierName(this, node)
            break
          end
        elseif default == 17 --[[SymbolKind.TypeParameter]] or default == 7 --[[SymbolKind.Label]] then
          do
            identifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, symbol:getName())
            break
          end
        elseif default == 11 --[[SymbolKind.NamedType]] then
          do
            identifier = GetTypeName(this, symbol)
            break
          end
        elseif default == 12 --[[SymbolKind.Namespace]] then
          do
            identifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, symbol:ToString())
            break
          end
        elseif default == 6 --[[SymbolKind.Field]] then
          do
            local fieldSymbol = System.cast(MicrosoftCodeAnalysis.IFieldSymbol, symbol)
            identifier = GetFieldNameExpression(this, fieldSymbol, node)
            identifier = CheckValueTypeClone(this, fieldSymbol:getType(), node, identifier)
            break
          end
        elseif default == 9 --[[SymbolKind.Method]] then
          do
            local methodSymbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, symbol)
            if methodSymbol:getMethodKind() == 17 --[[MethodKind.LocalFunction]] then
              identifier = GetSampleName(symbol)
            else
              identifier = GetMethodNameExpression(this, methodSymbol, node)
            end
            break
          end
        elseif default == 15 --[[SymbolKind.Property]] then
          do
            identifier = VisitFieldOrEventIdentifierName(this, node, symbol, true)
            break
          end
        elseif default == 5 --[[SymbolKind.Event]] then
          do
            identifier = VisitFieldOrEventIdentifierName(this, node, symbol, false)
            break
          end
        else
          do
            System.throw(System.NotSupportedException())
          end
        end
      until 1
      if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) then
        identifier = CheckConversion(this, node, identifier)
      end
      return identifier
    end
    VisitQualifiedName = function (this, node)
      return node:getRight():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
    end
    FillInvocationArgument = function (this, arguments, node, parameters, refOrOutArguments)
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      assert(expression ~= nil)
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getRefOrOutKeyword(), 8360 --[[SyntaxKind.RefKeyword]]) then
        refOrOutArguments:Add(expression)
      elseif MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getRefOrOutKeyword(), 8361 --[[SyntaxKind.OutKeyword]]) then
        refOrOutArguments:Add(expression)
        expression = CSharpLuaLuaAst.LuaIdentifierNameSyntax.Nil
      end
      if node:getNameColon() ~= nil then
        local name = node:getNameColon():getName():getIdentifier():getValueText()
        local index = CSharpLua.Utility.IndexOf(parameters, function (i)
          return i:getName() == name
        end, MicrosoftCodeAnalysis.IParameterSymbol)
        if index == - 1 then
          System.throw(CSharpLua.InvalidOperationException())
        end
        CSharpLua.Utility.AddAt(arguments, index, expression, CSharpLuaLuaAst.LuaExpressionSyntax)
      else
        arguments:Add(expression)
      end
    end
    BuildArgumentList = function (this, symbol, parameters, node, refOrOutArguments)
      assert(node ~= nil)
      local arguments = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)()
      for _, argument in System.each(node:getArguments()) do
        FillInvocationArgument(this, arguments, argument, parameters:__clone__(), refOrOutArguments)
      end
      CheckInvocationDeafultArguments1(this, symbol, parameters:__clone__(), arguments, node)
      return arguments
    end
    BuildArgumentList1 = function (this, arguments)
      local argumentList = CSharpLuaLuaAst.LuaArgumentListSyntax()
      for _, argument in System.each(arguments) do
        local newNode = System.cast(CSharpLuaLuaAst.LuaArgumentSyntax, argument:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        argumentList.Arguments:Add(newNode)
      end
      return argumentList
    end
    VisitArgumentList = function (this, node)
      return BuildArgumentList1(this, node:getArguments())
    end
    VisitArgument = function (this, node)
      assert(node:getNameColon() == nil)
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      return CSharpLuaLuaAst.LuaArgumentSyntax(expression)
    end
    VisitLiteralExpression = function (this, node)
      repeat
        local default = node:Kind()
        if default == 8749 --[[SyntaxKind.NumericLiteralExpression]] then
          do
            local value = node:getToken():getValueText()
            if System.is(node:getToken():getValue(), System.Double) or System.is(node:getToken():getValue(), System.Double) then
              if not Linq.Contains(value, 46 --[['.']]) then
                value = value .. ".0"
              end
            end
            return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, value)
          end
        elseif default == 8750 --[[SyntaxKind.StringLiteralExpression]] then
          do
            return BuildStringLiteralTokenExpression(this, node:getToken())
          end
        elseif default == 8751 --[[SyntaxKind.CharacterLiteralExpression]] then
          do
            return CSharpLuaLuaAst.LuaCharacterLiteralExpression(System.cast(System.Char, node:getToken():getValue()))
          end
        elseif default == 8754 --[[SyntaxKind.NullLiteralExpression]] then
          do
            return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.Nil
          end
        else
          do
            return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, node:getToken():getValueText())
          end
        end
      until 1
    end
    VisitLocalDeclarationStatement = function (this, node)
      local declaration = System.cast(CSharpLuaLuaAst.LuaVariableDeclarationSyntax, node:getDeclaration():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      return CSharpLuaLuaAst.LuaLocalDeclarationStatementSyntax(declaration)
    end
    VisitVariableDeclaration = function (this, node)
      local variableListDeclaration = CSharpLuaLuaAst.LuaVariableListDeclarationSyntax()
      for _, variable in System.each(node:getVariables()) do
        if variable:getInitializer() ~= nil and MicrosoftCodeAnalysis.CSharpExtensions.IsKind(variable:getInitializer():getValue(), 9050 --[[SyntaxKind.RefExpression]]) then
          local refExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, variable:getInitializer():getValue():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          AddLocalVariableMapping(this, CSharpLuaLuaAst.LuaExpressionNameSyntax(refExpression), variable)
        else
          local isConst = false
          local parent = node:getParent()
          if System.is(parent, MicrosoftCodeAnalysisCSharpSyntax.LocalDeclarationStatementSyntax) and parent:getIsConst() then
            isConst = true
            local value = variable:getInitializer():getValue()
            if System.is(value, MicrosoftCodeAnalysisCSharpSyntax.LiteralExpressionSyntax) then
              local token = value:getToken()
              local str = token:getValue()
              if System.is(str, System.String) then
                if #str > 15 --[[LuaSyntaxNodeTransform.kStringConstInlineCount]] then
                  isConst = false
                end
              end
            end
          end
          if not isConst then
            local variableDeclarator = System.cast(CSharpLuaLuaAst.LuaVariableDeclaratorSyntax, variable:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            variableListDeclaration.Variables:Add(variableDeclarator)
          end
        end
      end
      local isMultiNil = #variableListDeclaration.Variables > 0 and Linq.All(variableListDeclaration.Variables, function (i)
        return i.Initializer == nil
      end)
      if isMultiNil then
        local declarationStatement = CSharpLuaLuaAst.LuaLocalVariablesStatementSyntax()
        for _, variable in System.each(variableListDeclaration.Variables) do
          declarationStatement.Variables:Add(variable.Identifier)
        end
        return declarationStatement
      else
        return variableListDeclaration
      end
    end
    VisitVariableDeclarator = function (this, node)
      local identifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText())
      identifier = CheckLocalVariableName(this, identifier, node)
      local variableDeclarator = CSharpLuaLuaAst.LuaVariableDeclaratorSyntax(identifier)
      if node:getInitializer() ~= nil then
        variableDeclarator.Initializer = System.cast(CSharpLuaLuaAst.LuaEqualsValueClauseSyntax, node:getInitializer():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      end
      return variableDeclarator
    end
    VisitEqualsValueClause = function (this, node)
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getValue():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      return CSharpLuaLuaAst.LuaEqualsValueClauseSyntax(expression)
    end
    VisitPredefinedType = function (this, node)
      local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node, System.default(SystemThreading.CancellationToken)):getSymbol()
      return GetTypeShortName(this, symbol)
    end
    WriteStatementOrBlock = function (this, statement, block)
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(statement, 8792 --[[SyntaxKind.Block]]) then
        local blockNode = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, statement:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        block.Statements:AddRange(blockNode.Statements)
      else
        this.blocks_:Push(block)
        local statementNode = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, statement:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        block.Statements:Add(statementNode)
        this.blocks_:Pop()
      end
    end
    VisitIfStatement = function (this, node)
      local condition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local ifStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(condition)
      WriteStatementOrBlock(this, node:getStatement(), ifStatement.Body)
      this.ifStatements_:Push(ifStatement)
      local default = node:getElse()
      if default ~= nil then
        default:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
      end
      this.ifStatements_:Pop()
      return ifStatement
    end
    VisitElseClause = function (this, node)
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getStatement(), 8819 --[[SyntaxKind.IfStatement]]) then
        local ifStatement = System.cast(MicrosoftCodeAnalysisCSharpSyntax.IfStatementSyntax, node:getStatement())
        local condition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, ifStatement:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        local elseIfStatement = CSharpLuaLuaAst.LuaElseIfStatementSyntax(condition)
        WriteStatementOrBlock(this, ifStatement:getStatement(), elseIfStatement.Body)
        this.ifStatements_:Peek().ElseIfStatements:Add(elseIfStatement)
        local default = ifStatement:getElse()
        if default ~= nil then
          default:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
        end
        return elseIfStatement
      else
        local elseClause = CSharpLuaLuaAst.LuaElseClauseSyntax()
        WriteStatementOrBlock(this, node:getStatement(), elseClause.Body)
        this.ifStatements_:Peek().Else = elseClause
        return elseClause
      end
    end
    VisitSwitchStatement = function (this, node)
      local temp = GetTempIdentifier(this, node)
      local switchStatement = CSharpLuaLuaAst.LuaSwitchAdapterStatementSyntax(temp)
      this.switchs_:Push(switchStatement)
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      switchStatement:Fill(expression, Linq.Select(node:getSections(), function (i)
        return System.cast(CSharpLuaLuaAst.LuaStatementSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      end, CSharpLuaLuaAst.LuaStatementSyntax))
      this.switchs_:Pop()
      return switchStatement
    end
    VisitSwitchSection = function (this, node)
      local isDefault = Linq.Any(node:getLabels(), function (i)
        return i:Kind() == 8824 --[[SyntaxKind.DefaultSwitchLabel]]
      end)
      if isDefault then
        local block = CSharpLuaLuaAst.LuaBlockSyntax()
        for _, statement in System.each(node:getStatements()) do
          local luaStatement = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, statement:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          block.Statements:Add(luaStatement)
        end
        return block
      else
        local expressions = Linq.Select(node:getLabels(), function (i)
          return System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        end, CSharpLuaLuaAst.LuaExpressionSyntax)
        local condition = Linq.Aggregate(expressions, function (x, y)
          return CSharpLuaLuaAst.LuaBinaryExpressionSyntax(x, "or" --[[Keyword.Or]], y)
        end)
        local ifStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(condition)
        for _, statement in System.each(node:getStatements()) do
          local luaStatement = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, statement:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          ifStatement.Body.Statements:Add(luaStatement)
        end
        return ifStatement
      end
    end
    VisitCaseSwitchLabel = function (this, node)
      local left = this.switchs_:Peek().Temp
      local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getValue():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local BinaryExpression = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(left, "==" --[[Tokens.EqualsEquals]], right)
      return BinaryExpression
    end
    BuildSwitchLabelWhenClause = function (this, expression, whenClause)
      if whenClause ~= nil then
        local whenExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, whenClause:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        return CSharpLuaLuaAst.LuaBinaryExpressionSyntax(expression, "and" --[[Keyword.And]], whenExpression)
      else
        return expression
      end
    end
    VisitCasePatternSwitchLabel = function (this, node)
      local left = this.switchs_:Peek().Temp
      local declarationPattern = node:getPattern()
      if System.is(declarationPattern, MicrosoftCodeAnalysisCSharpSyntax.DeclarationPatternSyntax) then
        AddLocalVariableMapping(this, left, declarationPattern:getDesignation())
        local switchStatement = FindParent2(this, node, MicrosoftCodeAnalysisCSharpSyntax.SwitchStatementSyntax)
        local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, switchStatement:getExpression(), System.default(SystemThreading.CancellationToken)):getType()
        local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, declarationPattern:getType(), System.default(SystemThreading.CancellationToken)):getType()
        if CSharpLua.Utility.IsSubclassOf(leftType, rightType) then
          local default
          if node:getWhenClause() ~= nil then
            default = node:getWhenClause():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
          else
            default = CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.True
          end
          return default
        else
          local type = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, declarationPattern:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          local isInvoke = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Is, left, type)
          return BuildSwitchLabelWhenClause(this, isInvoke, node:getWhenClause())
        end
      else
        local patternExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getPattern():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        local expression = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(left, "==" --[[Tokens.EqualsEquals]], patternExpression)
        return BuildSwitchLabelWhenClause(this, expression, node:getWhenClause())
      end
    end
    VisitWhenClause = function (this, node)
      return node:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
    end
    VisitConstantPattern = function (this, node)
      return node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
    end
    VisitBreakStatement = function (this, node)
      return CSharpLuaLuaAst.LuaBreakStatementSyntax.Statement
    end
    WrapStringConcatExpression = function (this, expression)
      local typeInfo = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, expression, System.default(SystemThreading.CancellationToken)):getType()
      local original = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      if CSharpLua.Utility.IsStringType(typeInfo) then
        return original
      elseif typeInfo:getSpecialType() == 8 --[[SpecialType.System_Char]] then
        local constValue = this.semanticModel_:GetConstantValue(expression, System.default(SystemThreading.CancellationToken))
        if constValue:getHasValue() then
          local text = MicrosoftCodeAnalysisCSharp.SyntaxFactory.Literal(System.cast(System.Char, constValue:getValue())):getText()
          return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, text)
        else
          return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.StringChar, original)
        end
      elseif typeInfo:getSpecialType() >= 7 --[[SpecialType.System_Boolean]] and typeInfo:getSpecialType() <= 19 --[[SpecialType.System_Double]] then
        return original
      elseif typeInfo:getTypeKind() == 5 --[[TypeKind.Enum]] then
        if System.is(original, CSharpLuaLuaAst.LuaLiteralExpressionSyntax) then
          local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, expression, System.default(SystemThreading.CancellationToken)):getSymbol()
          return CSharpLuaLuaAst.LuaConstLiteralExpression:new(1, symbol:getName(), typeInfo:ToString())
        else
          AddExportEnum(this, typeInfo)
          local typeName = GetTypeShortName(this, typeInfo)
          local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(original, CSharpLuaLuaAst.LuaIdentifierNameSyntax.ToEnumString, true)
          return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, memberAccess, typeName)
        end
      elseif typeInfo:getIsValueType() then
        local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(original, CSharpLuaLuaAst.LuaIdentifierNameSyntax.ToStr, true)
        return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess)
      else
        return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.SystemToString, original)
      end
    end
    BuildStringConcatExpression = function (this, node)
      local expression = BuildStringConcatExpression1(this, node:getLeft(), node:getRight())
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8668 --[[SyntaxKind.AddExpression]]) then
        expression = CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(expression)
      end
      return expression
    end
    BuildStringConcatExpression1 = function (this, leftNode, rightNode)
      local left = WrapStringConcatExpression(this, leftNode)
      local right = WrapStringConcatExpression(this, rightNode)
      return CSharpLuaLuaAst.LuaBinaryExpressionSyntax(left, ".." --[[Tokens.Concatenation]], right)
    end
    BuildBinaryInvokeExpression = function (this, node, name)
      local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getLeft():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getRight():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, name, left, right)
    end
    BuildIntegerDivExpression = function (this, leftType, rightType, node)
      if getIsLuaNewest(this) then
        return BuildBinaryExpression(this, node, "//" --[[Tokens.IntegerDiv]])
      else
        local default
        if CSharpLua.Utility.IsNullableType(leftType) or CSharpLua.Utility.IsNullableType(rightType) then
          default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.IntegerDivOfNull
        else
          default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.IntegerDiv
        end
        local methodName = default
        return BuildBinaryInvokeExpression(this, node, methodName)
      end
    end
    BuildBinaryExpression = function (this, node, operatorToken)
      local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getLeft():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getRight():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      return CSharpLuaLuaAst.LuaBinaryExpressionSyntax(left, operatorToken, right)
    end
    BuildBitExpression = function (this, node, boolOperatorToken, otherName, nameOfNull)
      local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getLeft(), System.default(SystemThreading.CancellationToken)):getType()
      if leftType:getSpecialType() == 7 --[[SpecialType.System_Boolean]] then
        return BuildBinaryExpression(this, node, boolOperatorToken)
      elseif not getIsLuaNewest(this) then
        local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getRight(), System.default(SystemThreading.CancellationToken)):getType()
        local default
        if CSharpLua.Utility.IsNullableType(leftType) or CSharpLua.Utility.IsNullableType(rightType) then
          default = nameOfNull
        else
          default = otherName
        end
        local methodName = default
        return BuildBinaryInvokeExpression(this, node, methodName)
      else
        local operatorToken = GetOperatorToken(node:getOperatorToken())
        return BuildBinaryExpression(this, node, operatorToken)
      end
    end
    VisitBinaryExpression = function (this, node)
      local constExpression = GetConstExpression(this, node)
      if constExpression ~= nil then
        return constExpression
      end

      repeat
        local default = node:Kind()
        if default == 8668 --[[SyntaxKind.AddExpression]] then
          do
            local methodSymbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node, System.default(SystemThreading.CancellationToken)):getSymbol()
            if System.is(methodSymbol, MicrosoftCodeAnalysis.IMethodSymbol) then
              if CSharpLua.Utility.IsStringType(methodSymbol:getContainingType()) then
                return BuildStringConcatExpression(this, node)
              end
            end
            break
          end
        elseif default == 8671 --[[SyntaxKind.DivideExpression]] then
          do
            local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getLeft(), System.default(SystemThreading.CancellationToken)):getType()
            local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getRight(), System.default(SystemThreading.CancellationToken)):getType()
            if CSharpLua.Utility.IsIntegerType(leftType) and CSharpLua.Utility.IsIntegerType(rightType) then
              return BuildIntegerDivExpression(this, leftType, rightType, node)
            end
            break
          end
        elseif default == 8672 --[[SyntaxKind.ModuloExpression]] then
          do
            if not getIsLuaNewest(this) then
              local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getLeft(), System.default(SystemThreading.CancellationToken)):getType()
              local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getRight(), System.default(SystemThreading.CancellationToken)):getType()
              if CSharpLua.Utility.IsIntegerType(leftType) and CSharpLua.Utility.IsIntegerType(rightType) then
                local extern
                if CSharpLua.Utility.IsNullableType(leftType) or CSharpLua.Utility.IsNullableType(rightType) then
                  extern = CSharpLuaLuaAst.LuaIdentifierNameSyntax.IntegerModOfNull
                else
                  extern = CSharpLuaLuaAst.LuaIdentifierNameSyntax.IntegerMod
                end
                local methodName = extern
                return BuildBinaryInvokeExpression(this, node, methodName)
              end
            end
            break
          end
        elseif default == 8673 --[[SyntaxKind.LeftShiftExpression]] then
          do
            if not getIsLuaNewest(this) then
              local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getLeft(), System.default(SystemThreading.CancellationToken)):getType()
              local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getRight(), System.default(SystemThreading.CancellationToken)):getType()
              local ref
              if CSharpLua.Utility.IsNullableType(leftType) or CSharpLua.Utility.IsNullableType(rightType) then
                ref = CSharpLuaLuaAst.LuaIdentifierNameSyntax.ShiftLeftOfNull
              else
                ref = CSharpLuaLuaAst.LuaIdentifierNameSyntax.ShiftLeft
              end
              local methodName = ref
              return BuildBinaryInvokeExpression(this, node, methodName)
            end
            break
          end
        elseif default == 8674 --[[SyntaxKind.RightShiftExpression]] then
          do
            if not getIsLuaNewest(this) then
              local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getLeft(), System.default(SystemThreading.CancellationToken)):getType()
              local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getRight(), System.default(SystemThreading.CancellationToken)):getType()
              local out
              if CSharpLua.Utility.IsNullableType(leftType) or CSharpLua.Utility.IsNullableType(rightType) then
                out = CSharpLuaLuaAst.LuaIdentifierNameSyntax.ShiftRightOfNull
              else
                out = CSharpLuaLuaAst.LuaIdentifierNameSyntax.ShiftRight
              end
              local methodName = out
              return BuildBinaryInvokeExpression(this, node, methodName)
            end
            break
          end
        elseif default == 8677 --[[SyntaxKind.BitwiseOrExpression]] then
          do
            return BuildBitExpression(this, node, "or" --[[Keyword.Or]], CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitOr, CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitOrOfNull)
          end
        elseif default == 8678 --[[SyntaxKind.BitwiseAndExpression]] then
          do
            return BuildBitExpression(this, node, "and" --[[Keyword.And]], CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitAnd, CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitAndOfNull)
          end
        elseif default == 8679 --[[SyntaxKind.ExclusiveOrExpression]] then
          do
            return BuildBitExpression(this, node, "~=" --[[Tokens.NotEquals]], CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitXor, CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitXorOfNull)
          end
        elseif default == 8686 --[[SyntaxKind.IsExpression]] then
          do
            local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getLeft(), System.default(SystemThreading.CancellationToken)):getType()
            local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getRight(), System.default(SystemThreading.CancellationToken)):getType()
            if CSharpLua.Utility.IsSubclassOf(leftType, rightType) then
              return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.True
            end

            return BuildBinaryInvokeExpression(this, node, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Is)
          end
        elseif default == 8687 --[[SyntaxKind.AsExpression]] then
          do
            local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getLeft(), System.default(SystemThreading.CancellationToken)):getType()
            local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getRight(), System.default(SystemThreading.CancellationToken)):getType()
            if CSharpLua.Utility.IsSubclassOf(leftType, rightType) then
              return node:getLeft():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
            end

            return BuildBinaryInvokeExpression(this, node, CSharpLuaLuaAst.LuaIdentifierNameSyntax.As)
          end
        end
      until 1

      local operatorExpression = GerUserDefinedOperatorExpression(this, node)
      if operatorExpression ~= nil then
        return operatorExpression
      end

      local operatorToken = GetOperatorToken(node:getOperatorToken())
      return BuildBinaryExpression(this, node, operatorToken)
    end
    IsSingleLineUnary = function (this, node)
      return MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8797 --[[SyntaxKind.ExpressionStatement]]) or MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8811 --[[SyntaxKind.ForStatement]])
    end
    BuildPrefixUnaryExpression = function (this, isSingleLine, operatorToken, operand, node, isLocalVar)
      local binary = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(operand, operatorToken, CSharpLuaLuaAst.LuaIdentifierNameSyntax.One)
      if isSingleLine then
        return CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(operand, binary)
      else
        if isLocalVar then
          getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(operand, binary)))
          return operand
        else
          local temp = GetTempIdentifier(this, node)
          getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, temp, binary))
          getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(operand, temp)))
          return temp
        end
      end
    end
    BuildPropertyPrefixUnaryExpression = function (this, isSingleLine, operatorToken, get, set, node)
      set:setIsGetOrAdd(false)
      local binary = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(get, operatorToken, CSharpLuaLuaAst.LuaIdentifierNameSyntax.One)
      if isSingleLine then
        set.ArgumentList:AddArgument1(binary)
        return set
      else
        local temp = GetTempIdentifier(this, node)
        getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, temp, binary))
        set.ArgumentList:AddArgument1(temp)
        getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(set))
        return temp
      end
    end
    GetTempUnaryExpression = function (this, memberAccess, localTemp, node)
      local temp = GetTempIdentifier(this, node)
      localTemp = CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, temp, memberAccess.Expression)
      return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(temp, memberAccess.Name, memberAccess:getIsObjectColon()), localTemp
    end
    GetTempPropertyUnaryExpression = function (this, propertyAdapter, localTemp, node)
      local temp = GetTempIdentifier(this, node)
      localTemp = CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, temp, propertyAdapter.Expression)
      return CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax:new(2, temp, propertyAdapter.Name, propertyAdapter:getIsObjectColon()), localTemp
    end
    VisitPrefixUnaryExpression = function (this, node)
      local kind = node:Kind()
      repeat
        local default = kind
        if default == 8734 --[[SyntaxKind.PreIncrementExpression]] or default == 8735 --[[SyntaxKind.PreDecrementExpression]] then
          do
            local isSingleLine = IsSingleLineUnary(this, node)
            local operatorToken = kind == 8734 --[[SyntaxKind.PreIncrementExpression]] and "+" --[[Tokens.Plus]] or "-" --[[Tokens.Sub]]
            local operand = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getOperand():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))

            local memberAccess = operand
            local propertyAdapter = operand
            if System.is(memberAccess, CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax) then
              if memberAccess.Expression ~= CSharpLuaLuaAst.LuaIdentifierNameSyntax.This then
                local localTemp
                local extern
                extern, localTemp = GetTempUnaryExpression(this, memberAccess, nil, node)
                memberAccess = extern
                getCurBlock(this).Statements:Add(localTemp)
              end
              return BuildPrefixUnaryExpression(this, isSingleLine, operatorToken, memberAccess, node, false)
            elseif System.is(propertyAdapter, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax) then
              if propertyAdapter.Expression ~= nil then
                local localTemp
                local ref
                ref, localTemp = GetTempPropertyUnaryExpression(this, propertyAdapter, nil, node)
                local getAdapter = ref
                getCurBlock(this).Statements:Add(localTemp)
                return BuildPropertyPrefixUnaryExpression(this, isSingleLine, operatorToken, getAdapter, getAdapter:GetClone(), node)
              else
                return BuildPropertyPrefixUnaryExpression(this, isSingleLine, operatorToken, propertyAdapter, propertyAdapter:GetClone(), node)
              end
            else
              local isLocalVar = false
              if not isSingleLine then
                local symbolKind = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node:getOperand(), System.default(SystemThreading.CancellationToken)):getSymbol():getKind()
                if symbolKind == 13 --[[SymbolKind.Parameter]] or symbolKind == 8 --[[SymbolKind.Local]] then
                  isLocalVar = true
                end
              end
              return BuildPrefixUnaryExpression(this, isSingleLine, operatorToken, operand, node, isLocalVar)
            end
          end
        elseif default == 8736 --[[SyntaxKind.PointerIndirectionExpression]] then
          do
            local operand = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getOperand():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            local identifier = CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax:new(1, true, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Empty)
            return CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax:new(2, operand, identifier, true)
          end
        elseif default == 8732 --[[SyntaxKind.BitwiseNotExpression]] and not getIsLuaNewest(this) then
          do
            local type = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getOperand(), System.default(SystemThreading.CancellationToken)):getType()
            local operand = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getOperand():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            local out
            if CSharpLua.Utility.IsNullableType(type) then
              out = CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitNotOfNull
            else
              out = CSharpLuaLuaAst.LuaIdentifierNameSyntax.BitNot
            end
            return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, out, operand)
          end
        else
          do
            local operand = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getOperand():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            local operatorToken = GetOperatorToken(node:getOperatorToken())
            local unaryExpression = CSharpLuaLuaAst.LuaPrefixUnaryExpressionSyntax(operand, operatorToken)
            return unaryExpression
          end
        end
      until 1
    end
    BuildPostfixUnaryExpression = function (this, isSingleLine, operatorToken, operand, node)
      if isSingleLine then
        local binary = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(operand, operatorToken, CSharpLuaLuaAst.LuaIdentifierNameSyntax.One)
        return CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(operand, binary)
      else
        local temp = GetTempIdentifier(this, node)
        getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, temp, operand))
        local binary = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(temp, operatorToken, CSharpLuaLuaAst.LuaIdentifierNameSyntax.One)
        getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(operand, binary)))
        return temp
      end
    end
    BuildPropertyPostfixUnaryExpression = function (this, isSingleLine, operatorToken, get, set, node)
      set:setIsGetOrAdd(false)
      if isSingleLine then
        local binary = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(get, operatorToken, CSharpLuaLuaAst.LuaIdentifierNameSyntax.One)
        set.ArgumentList:AddArgument1(binary)
        return set
      else
        local temp = GetTempIdentifier(this, node)
        getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, temp, get))
        local binary = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(temp, operatorToken, CSharpLuaLuaAst.LuaIdentifierNameSyntax.One)
        set.ArgumentList:AddArgument1(binary)
        getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(set))
        return temp
      end
    end
    VisitPostfixUnaryExpression = function (this, node)
      local kind = node:Kind()
      if kind ~= 8738 --[[SyntaxKind.PostIncrementExpression]] and kind ~= 8739 --[[SyntaxKind.PostDecrementExpression]] then
        System.throw(System.NotSupportedException())
      end

      local isSingleLine = IsSingleLineUnary(this, node)
      local operatorToken = kind == 8738 --[[SyntaxKind.PostIncrementExpression]] and "+" --[[Tokens.Plus]] or "-" --[[Tokens.Sub]]
      local operand = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getOperand():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))

      local memberAccess = operand
      local propertyAdapter = operand
      if System.is(memberAccess, CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax) then
        if memberAccess.Expression ~= CSharpLuaLuaAst.LuaIdentifierNameSyntax.This then
          local localTemp
          local default
          default, localTemp = GetTempUnaryExpression(this, memberAccess, nil, node)
          memberAccess = default
          getCurBlock(this).Statements:Add(localTemp)
        end
        return BuildPostfixUnaryExpression(this, isSingleLine, operatorToken, memberAccess, node)
      elseif System.is(propertyAdapter, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax) then
        if propertyAdapter.Expression ~= nil then
          local localTemp
          local extern
          extern, localTemp = GetTempPropertyUnaryExpression(this, propertyAdapter, nil, node)
          local getAdapter = extern
          getCurBlock(this).Statements:Add(localTemp)
          return BuildPropertyPostfixUnaryExpression(this, isSingleLine, operatorToken, getAdapter, getAdapter:GetClone(), node)
        else
          return BuildPropertyPostfixUnaryExpression(this, isSingleLine, operatorToken, propertyAdapter, propertyAdapter:GetClone(), node)
        end
      else
        return BuildPostfixUnaryExpression(this, isSingleLine, operatorToken, operand, node)
      end
    end
    VisitContinueStatement = function (this, node)
      return CSharpLuaLuaAst.LuaContinueAdapterStatementSyntax.Statement
    end
    VisitLoopBody = function (this, bodyStatement, block)
      local hasContinue = IsContinueExists(this, bodyStatement)
      if hasContinue then
        -- http://lua-users.org/wiki/ContinueProposal
        local continueIdentifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax.Continue
        block.Statements:Add(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, continueIdentifier))
        local repeatStatement = CSharpLuaLuaAst.LuaRepeatStatementSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.One)
        WriteStatementOrBlock(this, bodyStatement, repeatStatement.Body)
        local assignment = CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(continueIdentifier, CSharpLuaLuaAst.LuaIdentifierNameSyntax.True)
        repeatStatement.Body.Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(assignment))
        block.Statements:Add(repeatStatement)
        local IfStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(CSharpLuaLuaAst.LuaPrefixUnaryExpressionSyntax(continueIdentifier, "not" --[[Keyword.Not]]))
        IfStatement.Body.Statements:Add(CSharpLuaLuaAst.LuaBreakStatementSyntax.Statement)
        block.Statements:Add(IfStatement)
      else
        WriteStatementOrBlock(this, bodyStatement, block)
      end
    end
    CheckForeachCast = function (this, identifier, node, forInStatement)
      local sourceType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getExpression(), System.default(SystemThreading.CancellationToken)):getType()
      local targetType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getType(), System.default(SystemThreading.CancellationToken)):getType()
      local hasCast = false
      local elementType = CSharpLua.Utility.GetIEnumerableElementType(sourceType)
      if elementType ~= nil then
        if not elementType:Equals(targetType) and not CSharpLua.Utility.IsSubclassOf(elementType, targetType) then
          hasCast = true
        end
      else
        if targetType:getSpecialType() ~= 1 --[[SpecialType.System_Object]] then
          hasCast = true
        end
      end
      if hasCast then
        local cast = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Cast, GetTypeName(this, targetType), identifier)
        local assignment = CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(identifier, cast)
        forInStatement.Body.Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(assignment))
      end
    end
    VisitForEachStatement = function (this, node)
      local identifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText())
      identifier = CheckLocalVariableName(this, identifier, node)
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local forInStatement = CSharpLuaLuaAst.LuaForInStatementSyntax(identifier, expression)
      CheckForeachCast(this, identifier, node, forInStatement)
      VisitLoopBody(this, node:getStatement(), forInStatement.Body)
      return forInStatement
    end
    VisitForEachVariableStatement = function (this, node)
      local temp = GetTempIdentifier(this, node)
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local forInStatement = CSharpLuaLuaAst.LuaForInStatementSyntax(temp, expression)
      local left = System.cast(CSharpLuaLuaAst.LuatLocalTupleVariableExpression, node:getVariable():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local elementType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getExpression(), System.default(SystemThreading.CancellationToken)):getType()
      local right = BuildDeconstructExpression(this, elementType, temp, node:getExpression())
      forInStatement.Body.Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(left, right)))
      VisitLoopBody(this, node:getStatement(), forInStatement.Body)
      return forInStatement
    end
    VisitWhileStatement = function (this, node)
      local condition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local whileStatement = CSharpLuaLuaAst.LuaWhileStatementSyntax(condition)
      VisitLoopBody(this, node:getStatement(), whileStatement.Body)
      return whileStatement
    end
    VisitForStatement = function (this, node)
      local numericalForStatement = GetNumericalForStatement(this, node)
      if numericalForStatement ~= nil then
        return numericalForStatement
      end

      local block = CSharpLuaLuaAst.LuaBlockStatementSyntax()
      this.blocks_:Push(block)

      if node:getDeclaration() ~= nil then
        block.Statements:Add(System.cast(CSharpLuaLuaAst.LuaVariableDeclarationSyntax, node:getDeclaration():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)))
      end
      local initializers = Linq.Select(node:getInitializers(), function (i)
        return CSharpLuaLuaAst.LuaExpressionStatementSyntax(System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)))
      end, CSharpLuaLuaAst.LuaExpressionStatementSyntax)
      block.Statements:AddRange(initializers)

      local default
      if node:getCondition() ~= nil then
        default = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      else
        default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.True
      end
      local condition = default
      local whileStatement = CSharpLuaLuaAst.LuaWhileStatementSyntax(condition)
      this.blocks_:Push(whileStatement.Body)
      VisitLoopBody(this, node:getStatement(), whileStatement.Body)
      local incrementors = Linq.Select(node:getIncrementors(), function (i)
        return CSharpLuaLuaAst.LuaExpressionStatementSyntax(System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)))
      end, CSharpLuaLuaAst.LuaExpressionStatementSyntax)
      whileStatement.Body.Statements:AddRange(incrementors)
      this.blocks_:Pop()
      block.Statements:Add(whileStatement)
      this.blocks_:Pop()

      return block
    end
    VisitDoStatement = function (this, node)
      local condition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local newCondition = CSharpLuaLuaAst.LuaPrefixUnaryExpressionSyntax(CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(condition), "not" --[[Keyword.Not]])
      local repeatStatement = CSharpLuaLuaAst.LuaRepeatStatementSyntax(newCondition)
      VisitLoopBody(this, node:getStatement(), repeatStatement.Body)
      return repeatStatement
    end
    VisitYieldStatement = function (this, node)
      getCurFunction(this).HasYield = true
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node, 8807 --[[SyntaxKind.YieldBreakStatement]]) then
        return CSharpLuaLuaAst.LuaReturnStatementSyntax()
      else
        local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        local invocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaIdentifierNameSyntax.YieldReturn)
        invocationExpression:AddArgument(expression)
        return CSharpLuaLuaAst.LuaExpressionStatementSyntax(invocationExpression)
      end
    end
    VisitParenthesizedExpression = function (this, node)
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      CheckPrevIsInvokeStatement(this)
      return CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(expression)
    end
    -- <summary>
    -- http://lua-users.org/wiki/TernaryOperator
    -- </summary>
    VisitConditionalExpression = function (this, node)
      local mayBeNullOrFalse = MayBeNullOrFalse(this, node:getWhenTrue())
      if mayBeNullOrFalse then
        local temp = GetTempIdentifier(this, node)
        local condition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        local ifStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(condition)
        this.blocks_:Push(ifStatement.Body)
        local whenTrue = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getWhenTrue():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        this.blocks_:Pop()
        ifStatement.Body.Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(temp, whenTrue)))

        local elseClause = CSharpLuaLuaAst.LuaElseClauseSyntax()
        this.blocks_:Push(elseClause.Body)
        local whenFalse = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getWhenFalse():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        this.blocks_:Pop()
        elseClause.Body.Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(temp, whenFalse)))

        ifStatement.Else = elseClause
        getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, temp))
        getCurBlock(this).Statements:Add(ifStatement)
        return temp
      else
        local Accept
        Accept = function (expressionNode)
          local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, expressionNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          local default
          if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expressionNode, 8676 --[[SyntaxKind.LogicalAndExpression]]) or MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expressionNode, 8675 --[[SyntaxKind.LogicalOrExpression]]) then
            default = CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(expression)
          else
            default = expression
          end
          return default
        end

        local condition = Accept(node:getCondition())
        local whenTrue = Accept(node:getWhenTrue())
        local whenFalse = Accept(node:getWhenFalse())
        return CSharpLuaLuaAst.LuaBinaryExpressionSyntax(CSharpLuaLuaAst.LuaBinaryExpressionSyntax(condition, "and" --[[Keyword.And]], whenTrue), "or" --[[Keyword.Or]], whenFalse)
      end
    end
    VisitGotoStatement = function (this, node)
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getCaseOrDefaultKeyword(), 8332 --[[SyntaxKind.CaseKeyword]]) then
        local switchStatement = this.switchs_:Peek()
        local caseIndex = GetCaseLabelIndex(this, node)
        local labelIdentifier = CSharpLua.Utility.GetOrDefault1(switchStatement.CaseLabels, caseIndex, nil, System.Int, CSharpLuaLuaAst.LuaIdentifierNameSyntax)
        if labelIdentifier == nil then
          local uniqueName = GetUniqueIdentifier(this, "caseLabel" --[[kCaseLabel]] .. caseIndex, node, 0)
          labelIdentifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, uniqueName)
          switchStatement.CaseLabels:Add(caseIndex, labelIdentifier)
        end
        return CSharpLuaLuaAst.LuaGotoCaseAdapterStatement(labelIdentifier)
      elseif MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getCaseOrDefaultKeyword(), 8333 --[[SyntaxKind.DefaultKeyword]]) then
        local switchStatement = this.switchs_:Peek()
        if switchStatement.DefaultLabel == nil then
          local identifier = GetUniqueIdentifier(this, "defaultLabel" --[[kDefaultLabel]], node, 0)
          switchStatement.DefaultLabel = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, identifier)
        end
        return CSharpLuaLuaAst.LuaGotoCaseAdapterStatement(switchStatement.DefaultLabel)
      else
        local identifier = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        return CSharpLuaLuaAst.LuaGotoStatement(identifier)
      end
    end
    VisitLabeledStatement = function (this, node)
      local identifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText())
      local statement = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, node:getStatement():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      return CSharpLuaLuaAst.LuaLabeledStatement(identifier, statement)
    end
    VisitEmptyStatement = function (this, node)
      return CSharpLuaLuaAst.LuaStatementSyntax.Empty
    end
    VisitCastExpression = function (this, node)
      local constExpression = GetConstExpression(this, node)
      if constExpression ~= nil then
        return constExpression
      end

      local originalType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getExpression(), System.default(SystemThreading.CancellationToken)):getType()
      local targetType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getType(), System.default(SystemThreading.CancellationToken)):getType()
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))

      if CSharpLua.Utility.IsAssignableFrom(targetType, originalType) then
        return expression
      end

      if targetType:getTypeKind() == 5 --[[TypeKind.Enum]] then
        if originalType:getTypeKind() == 5 --[[TypeKind.Enum]] or CSharpLua.Utility.IsIntegerType(originalType) then
          return expression
        end
      end

      if CSharpLua.Utility.IsIntegerType(targetType) then
        if originalType:getTypeKind() == 5 --[[TypeKind.Enum]] then
          return expression
        end

        if CSharpLua.Utility.IsIntegerType(originalType) then
          return GetCastToNumberExpression(this, expression, targetType, false)
        end

        if originalType:getSpecialType() == 19 --[[SpecialType.System_Double]] or originalType:getSpecialType() == 18 --[[SpecialType.System_Single]] then
          return GetCastToNumberExpression(this, expression, targetType, true)
        end
      elseif targetType:getSpecialType() == 18 --[[SpecialType.System_Single]] and originalType:getSpecialType() == 19 --[[SpecialType.System_Double]] then
        return GetCastToNumberExpression(this, expression, targetType, true)
      end

      if CSharpLua.Utility.IsAssignableFrom(originalType, targetType) then
        return BuildCastExpression(this, node:getType(), expression)
      end

      local explicitSymbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node, System.default(SystemThreading.CancellationToken)):getSymbol())
      if explicitSymbol ~= nil then
        return BuildConversionExpression(this, explicitSymbol, expression)
      end

      return BuildCastExpression(this, node:getType(), expression)
    end
    BuildCastExpression = function (this, type, expression)
      local typeExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, type:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Cast, typeExpression, expression)
    end
    GetCastToNumberExpression = function (this, expression, targetType, isFromFloat)
      local name = (isFromFloat and "To" or "to") .. targetType:getName()
      local methodName = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.System1, CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name), false)
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, methodName, expression)
    end
    VisitCheckedStatement = function (this, node)
      local isChecked = MicrosoftCodeAnalysisCSharp.CSharpExtensions.Kind(node:getKeyword()) == 8379 --[[SyntaxKind.CheckedKeyword]]
      PushChecked(this, isChecked)
      local statements = CSharpLuaLuaAst.LuaStatementListSyntax()
      statements.Statements:Add(CSharpLuaLuaAst.LuaShortCommentStatement(" " .. node:getKeyword():getValueText()))
      local block = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, node:getBlock():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      statements.Statements:Add(block)
      PopChecked(this)
      return statements
    end
    VisitCheckedExpression = function (this, node)
      local isChecked = MicrosoftCodeAnalysisCSharp.CSharpExtensions.Kind(node:getKeyword()) == 8379 --[[SyntaxKind.CheckedKeyword]]
      PushChecked(this, isChecked)
      local expression = node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
      PopChecked(this)
      return expression
    end
    IsLocalVarExists = function (this, name, root)
      local searcher = class.LocalVarSearcher(name)
      return searcher:Find(root)
    end
    FindFromCur = function (this, node, macth)
      local cur = node
      while cur ~= nil do
        if macth(cur) then
          return cur
        end
        cur = cur:getParent()
      end
      return nil
    end
    FindParent = function (this, node, macth)
      local parent = node:getParent()
      while true do
        if macth(parent) then
          return parent
        end
        parent = parent:getParent()
      end
    end
    FindParent1 = function (this, node, kind)
      return FindParent(this, node, function (i)
        return MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i, kind)
      end)
    end
    FindParent2 = function (this, node, T)
      return System.cast(T, FindParent(this, node, function (i)
        return System.is(i, T)
      end))
    end
    GetUniqueIdentifier = function (this, name, node, index)
      local root = FindParent2(this, node, MicrosoftCodeAnalysisCSharpSyntax.BaseMethodDeclarationSyntax)
      while true do
        local newName = CSharpLua.Utility.GetNewIdentifierName(name, index)
        local exists = IsLocalVarExists(this, newName, root)
        if not exists then
          return newName
        end
        index = index + 1
      end
    end
    CheckLocalBadWord = function (this, name, node)
      local default
      default, name = CSharpLua.Utility.IsIdentifierIllegal(name)
      if CSharpLuaLuaAst.LuaSyntaxNode.IsReservedWord(name) then
        name = GetUniqueIdentifier(this, name, node, 1)
        return true, name
      elseif default then
        name = GetUniqueIdentifier(this, name, node, 0)
        return true, name
      end
      return false, name
    end
    AddLocalVariableMapping = function (this, name, node)
      local symbol = MicrosoftCodeAnalysis.ModelExtensions.GetDeclaredSymbol(this.semanticModel_, node, System.default(SystemThreading.CancellationToken))
      assert(symbol ~= nil)
      this.localReservedNames_:Add(symbol, name)
    end
    CheckLocalVariableName = function (this, identifierName, node)
      local name = identifierName.ValueText
      local default
      default, name = CheckLocalBadWord(this, name, node)
      local isReserved = default
      if isReserved then
        identifierName = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name)
        AddLocalVariableMapping(this, identifierName, node)
      end
      return identifierName
    end
    CheckLocalSymbolName = function (this, symbol, name)
      local newName = CSharpLua.Utility.GetOrDefault1(this.localReservedNames_, symbol, nil, MicrosoftCodeAnalysis.ISymbol, CSharpLuaLuaAst.LuaIdentifierNameSyntax)
      if newName ~= nil then
        name = newName
      end
      return name
    end
    GetConstructorIndex = function (this, constructorSymbol)
      if CSharpLua.Utility.IsFromCode(constructorSymbol:getContainingType()) then
        local typeSymbol = System.cast(MicrosoftCodeAnalysis.INamedTypeSymbol, constructorSymbol:getReceiverType())
        local ctors = Linq.ToList(SystemLinq.ImmutableArrayExtensions.Where(typeSymbol:getConstructors(), function (i)
          return not i:getIsStatic()
        end, MicrosoftCodeAnalysis.IMethodSymbol))
        if #ctors > 1 then
          local firstCtorIndex = CSharpLua.Utility.IndexOf(ctors, function (i)
            return i:getParameters():getIsEmpty()
          end, MicrosoftCodeAnalysis.IMethodSymbol)
          if firstCtorIndex ~= - 1 and firstCtorIndex ~= 0 then
            local firstCtor = ctors:get(firstCtorIndex)
            ctors:Remove(firstCtor)
            ctors:Insert(0, firstCtor)
          end
          local index = ctors:IndexOf(constructorSymbol)
          assert(index ~= - 1)
          local ctroCounter = index + 1
          return ctroCounter
        end
      end
      return 0
    end
    IsContinueExists = function (this, node)
      local searcher = class.ContinueSearcher()
      return searcher:Find(node)
    end
    IsReturnExists = function (this, node)
      local searcher = class.ReturnStatementSearcher()
      return searcher:Find(node)
    end
    GetCaseLabelIndex = function (this, node)
      local switchStatement = System.cast(MicrosoftCodeAnalysisCSharpSyntax.SwitchStatementSyntax, FindParent1(this, node, 8821 --[[SyntaxKind.SwitchStatement]]))
      local index = 0
      for _, section in System.each(switchStatement:getSections()) do
        local isFound = Linq.Any(section:getLabels(), function (i)
          if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i, 8823 --[[SyntaxKind.CaseSwitchLabel]]) then
            local label = System.cast(MicrosoftCodeAnalysisCSharpSyntax.CaseSwitchLabelSyntax, i)
            if label:getValue():ToString() == node:getExpression():ToString() then
              return true
            end
          end
          return false
        end)
        if isFound then
          return index
        end
      end
      System.throw(CSharpLua.InvalidOperationException())
    end
    BuildCodeTemplateExpression = function (this, codeTemplate, targetExpression)
      return InternalBuildCodeTemplateExpression(this, codeTemplate, targetExpression)
    end
    BuildCodeTemplateExpression1 = function (this, codeTemplate, targetExpression, arguments, typeArguments)
      return InternalBuildCodeTemplateExpression(this, codeTemplate, targetExpression, Linq.Select(arguments, function (i)
        return function ()
          return i
        end
      end, System.Delegate), typeArguments)
    end
    BuildCodeTemplateExpression2 = function (this, codeTemplate, targetExpression, arguments, typeArguments)
      return InternalBuildCodeTemplateExpression(this, codeTemplate, targetExpression, Linq.Select(arguments, function (i)
        return function ()
          return System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        end
      end, System.Delegate), typeArguments)
    end
    AddCodeTemplateExpression = function (this, expression, comma, codeTemplateExpression)
      if not System.String.IsNullOrEmpty(comma) then
        codeTemplateExpression.Expressions:Add(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, comma))
      end
      codeTemplateExpression.Expressions:Add(expression)
    end
    InternalBuildCodeTemplateExpression = function (this, codeTemplate, targetExpression, arguments, typeArguments)
      local codeTemplateExpression = CSharpLuaLuaAst.LuaCodeTemplateExpressionSyntax()

      local matchs = codeTemplateRegex_:Matches(codeTemplate)
      local prevIndex = 0
      for _, match in System.each(matchs) do
        if match:getIndex() > prevIndex then
          local prevToken = codeTemplate:Substring(prevIndex, match:getIndex() - prevIndex)
          codeTemplateExpression.Expressions:Add(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, prevToken))
        end
        local comma = match:getGroups():get(1):getValue()
        local key = match:getGroups():get(2):getValue()
        if key == "this" then
          AddCodeTemplateExpression(this, BuildMemberAccessTargetExpression(this, targetExpression), comma, codeTemplateExpression)
        elseif key == "class" then
          local type = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, targetExpression, System.default(SystemThreading.CancellationToken)):getType()
          local typeName
          if type:getTypeKind() == 5 --[[TypeKind.Enum]] then
            typeName = GetTypeShortName(this, type)
            AddExportEnum(this, type)
          else
            typeName = GetTypeName(this, type)
          end
          AddCodeTemplateExpression(this, typeName, comma, codeTemplateExpression)
        elseif key:get(0) == 94 --[['^']] then
          local typeIndex
          local default
          default, typeIndex = System.Int.TryParse(key:Substring(1), nil)
          if default then
            local typeArgument = CSharpLua.Utility.GetOrDefault(typeArguments, typeIndex, nil, MicrosoftCodeAnalysis.ITypeSymbol)
            if typeArgument ~= nil then
              local typeName
              if typeArgument:getTypeKind() == 5 --[[TypeKind.Enum]] and codeTemplate:StartsWith("System.Enum.TryParse") then
                typeName = GetTypeShortName(this, typeArgument)
                AddExportEnum(this, typeArgument)
              else
                typeName = GetTypeName(this, typeArgument)
              end
              AddCodeTemplateExpression(this, typeName, comma, codeTemplateExpression)
            end
          end
        elseif key:get(0) == 42 --[['*']] then
          local paramsIndex
          local extern
          extern, paramsIndex = System.Int.TryParse(key:Substring(1), nil)
          if extern then
            local paramsExpression = CSharpLuaLuaAst.LuaCodeTemplateExpressionSyntax()
            for _, argument in System.each(Linq.Skip(arguments, paramsIndex)) do
              local argumentExpression = argument()
              paramsExpression.Expressions:Add(argumentExpression)
            end
            if #paramsExpression.Expressions > 0 then
              AddCodeTemplateExpression(this, paramsExpression, comma, codeTemplateExpression)
            end
          end
        else
          local argumentIndex
          local ref
          ref, argumentIndex = System.Int.TryParse(key, nil)
          if ref then
            local argument = Linq.ElementAtOrDefault(arguments, argumentIndex)
            if argument ~= nil then
              local argumentExpression = argument()
              AddCodeTemplateExpression(this, argumentExpression, comma, codeTemplateExpression)
            end
          end
        end
        prevIndex = match:getIndex() + match:getLength()
      end

      if prevIndex < #codeTemplate then
        local last = codeTemplate:Substring(prevIndex)
        codeTemplateExpression.Expressions:Add(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, last))
      end

      return codeTemplateExpression
    end
    AddExportEnum = function (this, enumType)
      assert(enumType:getTypeKind() == 5 --[[TypeKind.Enum]])
      this.generator_:AddExportEnum(enumType:ToString())
    end
    IsPropertyField = function (this, symbol)
      return this.generator_:IsPropertyField(symbol)
    end
    IsEventFiled = function (this, symbol)
      return this.generator_:IsEventFiled(symbol)
    end
    IsInternalMember = function (this, node, symbol)
      local isVirtual = CSharpLua.Utility.IsOverridable(symbol) and not this.generator_:IsSealed(symbol:getContainingType())
      if not isVirtual then
        local typeSymbol = getCurTypeSymbol(this)
        if typeSymbol:Equals(symbol:getContainingType()) then
          return true
        end
      end
      return false
    end
    BuildEmptyArray = function (this, baseType)
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.ArrayEmpty, baseType)
    end
    BuildArray = function (this, elementType, elements)
      local expressions = elements
      return BuildArray1(this, elementType, expressions)
    end
    BuildArray1 = function (this, elementType, elements)
      local baseType = GetTypeName(this, elementType)
      local arrayType = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Array, baseType)
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(5, arrayType, elements)
    end
    GetLiteralExpression = function (this, constantValue)
      if constantValue ~= nil then
        local code = System.Type.GetTypeCode(constantValue:GetType())
        repeat
          local default = code
          if default == 4 --[[TypeCode.Char]] then
            do
              return CSharpLuaLuaAst.LuaCharacterLiteralExpression(System.cast(System.Char, constantValue))
            end
          elseif default == 18 --[[TypeCode.String]] then
            do
              return BuildStringLiteralExpression(this, System.cast(System.String, constantValue))
            end
          elseif default == 3 --[[TypeCode.Boolean]] then
            do
              local v = System.cast(System.Boolean, constantValue)
              local extern
              if v then
                extern = CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.True
              else
                extern = CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.False
              end
              return extern
            end
          else
            do
              return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, constantValue:ToString())
            end
          end
        until 1
      else
        return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.Nil
      end
    end
    GetConstLiteralExpression = function (this, constField)
      assert(constField:getHasConstantValue())
      if constField:getType():getSpecialType() == 8 --[[SpecialType.System_Char]] then
        return CSharpLuaLuaAst.LuaCharacterLiteralExpression(System.cast(System.Char, constField:getConstantValue()))
      else
        local literalExpression = GetLiteralExpression(this, constField:getConstantValue())
        local identifierToken = (constField:getContainingType():getName() .. '.') .. constField:getName()
        return CSharpLuaLuaAst.LuaConstLiteralExpression:new(2, literalExpression, identifierToken)
      end
    end
    GetConstLiteralExpression1 = function (this, constLocal)
      assert(constLocal:getHasConstantValue())
      if constLocal:getType():getSpecialType() == 8 --[[SpecialType.System_Char]] then
        return CSharpLuaLuaAst.LuaCharacterLiteralExpression(System.cast(System.Char, constLocal:getConstantValue()))
      else
        local literalExpression = GetLiteralExpression(this, constLocal:getConstantValue())
        local identifierToken = constLocal:getName()
        return CSharpLuaLuaAst.LuaConstLiteralExpression:new(2, literalExpression, identifierToken)
      end
    end
    GetConstExpression = function (this, node)
      local constValue = this.semanticModel_:GetConstantValue(node, System.default(SystemThreading.CancellationToken))
      if constValue:getHasValue() then
        local literalExpression = GetLiteralExpression(this, constValue:getValue())
        return CSharpLuaLuaAst.LuaConstLiteralExpression:new(2, literalExpression, node:ToString())
      end
      return nil
    end
    BuildStringLiteralTokenExpression = function (this, token)
      if token:getText():get(0) == 64 --[['@']] then
        return BuildVerbatimStringExpression(this, token:getValueText())
      else
        return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, token:getText())
      end
    end
    BuildStringLiteralExpression = function (this, value)
      local text = MicrosoftCodeAnalysisCSharp.SyntaxFactory.Literal(value):getText()
      return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, text)
    end
    BuildVerbatimStringExpression = function (this, value)
      return CSharpLuaLuaAst.LuaVerbatimStringLiteralExpressionSyntax(value, true)
    end
    GetCallerAttributeKind = function (this, typeSymbol)
      repeat
        local default = typeSymbol:ToString()
        if default == "System.Runtime.CompilerServices.CallerLineNumberAttribute" then
          return 1 --[[CallerAttributeKind.Line]]
        elseif default == "System.Runtime.CompilerServices.CallerMemberNameAttribute" then
          return 2 --[[CallerAttributeKind.Member]]
        elseif default == "System.Runtime.CompilerServices.CallerFilePathAttribute" then
          return 3 --[[CallerAttributeKind.FilePath]]
        else
          return 0 --[[CallerAttributeKind.None]]
        end
      until 1
    end
    GetCallerAttributeKind1 = function (this, parameter)
      for _, attribute in System.each(parameter:GetAttributes()) do
        local callerKind = GetCallerAttributeKind(this, attribute:getAttributeClass())
        if callerKind ~= 0 --[[CallerAttributeKind.None]] then
          return callerKind
        end
      end
      return 0 --[[CallerAttributeKind.None]]
    end
    CheckCallerAttribute = function (this, parameter, node)
      local kind = GetCallerAttributeKind1(this, parameter)
      repeat
        local default = kind
        if default == 1 --[[CallerAttributeKind.Line]] then
          do
            local lineSpan = node:getSyntaxTree():GetLineSpan(node:getSpan(), System.default(SystemThreading.CancellationToken))
            return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(2, lineSpan:getStartLinePosition():getLine() + 1)
          end
        elseif default == 2 --[[CallerAttributeKind.Member]] then
          do
            local parentMethod = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MethodDeclarationSyntax, FindParent1(this, node, 8875 --[[SyntaxKind.MethodDeclaration]]))
            return CSharpLuaLuaAst.LuaStringLiteralExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, parentMethod:getIdentifier():getValueText()))
          end
        elseif default == 3 --[[CallerAttributeKind.FilePath]] then
          do
            return BuildStringLiteralExpression(this, this.generator_:RemoveBaseFolder(node:getSyntaxTree():getFilePath()))
          end
        else
          return nil
        end
      until 1
    end
    CheckUsingStaticNameSyntax = function (this, symbol, node, expression, outExpression)
      if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) then
        if symbol:getContainingType() ~= getCurTypeSymbol(this) then
          --using static
          local usingStaticType = GetTypeName(this, symbol:getContainingType())
          outExpression = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(usingStaticType, expression, false)
          return true, outExpression
        end
      end

      outExpression = nil
      return false, outExpression
    end
    MayBeFalse = function (this, expression, type)
      local mayBeFalse = false
      if type:getIsValueType() then
        if type:getSpecialType() == 7 --[[SpecialType.System_Boolean]] then
          local constValue = this.semanticModel_:GetConstantValue(expression, System.default(SystemThreading.CancellationToken))
          if constValue:getHasValue() and System.cast(System.Boolean, constValue:getValue()) then
            mayBeFalse = false
          else
            mayBeFalse = true
          end
        end
      end
      return mayBeFalse
    end
    MayBeNull = function (this, expression, type)
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expression, 8644 --[[SyntaxKind.ObjectInitializerExpression]]) then
        return false
      end

      assert(type ~= nil)
      local mayBeNull
      if type:getIsValueType() then
        mayBeNull = false
      elseif CSharpLua.Utility.IsStringType(type) then
        local constValue = this.semanticModel_:GetConstantValue(expression, System.default(SystemThreading.CancellationToken))
        if constValue:getHasValue() then
          mayBeNull = false
        else
          if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expression, 8634 --[[SyntaxKind.InvocationExpression]]) then
            local invocation = System.cast(MicrosoftCodeAnalysisCSharpSyntax.InvocationExpressionSyntax, expression)
            if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(invocation:getExpression(), 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) then
              local memberAccess = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MemberAccessExpressionSyntax, invocation:getExpression())
              if memberAccess:getName():getIdentifier():getValueText() == CSharpLuaLuaAst.LuaIdentifierNameSyntax.ToStr.ValueText then
                local typeInfo = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, memberAccess:getExpression(), System.default(SystemThreading.CancellationToken)):getType()
                if typeInfo:getSpecialType() > 1 --[[SpecialType.System_Object]] then
                  return false
                end
              end
            end
          elseif MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expression, 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) then
            local memberAccess = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MemberAccessExpressionSyntax, expression)
            local typeInfo = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, memberAccess:getExpression(), System.default(SystemThreading.CancellationToken)):getType()
            if typeInfo:getSpecialType() > 1 --[[SpecialType.System_Object]] then
              return false
            end
          end
          mayBeNull = true
        end
      else
        mayBeNull = true
      end
      return mayBeNull
    end
    MayBeNullOrFalse = function (this, conditionalWhenTrue)
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(conditionalWhenTrue, 8754 --[[SyntaxKind.NullLiteralExpression]]) then
        return true
      end
      local type = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, conditionalWhenTrue, System.default(SystemThreading.CancellationToken)):getType()
      return MayBeNull(this, conditionalWhenTrue, type) or MayBeFalse(this, conditionalWhenTrue, type)
    end
    ImportTypeName = function (this, name, symbol)
      if not getIsGetInheritTypeName(this) then
        local pos = name:LastIndexOf(46 --[['.']])
        if pos ~= - 1 then
          local prefix = name:Substring(0, pos)
          if prefix ~= CSharpLuaLuaAst.LuaIdentifierNameSyntax.System1.ValueText and prefix ~= CSharpLuaLuaAst.LuaIdentifierNameSyntax.Class.ValueText then
            local newPrefix = prefix:Replace(".", "")
            local methodInfo = getCurMethodInfoOrNull(this)
            if methodInfo ~= nil then
              local syntaxReference = CSharpLua.Utility.First(methodInfo.Symbol:getDeclaringSyntaxReferences(), MicrosoftCodeAnalysis.SyntaxReference)
              local root = syntaxReference:GetSyntax(System.default(SystemThreading.CancellationToken))
              if IsLocalVarExists(this, newPrefix, root) then
                return name
              end
            end
            name = newPrefix .. name:Substring(pos)
            getCurCompilationUnit(this):AddImport1(prefix, newPrefix, CSharpLua.Utility.IsFromCode(symbol))
          end
        end
      end
      return name
    end
    GetTypeShortName = function (this, symbol)
      return this.generator_:GetTypeShortName(symbol, this)
    end
    GetTypeName = function (this, symbol)
      return this.generator_:GetTypeName(symbol, this)
    end
    BuildFieldOrPropertyMemberAccessExpression = function (this, expression, name, isStatic)
      local propertyMethod = name
      if System.is(propertyMethod, CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax) then
        local arguments = propertyMethod.ArgumentList.Arguments
        if #arguments == 1 then
          if arguments:get(0).Expression == CSharpLuaLuaAst.LuaIdentifierNameSyntax.This then
            propertyMethod.ArgumentList.Arguments:set(0, CSharpLuaLuaAst.LuaArgumentSyntax(expression))
          end
        else
          propertyMethod:Update(expression, not isStatic)
        end
        return propertyMethod
      else
        return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, name, false)
      end
    end
    VisitAttributeList = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    VisitAttributeArgument = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    VisitNameColon = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    VisitAttributeArgumentList = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    VisitNameEquals = function (this, node)
      return node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
    end
    BuildObjectCreationInvocation = function (this, symbol, expression)
      local constructorIndex = GetConstructorIndex(this, symbol)
      if constructorIndex > 0 then
        expression = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, CSharpLuaLuaAst.LuaIdentifierNameSyntax.New, true)
      end
      local invocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, expression)
      if constructorIndex > 0 then
        invocationExpression:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(2, constructorIndex))
      end
      return invocationExpression
    end
    VisitAttribute = function (this, node)
      local symbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node:getName(), System.default(SystemThreading.CancellationToken)):getSymbol())
      local typeSymbol = symbol:getContainingType()
      if not this.generator_:IsExportAttribute(typeSymbol) then
        return nil
      end

      local typeDeclarationSymbol = getCurTypeSymbol(this)
      this.generator_:AddTypeDeclarationAttribute(typeDeclarationSymbol, typeSymbol)

      this.inheritNameNodeCounter_ = this.inheritNameNodeCounter_ + 1
      local expression = GetTypeName(this, typeSymbol)
      this.inheritNameNodeCounter_ = this.inheritNameNodeCounter_ - 1
      local invocation = BuildObjectCreationInvocation(this, symbol, expression)

      if node:getArgumentList() ~= nil then
        local arguments = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)()
        local initializers = System.List(System.Tuple)()
        local argumentNodeInfos = System.List(System.Tuple)()

        for _, argumentNode in System.each(node:getArgumentList():getArguments()) do
          local argumentExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, argumentNode:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          if argumentNode:getNameEquals() == nil then
            if argumentNode:getNameColon() ~= nil then
              local name = argumentNode:getNameColon():getName():getIdentifier():getValueText()
              local index = CSharpLua.Utility.IndexOf(symbol:getParameters(), function (i)
                return i:getName() == name
              end, MicrosoftCodeAnalysis.IParameterSymbol)
              assert(index ~= - 1)
              CSharpLua.Utility.AddAt(arguments, index, argumentExpression, CSharpLuaLuaAst.LuaExpressionSyntax)
            else
              arguments:Add(argumentExpression)
            end
          else
            local name = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, argumentNode:getNameEquals():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            initializers:Add(System.tuple(name, argumentExpression))
          end
        end

        CheckInvocationDeafultArguments(this, symbol, symbol:getParameters(), arguments, argumentNodeInfos, node, false)
        invocation:AddArguments(arguments)

        if #initializers == 0 then
          return invocation
        else
          local function_ = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
          PushFunction(this, function_)
          local temp = GetTempIdentifier(this, node)
          function_:AddParameter1(temp)

          for _, initializer in System.each(initializers) do
            local memberAccess = BuildFieldOrPropertyMemberAccessExpression(this, temp, initializer[1], false)
            local assignmentExpression = BuildLuaSimpleAssignmentExpression(this, memberAccess, initializer[2])
            function_:AddStatement1(assignmentExpression)
          end

          PopFunction(this)
          return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Create, invocation, function_)
        end
      else
        return invocation
      end
    end
    BuildAttributes = function (this, attributeLists)
      local expressions = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)()
      local attributes = Linq.SelectMany(attributeLists, function (i)
        return i:getAttributes()
      end, MicrosoftCodeAnalysisCSharpSyntax.AttributeSyntax)
      for _, node in System.each(attributes) do
        local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        if expression ~= nil then
          expressions:Add(expression)
        end
      end
      return expressions
    end
    TryAddStructDefaultMethod = function (this, symbol, declaration)
      assert(symbol:getIsValueType())
      if declaration:getIsInitStatementExists() then
        local className = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, symbol:getName())
        local thisIdentifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax.This
        local functionExpression = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
        functionExpression:AddParameter1(className)
        local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.setmetatable, CSharpLuaLuaAst.LuaTableInitializerExpression.Empty, className)
        local local_ = CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, thisIdentifier, invocation)
        functionExpression:AddStatement(local_)
        local default
        if declaration:getIsNoneCtros() then
          default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.Ctor
        else
          default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.Init
        end
        functionExpression:AddStatement(CSharpLuaLuaAst.LuaExpressionStatementSyntax(CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, default, thisIdentifier)))
        functionExpression:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(thisIdentifier))
        declaration:AddMethod(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Default, functionExpression, false)
      end
    end
    CheckValueTypeClone = function (this, typeSymbol, node, expression)
      if typeSymbol:getIsValueType() and typeSymbol:getTypeKind() ~= 5 --[[TypeKind.Enum]] and (typeSymbol:getSpecialType() == 0 --[[SpecialType.None]] and not CSharpLua.Utility.IsTimeSpanType(typeSymbol)) then
        local need = false
        repeat
          local default = MicrosoftCodeAnalysisCSharp.CSharpExtensions.Kind(node:getParent())
          if default == 8638 --[[SyntaxKind.Argument]] then
            do
              local symbol = MicrosoftCodeAnalysis.ModelExtensions.GetSymbolInfo(this.semanticModel_, node:getParent():getParent():getParent(), System.default(SystemThreading.CancellationToken)):getSymbol()
              if symbol ~= nil and CSharpLua.Utility.IsFromAssembly(symbol) and not CSharpLua.Utility.IsCollectionType(symbol:getContainingType()) then
                break
              end
              need = true
              break
            end
          elseif default == 8805 --[[SyntaxKind.ReturnStatement]] then
            do
              need = true
              break
            end
          elseif default == 8714 --[[SyntaxKind.SimpleAssignmentExpression]] then
            do
              local assignment = System.cast(MicrosoftCodeAnalysisCSharpSyntax.AssignmentExpressionSyntax, node:getParent())
              if assignment:getRight() == node then
                local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, assignment:getLeft(), System.default(SystemThreading.CancellationToken)):getSymbol()
                if symbol ~= nil and CSharpLua.Utility.IsFromAssembly(symbol) then
                  break
                end
                need = true
              end
              break
            end
          elseif default == 8796 --[[SyntaxKind.EqualsValueClause]] then
            do
              local equalsValueClause = System.cast(MicrosoftCodeAnalysisCSharpSyntax.EqualsValueClauseSyntax, node:getParent())
              if equalsValueClause:getValue() == node then
                need = true
              end
              break
            end
          end
        until 1

        if need then
          local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Clone, true))
          expression = invocation
        end
      end
      return expression
    end
    BuildDocumentationComment = function (this, node)
      for _, trivia in System.each(node:GetLeadingTrivia()) do
        if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(trivia, 8544 --[[SyntaxKind.SingleLineDocumentationCommentTrivia]]) then
          local triviaText = trivia:ToString()
          if not System.String.IsNullOrWhiteSpace(triviaText) then
            return CSharpLuaLuaAst.LuaDocumentStatement:new(2, triviaText)
          end
        end
      end
      return nil
    end
    BuildInheritTypeName = function (this, baseType)
      this.inheritNameNodeCounter_ = this.inheritNameNodeCounter_ + 1
      local baseTypeName = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, baseType:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      this.inheritNameNodeCounter_ = this.inheritNameNodeCounter_ - 1
      return baseTypeName
    end
    VisitTypeParameterList = function (this, node)
      local parameterList = CSharpLuaLuaAst.LuaParameterListSyntax()
      for _, typeParameter in System.each(node:getParameters()) do
        local typeIdentifier = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, typeParameter:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        parameterList.Parameters:Add(CSharpLuaLuaAst.LuaParameterSyntax(typeIdentifier))
      end
      return parameterList
    end
    FillExternalTypeParameters = function (this, typeParameters, typeSymbol)
      local externalType = typeSymbol:getContainingType()
      if externalType ~= nil then
        FillExternalTypeParameters(this, typeParameters, externalType)
        for _, typeParameterSymbol in System.each(externalType:getTypeParameters()) do
          local identifierName = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, typeParameterSymbol:getName())
          typeParameters:Add(CSharpLuaLuaAst.LuaParameterSyntax(identifierName))
        end
      end
    end
    BuildTypeParameters = function (this, typeSymbol, node, typeDeclaration)
      local typeParameters = System.List(CSharpLuaLuaAst.LuaParameterSyntax)()
      FillExternalTypeParameters(this, typeParameters, typeSymbol)
      if node:getTypeParameterList() ~= nil then
        local parameterList = System.cast(CSharpLuaLuaAst.LuaParameterListSyntax, node:getTypeParameterList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        typeParameters:AddRange(parameterList.Parameters)
      end
      typeDeclaration:AddTypeParameters(typeParameters)
    end
    CheckFieldNameOfProtobufnet = function (this, fieldName, containingType)
      if not containingType:getInterfaces():getIsEmpty() then
        if CSharpLua.Utility.First(containingType:getInterfaces(), MicrosoftCodeAnalysis.INamedTypeSymbol):ToString() == "ProtoBuf.IExtensible" then
          fieldName = fieldName:TrimStart(95 --[['_']])
          return true, fieldName
        end
      end
      return false, fieldName
    end
    GetMemberName = function (this, symbol)
      return this.generator_:GetMemberName(symbol)
    end
    AddInnerName = function (this, symbol)
      return this.generator_:AddInnerName(symbol)
    end
    RemoveNilArgumentsAtTail = function (this, arguments)
      local i
      do
        i = #arguments - 1
        i
        while i >= 0 do
          if not CSharpLua.Utility.IsNil(arguments:get(i)) then
            break
          end
          i = i - 1
        end
      end
      local nilStartIndex = i + 1
      local nilArgumentCount = #arguments - nilStartIndex
      if nilArgumentCount > 0 then
        arguments:RemoveRange(nilStartIndex, nilArgumentCount)
      end
    end
    TryRemoveNilArgumentsAtTail = function (this, symbol, arguments)
      if #arguments > 0 then
        if CSharpLua.Utility.IsFromCode(symbol) or symbol:getContainingType():GetMembers(symbol:getName()):getLength() == 1 then
          RemoveNilArgumentsAtTail(this, arguments)
        end
      end
    end
    PushChecked = function (this, isChecked)
      this.checkeds_:Push(isChecked)
    end
    PopChecked = function (this)
      this.checkeds_:Pop()
    end
    getIsCurChecked = function (this)
      if #this.checkeds_ > 0 then
        return this.checkeds_:Peek()
      end
      return this.generator_:getIsCheckedOverflow()
    end
    CheckConversion = function (this, node, expression)
      local conversion = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetConversion(this.semanticModel_, node, System.default(SystemThreading.CancellationToken))
      if conversion:getIsUserDefined() and conversion:getIsImplicit() then
        expression = BuildConversionExpression(this, conversion:getMethodSymbol(), expression)
      end
      return expression
    end
    GetOperatorMemberAccessExpression = function (this, methodSymbol)
      local typeName = GetTypeName(this, methodSymbol:getContainingType())
      local methodName = GetMemberName(this, methodSymbol)
      return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(typeName, methodName, false)
    end
    BuildConversionExpression = function (this, methodSymbol, expression)
      local codeTemplate = getXmlMetaProvider(this):GetMethodCodeTemplate(methodSymbol)
      if codeTemplate ~= nil then
        return BuildCodeTemplateExpression1(this, codeTemplate, nil, System.Array(CSharpLuaLuaAst.LuaExpressionSyntax)(expression))
      end

      local memberAccess = GetOperatorMemberAccessExpression(this, methodSymbol)
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, memberAccess, expression)
    end
    GerUserDefinedOperatorExpression = function (this, node)
      local methodSymbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node, System.default(SystemThreading.CancellationToken)):getSymbol())
      if methodSymbol ~= nil then
        local typeSymbol = methodSymbol:getContainingType()
        if typeSymbol ~= nil then
          if typeSymbol:getTypeKind() ~= 5 --[[TypeKind.Enum]] and typeSymbol:getTypeKind() ~= 3 --[[TypeKind.Delegate]] and typeSymbol:getSpecialType() == 0 --[[SpecialType.None]] and not CSharpLua.Utility.IsTimeSpanType(typeSymbol) then
            local codeTemplate = getXmlMetaProvider(this):GetMethodCodeTemplate(methodSymbol)
            if codeTemplate ~= nil then
              return BuildCodeTemplateExpression2(this, codeTemplate, nil, System.Array(MicrosoftCodeAnalysisCSharpSyntax.ExpressionSyntax)(node:getLeft(), node:getRight()))
            end

            local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getLeft():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getRight():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            local memberAccess = GetOperatorMemberAccessExpression(this, methodSymbol)
            return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, memberAccess, left, right)
          end
        end
      end
      return nil
    end
    IsNumericalForVariableMatch = function (this, node, identifier)
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node, 8616 --[[SyntaxKind.IdentifierName]]) then
        local identifierName = System.cast(MicrosoftCodeAnalysisCSharpSyntax.IdentifierNameSyntax, node)
        return identifierName:getIdentifier():getValueText() == identifier:getValueText()
      end
      return false
    end
    IsNumericalForLess = function (this, kind, isLess)
      repeat
        local default = kind
        if default == 8681 --[[SyntaxKind.NotEqualsExpression]] or default == 8682 --[[SyntaxKind.LessThanExpression]] then
          isLess = true
          return true, isLess
        elseif default == 8683 --[[SyntaxKind.LessThanOrEqualExpression]] then
          isLess = false
          return true, isLess
        else
          isLess = false
          return false, isLess
        end
      until 1
    end
    IsNumericalForGreater = function (this, kind, isGreater)
      repeat
        local default = kind
        if default == 8681 --[[SyntaxKind.NotEqualsExpression]] or default == 8684 --[[SyntaxKind.GreaterThanExpression]] then
          isGreater = true
          return true, isGreater
        elseif default == 8685 --[[SyntaxKind.GreaterThanOrEqualExpression]] then
          isGreater = false
          return true, isGreater
        else
          isGreater = false
          return false, isGreater
        end
      until 1
    end
    GetNumericalForStatement = function (this, node)
      if node:getDeclaration() == nil or node:getDeclaration():getVariables():getCount() > 1 then
        goto Fail
      end

      if node:getCondition() == nil then
        goto Fail
      end

      if node:getIncrementors():getCount() ~= 1 then
        goto Fail
      end

      local variable = node:getDeclaration():getVariables():First()
      if variable:getInitializer() == nil then
        goto Fail
      end

      local conditionKind = node:getCondition():Kind()
      if conditionKind < 8681 --[[SyntaxKind.NotEqualsExpression]] or conditionKind > 8685 --[[SyntaxKind.GreaterThanOrEqualExpression]] then
        goto Fail
      end

      local condition = System.cast(MicrosoftCodeAnalysisCSharpSyntax.BinaryExpressionSyntax, node:getCondition())
      if not IsNumericalForVariableMatch(this, condition:getLeft(), variable:getIdentifier()) then
        goto Fail
      end

      local limitConst = this.semanticModel_:GetConstantValue(condition:getRight(), System.default(SystemThreading.CancellationToken))
      if limitConst:getHasValue() then
        if not (System.is(limitConst:getValue(), System.Int)) then
          goto Fail
        end
      else
        local isReadOnly = false
        local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, condition:getRight(), System.default(SystemThreading.CancellationToken)):getSymbol()
        if symbol ~= nil then
          if symbol:getKind() == 6 --[[SymbolKind.Field]] then
            isReadOnly = (System.cast(MicrosoftCodeAnalysis.IFieldSymbol, symbol)):getIsReadOnly()
          elseif symbol:getKind() == 15 --[[SymbolKind.Property]] then
            local propertySymbol = System.cast(MicrosoftCodeAnalysis.IPropertySymbol, symbol)
            isReadOnly = propertySymbol:getIsReadOnly() and IsPropertyField(this, propertySymbol)
          end
        end
        if not isReadOnly then
          goto Fail
        end
      end

      local hasNoEqual
      local isPlus
      local incrementor = node:getIncrementors():First()
      repeat
        local default = incrementor:Kind()
        if default == 8734 --[[SyntaxKind.PreIncrementExpression]] or default == 8735 --[[SyntaxKind.PreDecrementExpression]] then
          local prefixUnaryExpression = System.cast(MicrosoftCodeAnalysisCSharpSyntax.PrefixUnaryExpressionSyntax, incrementor)
          if not IsNumericalForVariableMatch(this, prefixUnaryExpression:getOperand(), variable:getIdentifier()) then
            goto Fail
          end
          if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(incrementor, 8734 --[[SyntaxKind.PreIncrementExpression]]) then
            local extern
            extern, hasNoEqual = IsNumericalForLess(this, conditionKind)
            if not extern then
              goto Fail
            end
            isPlus = true
          else
            local ref
            ref, hasNoEqual = IsNumericalForGreater(this, conditionKind)
            if not ref then
              goto Fail
            end
            isPlus = false
          end
          break
        elseif default == 8738 --[[SyntaxKind.PostIncrementExpression]] or default == 8739 --[[SyntaxKind.PostDecrementExpression]] then
          local postfixUnaryExpression = System.cast(MicrosoftCodeAnalysisCSharpSyntax.PostfixUnaryExpressionSyntax, incrementor)
          if not IsNumericalForVariableMatch(this, postfixUnaryExpression:getOperand(), variable:getIdentifier()) then
            goto Fail
          end
          if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(incrementor, 8738 --[[SyntaxKind.PostIncrementExpression]]) then
            local out
            out, hasNoEqual = IsNumericalForLess(this, conditionKind)
            if not out then
              goto Fail
            end
            isPlus = true
          else
            local try
            try, hasNoEqual = IsNumericalForGreater(this, conditionKind)
            if not try then
              goto Fail
            end
            isPlus = false
          end
          break
        else
          goto Fail
        end
      until 1

      local identifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, variable:getIdentifier():getValueText())
      identifier = CheckLocalVariableName(this, identifier, variable)

      local startExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, variable:getInitializer():getValue():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local limitExpression
      local stepExpression = nil
      if hasNoEqual then
        if limitConst:getValue() ~= nil then
          local limit = System.cast(System.Int, limitConst:getValue())
          if isPlus then
            limit = limit - 1
          else
            limit = limit + 1
            stepExpression = CSharpLuaLuaAst.LuaPrefixUnaryExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.One, "-" --[[Tokens.Sub]])
          end
          limitExpression = CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, limit:ToString())
        else
          limitExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, condition:getRight():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          if isPlus then
            limitExpression = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(limitExpression, "-" --[[Tokens.Sub]], CSharpLuaLuaAst.LuaIdentifierNameSyntax.One)
          else
            limitExpression = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(limitExpression, "+" --[[Tokens.Plus]], CSharpLuaLuaAst.LuaIdentifierNameSyntax.One)
            stepExpression = CSharpLuaLuaAst.LuaPrefixUnaryExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.One, "-" --[[Tokens.Sub]])
          end
        end
      else
        limitExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, condition:getRight():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        if not isPlus then
          stepExpression = CSharpLuaLuaAst.LuaPrefixUnaryExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.One, "-" --[[Tokens.Sub]])
        end
      end

      local numericalForStatement = CSharpLuaLuaAst.LuaNumericalForStatementSyntax(identifier, startExpression, limitExpression, stepExpression)
      VisitLoopBody(this, node:getStatement(), numericalForStatement.Body)
      return numericalForStatement

      ::Fail::
      return nil
    end
    GetValueTupleDefaultExpression = function (this, typeSymbol)
      local elementTypes = CSharpLua.Utility.GetTupleElementTypes(typeSymbol)
      return BuildValueTupleCreateExpression(this, Linq.Select(elementTypes, function (i)
        return GetDefaultValueExpression(this, i)
      end, CSharpLuaLuaAst.LuaExpressionSyntax))
    end
    GetDefaultValueExpression = function (this, typeSymbol)
      if typeSymbol:getIsReferenceType() then
        return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.Nil
      end

      if typeSymbol:getIsValueType() then
        if CSharpLua.Utility.IsNullableType(typeSymbol) then
          return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.Nil
        end

        if typeSymbol:getIsTupleType() then
          return GetValueTupleDefaultExpression(this, typeSymbol)
        end

        local predefinedValueType = GetPredefinedValueTypeDefaultValue(typeSymbol)
        if predefinedValueType ~= nil then
          return predefinedValueType
        end
      end

      local typeName = GetTypeName(this, typeSymbol)
      return BuildDefaultValue(typeName)
    end
    BuildDeconstructExpression = function (this, typeSymbol, expression, node)
      local function BuildInvocation() 
        return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(expression, CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, "Deconstruct" --[[kDeconstructName]]), true))
      end

      if typeSymbol:getIsTupleType() then
        local invocationExpression = BuildInvocation()
        invocationExpression:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(2, CSharpLua.Utility.GetTupleElementCount(typeSymbol)))
        return invocationExpression
      elseif CSharpLua.Utility.IsSystemTuple(typeSymbol) then
        local nameTypeSymbol = System.cast(MicrosoftCodeAnalysis.INamedTypeSymbol, typeSymbol)
        local invocationExpression = BuildInvocation()
        invocationExpression:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(2, nameTypeSymbol:getTypeArguments():getLength()))
        return invocationExpression
      else
        local methods = typeSymbol:GetMembers("Deconstruct" --[[kDeconstructName]])
        if methods:getIsEmpty() then
          System.throw(CSharpLua.CompilationErrorException:new(2, node, "current version Roslyn not public api get extension Deconstruct method symbol"))
        end
        return BuildInvocation()
      end
    end
    BuildDeconstructExpression1 = function (this, node, expression)
      local typeSymbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node, System.default(SystemThreading.CancellationToken)):getType()
      return BuildDeconstructExpression(this, typeSymbol, expression, node)
    end
    VisitObjectCreationExpression = function (this, node)
      local constExpression = GetConstExpression(this, node)
      if constExpression ~= nil then
        return constExpression
      end

      local symbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node, System.default(SystemThreading.CancellationToken)):getSymbol())
      local creationExpression
      if symbol ~= nil then
        local codeTemplate = getXmlMetaProvider(this):GetMethodCodeTemplate(symbol)
        if codeTemplate ~= nil then
          creationExpression = BuildCodeTemplateExpression2(this, codeTemplate, nil, Linq.Select(node:getArgumentList():getArguments(), function (i)
            return i:getExpression()
          end, MicrosoftCodeAnalysisCSharpSyntax.ExpressionSyntax), symbol:getTypeArguments())
        elseif MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getType(), 8625 --[[SyntaxKind.NullableType]]) then
          assert(node:getArgumentList():getArguments():getCount() == 1)
          local argument = node:getArgumentList():getArguments():First()
          return argument:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
        elseif symbol:getContainingType():getIsTupleType() then
          local expressions = Linq.Select(node:getArgumentList():getArguments(), function (i)
            return System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, i:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          end, CSharpLuaLuaAst.LuaExpressionSyntax)
          return BuildValueTupleCreateExpression(this, expressions)
        else
          local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          local invokeExpression = BuildObjectCreationInvocation(this, symbol, expression)
          if node:getArgumentList() ~= nil then
            local arguments = BuildArgumentList(this, symbol, symbol:getParameters(), node:getArgumentList())
            TryRemoveNilArgumentsAtTail(this, symbol, arguments)
            invokeExpression:AddArguments(arguments)
          end
          creationExpression = invokeExpression
        end
      else
        local type = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node:getType(), System.default(SystemThreading.CancellationToken)):getSymbol()
        if type ~= nil and type:getKind() == 11 --[[SymbolKind.NamedType]] then
          local nameType = System.cast(MicrosoftCodeAnalysis.INamedTypeSymbol, type)
          if CSharpLua.Utility.IsDelegateType(nameType) then
            assert(node:getArgumentList():getArguments():getCount() == 1)
            local argument = node:getArgumentList():getArguments():First()
            return argument:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
          end
        end

        assert(not node:getArgumentList():getArguments():Any())
        local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        local invokeExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.SystemNew, expression)
        creationExpression = invokeExpression
      end

      if node:getInitializer() == nil then
        return creationExpression
      else
        local functionExpression = BuildObjectInitializerExpression(this, node:getInitializer())
        return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Create, creationExpression, functionExpression)
      end
    end
    BuildObjectInitializerExpression = function (this, node)
      local function_ = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      PushFunction(this, function_)
      local temp = GetTempIdentifier(this, node)
      function_:AddParameter1(temp)
      for _, expression in System.each(node:getExpressions()) do
        if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expression, 8714 --[[SyntaxKind.SimpleAssignmentExpression]]) then
          local assignment = System.cast(MicrosoftCodeAnalysisCSharpSyntax.AssignmentExpressionSyntax, expression)
          local left = assignment:getLeft():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
          local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, assignment:getRight():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(assignment:getLeft(), 8656 --[[SyntaxKind.ImplicitElementAccess]]) then
            local argumentList = System.cast(CSharpLuaLuaAst.LuaArgumentListSyntax, left)
            local methodName = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, "set" --[[Tokens.Set]])
            local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(temp, methodName, true)
            local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess)
            invocation.ArgumentList.Arguments:AddRange(argumentList.Arguments)
            invocation:AddArgument(right)
            function_:AddStatement1(invocation)
          else
            local memberAccess = BuildFieldOrPropertyMemberAccessExpression(this, temp, System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, left), false)
            local assignmentExpression = BuildLuaSimpleAssignmentExpression(this, memberAccess, right)
            function_:AddStatement1(assignmentExpression)
          end
        else
          local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(temp, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Add, true)
          local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess)
          if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expression, 8648 --[[SyntaxKind.ComplexElementInitializerExpression]]) then
            local initializer = System.cast(MicrosoftCodeAnalysisCSharpSyntax.InitializerExpressionSyntax, expression)
            for _, expressionNode in System.each(initializer:getExpressions()) do
              local argumnet = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, expressionNode:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
              invocation:AddArgument(argumnet)
            end
          else
            local value = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            invocation:AddArgument(value)
          end
          function_:AddStatement1(invocation)
        end
      end

      PopFunction(this)
      return function_
    end
    VisitAnonymousObjectMemberDeclarator = function (this, node)
      local name
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      if node:getNameEquals() ~= nil then
        name = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, node:getNameEquals():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      else
        name = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, expression)
      end
      return CSharpLuaLuaAst.LuaKeyValueTableItemSyntax(CSharpLuaLuaAst.LuaTableLiteralKeySyntax(name), expression)
    end
    VisitAnonymousObjectCreationExpression = function (this, node)
      local table = CSharpLuaLuaAst.LuaTableInitializerExpression()
      for _, initializer in System.each(node:getInitializers()) do
        local item = System.cast(CSharpLuaLuaAst.LuaKeyValueTableItemSyntax, initializer:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        table.Items:Add(item)
      end
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.AnonymousTypeCreate, table)
    end
    VisitInitializerExpression = function (this, node)
      assert(MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node, 8646 --[[SyntaxKind.ArrayInitializerExpression]]))
      local arrayType = BuildArrayTypeFromInitializer(this, node)
      return BuildArrayCreationExpression(this, arrayType, node)
    end
    VisitBracketedArgumentList = function (this, node)
      return BuildArgumentList1(this, node:getArguments())
    end
    VisitImplicitElementAccess = function (this, node)
      return node:getArgumentList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
    end
    VisitGenericName = function (this, node)
      local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node, System.default(SystemThreading.CancellationToken)):getSymbol()
      if symbol:getKind() == 9 --[[SymbolKind.Method]] then
        return GetMethodNameExpression(this, System.cast(MicrosoftCodeAnalysis.IMethodSymbol, symbol), node)
      else
        return GetTypeName(this, symbol)
      end
    end
    VisitOmittedArraySizeExpression = function (this, node)
      return nil
    end
    VisitArrayRankSpecifier = function (this, node)
      local rankSpecifier = CSharpLuaLuaAst.LuaArrayRankSpecifierSyntax(node:getRank())
      for _, size in System.each(node:getSizes()) do
        local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, size:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        rankSpecifier.Sizes:Add(expression)
      end
      return rankSpecifier
    end
    VisitArrayType = function (this, node)
      local elementType = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getElementType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))

      local typeExpress = nil
      for _, rank in System.each(Linq.Reverse(node:getRankSpecifiers())) do
        local default
        if rank:getRank() == 1 then
          default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.Array
        else
          default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.MultiArray
        end
        local arrayTypeName = default
        typeExpress = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, arrayTypeName, typeExpress or elementType)
      end

      local arrayRankSpecifier = System.cast(CSharpLuaLuaAst.LuaArrayRankSpecifierSyntax, node:getRankSpecifiers():get(0):Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local arrayTypeAdapter = CSharpLuaLuaAst.LuaArrayTypeAdapterExpressionSyntax(typeExpress, arrayRankSpecifier)
      return arrayTypeAdapter
    end
    FillMultiArrayInitializer = function (this, initializer, rankSpecifier, invocation, isFirst)
      if isFirst then
        rankSpecifier.Items:Add(CSharpLuaLuaAst.LuaSingleTableItemSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(2, initializer:getExpressions():getCount())))
      end

      local index = 0
      for _, expression in System.each(initializer:getExpressions()) do
        if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(expression, 8646 --[[SyntaxKind.ArrayInitializerExpression]]) then
          FillMultiArrayInitializer(this, System.cast(MicrosoftCodeAnalysisCSharpSyntax.InitializerExpressionSyntax, expression), rankSpecifier, invocation, index == 0)
        else
          local item = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          invocation:AddArgument(item)
        end
        index = index + 1
      end
    end
    BuildArrayCreationExpression = function (this, arrayType, initializer)
      if initializer ~= nil and initializer:getExpressions():getCount() > 0 then
        if arrayType:getIsSimapleArray() then
          return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(5, arrayType, Linq.Select(initializer:getExpressions(), function (i)
            return System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          end, CSharpLuaLuaAst.LuaExpressionSyntax))
        else
          local rankSpecifier = CSharpLuaLuaAst.LuaTableInitializerExpression()
          local invocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, arrayType, rankSpecifier)
          FillMultiArrayInitializer(this, initializer, rankSpecifier, invocationExpression, true)
          return invocationExpression
        end
      else
        if arrayType:getIsSimapleArray() then
          local size = arrayType.RankSpecifier.Sizes:get(0)
          if size == nil then
            return BuildEmptyArray(this, arrayType:getBaseType())
          end

          local constSize = size
          if System.is(constSize, CSharpLuaLuaAst.LuaLiteralExpressionSyntax) and constSize:getText() == (0):ToString() then
            return BuildEmptyArray(this, arrayType:getBaseType())
          end

          local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(arrayType, CSharpLuaLuaAst.LuaIdentifierNameSyntax.New, true)
          return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, memberAccess, size)
        else
          local rankSpecifier = CSharpLuaLuaAst.LuaTableInitializerExpression()
          for _, size in System.each(arrayType.RankSpecifier.Sizes) do
            if size ~= nil then
              rankSpecifier.Items:Add(CSharpLuaLuaAst.LuaSingleTableItemSyntax(size))
            else
              rankSpecifier.Items:Add(CSharpLuaLuaAst.LuaSingleTableItemSyntax(CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.Zero))
            end
          end
          return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, arrayType, rankSpecifier)
        end
      end
    end
    VisitArrayCreationExpression = function (this, node)
      local arrayType = System.cast(CSharpLuaLuaAst.LuaArrayTypeAdapterExpressionSyntax, node:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      return BuildArrayCreationExpression(this, arrayType, node:getInitializer())
    end
    BuildArrayTypeFromInitializer = function (this, initializer)
      local rank = 1
      local firstExpression = initializer:getExpressions():First()
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(firstExpression, 8646 --[[SyntaxKind.ArrayInitializerExpression]]) then
        repeat
          rank = rank + 1
          firstExpression = (System.cast(MicrosoftCodeAnalysisCSharpSyntax.InitializerExpressionSyntax, firstExpression)):getExpressions():First()
        until not (MicrosoftCodeAnalysis.CSharpExtensions.IsKind(firstExpression, 8646 --[[SyntaxKind.ArrayInitializerExpression]]))
      end
      local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, firstExpression, System.default(SystemThreading.CancellationToken)):getType()
      local elementType = GetTypeName(this, symbol)
      local default
      if rank == 1 then
        default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.Array
      else
        default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.MultiArray
      end
      local typeExpress = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, default, elementType)
      return CSharpLuaLuaAst.LuaArrayTypeAdapterExpressionSyntax(typeExpress, CSharpLuaLuaAst.LuaArrayRankSpecifierSyntax(rank))
    end
    VisitImplicitArrayCreationExpression = function (this, node)
      local arrayType = BuildArrayTypeFromInitializer(this, node:getInitializer())
      return BuildArrayCreationExpression(this, arrayType, node:getInitializer())
    end
    BuildCallBaseConstructor = function (this, type, baseType, ctroCounter)
      local default
      if not this.generator_:IsSealed(type) then
        default = GetTypeName(this, baseType)
      else
        default = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Base, false)
      end
      local typeName = default
      local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(typeName, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Ctor, false)
      local otherCtorInvoke
      if ctroCounter > 0 then
        otherCtorInvoke = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaTableIndexAccessExpressionSyntax(memberAccess, CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(2, ctroCounter)))
      else
        otherCtorInvoke = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess)
      end
      return otherCtorInvoke
    end
    BuildCallBaseConstructor1 = function (this, typeSymbol)
      local baseType = typeSymbol:getBaseType()
      if baseType ~= nil and baseType:getSpecialType() ~= 1 --[[SpecialType.System_Object]] and baseType:getSpecialType() ~= 5 --[[SpecialType.System_ValueType]] then
        local ctroCounter = 0
        if CSharpLua.Utility.IsFromCode(baseType) then
          if Linq.Count(baseType:getConstructors(), function (i)
            return not i:getIsStatic()
          end) > 1 then
            ctroCounter = 1
          end
        end
        local otherCtorInvoke = BuildCallBaseConstructor(this, typeSymbol, baseType, ctroCounter)
        otherCtorInvoke:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This)
        return otherCtorInvoke
      end
      return nil
    end
    VisitConstructorDeclaration = function (this, node)
      local ctorSymbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, node, System.default(SystemThreading.CancellationToken))
      this.methodInfos_:Push(class.MethodInfo:new(1, ctorSymbol))

      local function_ = CSharpLuaLuaAst.LuaConstructorAdapterExpressionSyntax()
      PushFunction(this, function_)
      local isStatic = CSharpLua.Utility.IsStatic(node:getModifiers())
      function_.IsStatic = isStatic
      function_:AddParameter1(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This)
      local parameterList = System.cast(CSharpLuaLuaAst.LuaParameterListSyntax, node:getParameterList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      function_.ParameterList.Parameters:AddRange(parameterList.Parameters)

      if node:getInitializer() ~= nil then
        local symbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node:getInitializer(), System.default(SystemThreading.CancellationToken)):getSymbol())
        local ctroCounter = GetConstructorIndex(this, symbol)
        local otherCtorInvoke
        if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getInitializer(), 8890 --[[SyntaxKind.ThisConstructorInitializer]]) then
          assert(ctroCounter ~= 0)
          local thisCtor = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, CSharpLuaLuaAst.LuaSyntaxNode.SpecailWord("ctor" --[[Tokens.Ctor]] .. ctroCounter))
          otherCtorInvoke = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, thisCtor)
          function_.IsInvokeThisCtor = true
        else
          otherCtorInvoke = BuildCallBaseConstructor(this, ctorSymbol:getContainingType(), symbol:getReceiverType(), ctroCounter)
        end
        otherCtorInvoke:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This)
        local arguments = BuildArgumentList(this, symbol, symbol:getParameters(), node:getInitializer():getArgumentList())
        otherCtorInvoke:AddArguments(arguments)
        function_:AddStatement1(otherCtorInvoke)
      elseif not isStatic then
        local baseCtorInvoke = BuildCallBaseConstructor1(this, ctorSymbol:getContainingType())
        if baseCtorInvoke ~= nil then
          function_:AddStatement1(baseCtorInvoke)
        end
      end

      if node:getBody() ~= nil then
        local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, node:getBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        function_:AddStatements(block.Statements)
      else
        this.blocks_:Push(function_.Body)
        local bodyExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpressionBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        function_:AddStatement1(bodyExpression)
        this.blocks_:Pop()
      end

      PopFunction(this)
      if isStatic then
        getCurType(this):SetStaticCtor(function_)
      else
        getCurType(this):AddCtor(function_, node:getParameterList():getParameters():getCount() == 0)
      end

      this.methodInfos_:Pop()
      return function_
    end
    VisitSimpleBaseType = function (this, node)
      return node:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
    end
    VisitLambdaExpression = function (this, parameters, body)
      local symbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, MicrosoftCodeAnalysis.ModelExtensions.GetSymbolInfo(this.semanticModel_, body:getParent(), System.default(SystemThreading.CancellationToken)):getSymbol())
      this.methodInfos_:Push(class.MethodInfo:new(1, symbol))

      local function_ = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      PushFunction(this, function_)

      if parameters ~= nil then
        for _, parameter in System.each(parameters) do
          local luaParameter = System.cast(CSharpLuaLuaAst.LuaParameterSyntax, parameter:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          function_.ParameterList.Parameters:Add(luaParameter)
        end
      end

      local resultExpression = function_
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(body, 8792 --[[SyntaxKind.Block]]) then
        local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, body:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        function_:AddStatements(block.Statements)
      else
        local type = System.cast(MicrosoftCodeAnalysis.INamedTypeSymbol, MicrosoftCodeAnalysis.ModelExtensions.GetTypeInfo(this.semanticModel_, body:getParent(), System.default(SystemThreading.CancellationToken)):getConvertedType())
        local delegateInvokeMethod = type:getDelegateInvokeMethod()

        this.blocks_:Push(function_.Body)
        local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, body:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        this.blocks_:Pop()
        if delegateInvokeMethod:getReturnsVoid() then
          function_:AddStatement1(expression)
        else
          function_:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(expression))
        end
      end

      PopFunction(this)
      this.methodInfos_:Pop()

      return resultExpression
    end
    VisitSimpleLambdaExpression = function (this, node)
      return VisitLambdaExpression(this, System.Array(MicrosoftCodeAnalysisCSharpSyntax.ParameterSyntax)(node:getParameter()), node:getBody())
    end
    VisitParenthesizedLambdaExpression = function (this, node)
      return VisitLambdaExpression(this, node:getParameterList():getParameters(), node:getBody())
    end
    VisitAnonymousMethodExpression = function (this, node)
      local default = node:getParameterList()
      if default ~= nil then
        default = default.getParameters()
      end
      return VisitLambdaExpression(this, default, node:getBody())
    end
    VisitTypeParameter = function (this, node)
      return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText())
    end
    VisitTypeOfExpression = function (this, node)
      local type = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getType(), System.default(SystemThreading.CancellationToken)):getType()
      if type ~= nil and type:getTypeKind() == 5 --[[TypeKind.Enum]] then
        AddExportEnum(this, type)
        local typeNameExpression = GetTypeShortName(this, type)
        return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.TypeOf, typeNameExpression)
      end

      local typeName = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.TypeOf, typeName)
    end
    VisitThrowStatement = function (this, node)
      local invocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Throw)
      if node:getExpression() ~= nil then
        local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        invocationExpression:AddArgument(expression)
      else
        local curTryFunction = System.cast(CSharpLuaLuaAst.LuaTryAdapterExpressionSyntax, getCurFunction(this))
        assert(curTryFunction.CatchTemp ~= nil)
        invocationExpression:AddArgument(curTryFunction.CatchTemp)
      end
      return CSharpLuaLuaAst.LuaExpressionStatementSyntax(invocationExpression)
    end
    VisitThrowExpression = function (this, node)
      local invocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Throw)
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      invocationExpression:AddArgument(expression)
      return invocationExpression
    end
    VisitCatchFilterClause = function (this, node)
      return node:getFilterExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
    end
    VisitCatchClause = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    VisitCatchDeclaration = function (this, node)
      return CSharpLuaLuaAst.LuaVariableDeclaratorSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText()))
    end
    VisitTryCatchesExpress = function (this, catches)
      local functionExpress = CSharpLuaLuaAst.LuaTryAdapterExpressionSyntax()
      PushFunction(this, functionExpress)
      local temp = GetTempIdentifier(this, catches:First())
      functionExpress.CatchTemp = temp
      functionExpress:AddParameter1(temp)

      local ifStatement = nil
      local hasCatchRoot = false
      for _, catchNode in System.each(catches) do
        local isRootExceptionDeclaration = false
        local ifCondition = nil
        if catchNode:getFilter() ~= nil then
          ifCondition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, catchNode:getFilter():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        end
        if catchNode:getDeclaration() ~= nil then
          local typeName = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, catchNode:getDeclaration():getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          if typeName.ValueText ~= "System.Exception" then
            local mathcTypeInvocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Is, temp, typeName)
            if ifCondition ~= nil then
              ifCondition = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(ifCondition, "and" --[[Keyword.And]], mathcTypeInvocation)
            else
              ifCondition = mathcTypeInvocation
            end
          else
            if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(catchNode:getDeclaration():getIdentifier(), 0 --[[SyntaxKind.None]]) then
              isRootExceptionDeclaration = true
            end
            hasCatchRoot = true
          end
        else
          hasCatchRoot = true
        end

        local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, catchNode:getBlock():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        if ifCondition ~= nil then
          local body
          if ifStatement == nil then
            ifStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(ifCondition)
            body = ifStatement.Body
          else
            local elseIfStatement = CSharpLuaLuaAst.LuaElseIfStatementSyntax(ifCondition)
            body = elseIfStatement.Body
            ifStatement.ElseIfStatements:Add(elseIfStatement)
          end
          if catchNode:getDeclaration() ~= nil and not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(catchNode:getDeclaration():getIdentifier(), 0 --[[SyntaxKind.None]]) then
            local variableDeclarator = System.cast(CSharpLuaLuaAst.LuaVariableDeclaratorSyntax, catchNode:getDeclaration():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            variableDeclarator.Initializer = CSharpLuaLuaAst.LuaEqualsValueClauseSyntax(temp)
            body.Statements:Add(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(1, variableDeclarator))
          end
          body.Statements:AddRange(block.Statements)
        else
          if isRootExceptionDeclaration then
            local variableDeclarator = System.cast(CSharpLuaLuaAst.LuaVariableDeclaratorSyntax, catchNode:getDeclaration():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
            variableDeclarator.Initializer = CSharpLuaLuaAst.LuaEqualsValueClauseSyntax(temp)
            block.Statements:Insert(0, CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(1, variableDeclarator))
          end

          if ifStatement ~= nil then
            local elseClause = CSharpLuaLuaAst.LuaElseClauseSyntax()
            elseClause.Body.Statements:AddRange(block.Statements)
            ifStatement.Else = elseClause
          else
            functionExpress:AddStatements(block.Statements)
          end
          break
        end
      end

      if ifStatement ~= nil then
        if not hasCatchRoot then
          assert(ifStatement.Else == nil)
          local rethrowStatement = CSharpLuaLuaAst.LuaMultipleReturnStatementSyntax()
          rethrowStatement.Expressions:Add(CSharpLuaLuaAst.LuaIdentifierNameSyntax.One)
          rethrowStatement.Expressions:Add(temp)
          local block = CSharpLuaLuaAst.LuaBlockSyntax()
          block.Statements:Add(rethrowStatement)
          local elseClause = CSharpLuaLuaAst.LuaElseClauseSyntax()
          elseClause.Body.Statements:AddRange(block.Statements)
          ifStatement.Else = elseClause
        end
        functionExpress:AddStatement(ifStatement)
      end

      PopFunction(this)
      return functionExpress
    end
    BuildCheckReturnInvocationExpression = function (this, invocationExpression, node)
      if IsReturnExists(this, node) then
        local curMethodInfo = getCurMethodInfoOrNull(this)
        local isReturnVoid = curMethodInfo ~= nil and curMethodInfo.Symbol:getReturnsVoid()

        local temp1 = GetTempIdentifier(this, node)
        local default
        if isReturnVoid then
          default = nil
        else
          default = GetTempIdentifier(this, node)
        end
        local temp2 = default
        local localVariables = CSharpLuaLuaAst.LuaLocalVariablesStatementSyntax()
        localVariables.Variables:Add(temp1)
        if temp2 ~= nil then
          localVariables.Variables:Add(temp2)
        end
        local initializer = CSharpLuaLuaAst.LuaEqualsValueClauseListSyntax()
        initializer.Values:Add(invocationExpression)
        localVariables.Initializer = initializer

        local ifStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(temp1)
        if System.is(getCurFunction(this), CSharpLuaLuaAst.LuaCheckReturnFunctionExpressionSyntax) then
          local returnStatement = CSharpLuaLuaAst.LuaMultipleReturnStatementSyntax()
          returnStatement.Expressions:Add(CSharpLuaLuaAst.LuaIdentifierNameSyntax.True)
          if temp2 ~= nil then
            returnStatement.Expressions:Add(temp2)
          end
          ifStatement.Body.Statements:Add(returnStatement)
        else
          if curMethodInfo ~= nil and curMethodInfo.RefOrOutParameters:getCount() > 0 then
            local returnStatement = CSharpLuaLuaAst.LuaMultipleReturnStatementSyntax()
            if temp2 ~= nil then
              returnStatement.Expressions:Add(temp2)
            end
            returnStatement.Expressions:AddRange(curMethodInfo.RefOrOutParameters)
            ifStatement.Body.Statements:Add(returnStatement)
          else
            ifStatement.Body.Statements:Add(CSharpLuaLuaAst.LuaReturnStatementSyntax(temp2))
          end
        end

        local statements = CSharpLuaLuaAst.LuaStatementListSyntax()
        statements.Statements:Add(localVariables)
        statements.Statements:Add(ifStatement)
        return statements
      else
        return CSharpLuaLuaAst.LuaExpressionStatementSyntax(invocationExpression)
      end
    end
    VisitFinallyClause = function (this, node)
      local functionExpress = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      PushFunction(this, functionExpress)
      local finallyBlock = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, node:getBlock():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      PopFunction(this)
      functionExpress:AddStatements(finallyBlock.Statements)
      return functionExpress
    end
    VisitTryStatement = function (this, node)
      local tryInvocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Try)

      local tryBlockFunctionExpress = CSharpLuaLuaAst.LuaTryAdapterExpressionSyntax()
      PushFunction(this, tryBlockFunctionExpress)
      local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, node:getBlock():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      PopFunction(this)
      tryBlockFunctionExpress:AddStatements(block.Statements)
      tryInvocationExpression:AddArgument(tryBlockFunctionExpress)

      if node:getCatches():getCount() > 0 then
        local catchesExpress = VisitTryCatchesExpress(this, node:getCatches())
        tryInvocationExpression:AddArgument(catchesExpress)
      else
        tryInvocationExpression:AddArgument(CSharpLuaLuaAst.LuaIdentifierNameSyntax.Nil)
      end

      if node:getFinally() ~= nil then
        local finallyfunctionExpress = System.cast(CSharpLuaLuaAst.LuaFunctionExpressionSyntax, node:getFinally():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        tryInvocationExpression:AddArgument(finallyfunctionExpress)
      end

      return BuildCheckReturnInvocationExpression(this, tryInvocationExpression, node)
    end
    VisitUsingStatement = function (this, node)
      local variableIdentifiers = System.List(CSharpLuaLuaAst.LuaIdentifierNameSyntax)()
      local variableExpressions = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)()
      if node:getDeclaration() ~= nil then
        local variableList = System.cast(CSharpLuaLuaAst.LuaVariableListDeclarationSyntax, node:getDeclaration():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        for _, variable in System.each(variableList.Variables) do
          variableIdentifiers:Add(variable.Identifier)
          variableExpressions:Add(variable.Initializer.Value)
        end
      else
        local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        variableExpressions:Add(expression)
      end

      local usingAdapterExpress = CSharpLuaLuaAst.LuaUsingAdapterExpressionSyntax()
      usingAdapterExpress.ParameterList.Parameters:AddRange(Linq.Select(variableIdentifiers, function (i)
        return CSharpLuaLuaAst.LuaParameterSyntax(i)
      end, CSharpLuaLuaAst.LuaParameterSyntax))
      PushFunction(this, usingAdapterExpress)
      WriteStatementOrBlock(this, node:getStatement(), usingAdapterExpress.Body)
      PopFunction(this)

      if #variableExpressions == 1 then
        local usingInvocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Using)
        usingInvocationExpression:AddArgument(CSharpLua.Utility.First(variableExpressions, CSharpLuaLuaAst.LuaExpressionSyntax))
        usingInvocationExpression:AddArgument(usingAdapterExpress)
        return BuildCheckReturnInvocationExpression(this, usingInvocationExpression, node)
      else
        local usingInvocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaIdentifierNameSyntax.UsingX)
        usingInvocationExpression:AddArgument(usingAdapterExpress)
        usingInvocationExpression.ArgumentList.Arguments:AddRange(Linq.Select(variableExpressions, function (i)
          return CSharpLuaLuaAst.LuaArgumentSyntax(i)
        end, CSharpLuaLuaAst.LuaArgumentSyntax))
        return BuildCheckReturnInvocationExpression(this, usingInvocationExpression, node)
      end
    end
    VisitThisExpression = function (this, node)
      return CSharpLuaLuaAst.LuaIdentifierNameSyntax.This
    end
    CheckBaseVisitType = function (this, parent, symbol, overriddenFunc, T)
      if CSharpLua.Utility.IsOverridable(symbol) then
        local curTypeSymbol = getCurTypeSymbol(this)
        if this.generator_:IsSealed(curTypeSymbol) then
          local exists = Linq.Any(curTypeSymbol:GetMembers():OfType(T), function (i)
            local overriddenSymbol = overriddenFunc(i)
            return overriddenSymbol ~= nil and overriddenSymbol:Equals(symbol)
          end)
          return exists and 2 --[[BaseVisitType.UseBase]] or 0 --[[BaseVisitType.UseThis]]
        else
          return 1 --[[BaseVisitType.UseName]]
        end
      else
        return 0 --[[BaseVisitType.UseThis]]
      end
    end
    VisitBaseExpression = function (this, node)
      local parent = System.cast(MicrosoftCodeAnalysisCSharpSyntax.MemberAccessExpressionSyntax, node:getParent())
      local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, parent, System.default(SystemThreading.CancellationToken)):getSymbol()

      local useType = 0 --[[BaseVisitType.UseThis]]
      repeat
        local default = symbol:getKind()
        if default == 9 --[[SymbolKind.Method]] then
          do
            CSharpLua.Utility.IsOverridable(symbol)
            local methodSymbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, symbol)
            useType = CheckBaseVisitType(this, parent, methodSymbol, function (i)
              return i:getOverriddenMethod()
            end, MicrosoftCodeAnalysis.IMethodSymbol)
            break
          end
        elseif default == 15 --[[SymbolKind.Property]] then
          do
            local propertySymbol = System.cast(MicrosoftCodeAnalysis.IPropertySymbol, symbol)
            if not IsPropertyField(this, propertySymbol) then
              useType = CheckBaseVisitType(this, parent, propertySymbol, function (i)
                return i:getOverriddenProperty()
              end, MicrosoftCodeAnalysis.IPropertySymbol)
            end
            break
          end
        elseif default == 5 --[[SymbolKind.Event]] then
          do
            local eventSymbol = System.cast(MicrosoftCodeAnalysis.IEventSymbol, symbol)
            if not CSharpLua.Utility.IsEventFiled(eventSymbol) then
              useType = CheckBaseVisitType(this, parent, eventSymbol, function (i)
                return i:getOverriddenEvent()
              end, MicrosoftCodeAnalysis.IEventSymbol)
            end
            break
          end
        end
      until 1

      repeat
        local extern = useType
        if extern == 0 --[[BaseVisitType.UseThis]] then
          return CSharpLuaLuaAst.LuaIdentifierNameSyntax.This
        elseif extern == 1 --[[BaseVisitType.UseName]] then
          return GetTypeName(this, symbol:getContainingType())
        elseif extern == 2 --[[BaseVisitType.UseBase]] then
          return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax.This, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Base, false)
        else
          assert(false)
          System.throw(CSharpLua.InvalidOperationException())
        end
      until 1
    end
    VisitConditionalAccessExpression = function (this, node)
      local isEmpty = #this.functions_ == 0
      if isEmpty then
        local function_ = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
        PushFunction(this, function_)
        this.blocks_:Push(function_.Body)
      end

      local isRoot = not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8691 --[[SyntaxKind.ConditionalAccessExpression]])
      if isRoot then
        this.conditionalTemps_:Push(GetTempIdentifier(this, node:getExpression()))
      end

      local temp = this.conditionalTemps_:Peek()
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      if isRoot then
        getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, temp, expression))
      else
        getCurBlock(this).Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(temp, expression)))
      end

      local condition = CSharpLuaLuaAst.LuaBinaryExpressionSyntax(temp, "~=" --[[Tokens.NotEquals]], CSharpLuaLuaAst.LuaIdentifierNameSyntax.Nil)
      local ifStatement = CSharpLuaLuaAst.LuaIfStatementSyntax(condition)
      getCurBlock(this).Statements:Add(ifStatement)

      this.blocks_:Push(ifStatement.Body)
      local whenNotNull = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getWhenNotNull():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      this.blocks_:Pop()

      if isRoot then
        this.conditionalTemps_:Pop()
      end

      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8797 --[[SyntaxKind.ExpressionStatement]]) then
        if isEmpty then
          System.throw(CSharpLua.InvalidOperationException())
        end
        if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getWhenNotNull(), 8691 --[[SyntaxKind.ConditionalAccessExpression]]) then
          ifStatement.Body.Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(whenNotNull))
        end
        return CSharpLuaLuaAst.LuaExpressionSyntax.EmptyExpression
      else
        if not MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getWhenNotNull(), 8691 --[[SyntaxKind.ConditionalAccessExpression]]) then
          local assignment = CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(temp, whenNotNull)
          ifStatement.Body.Statements:Add(CSharpLuaLuaAst.LuaExpressionStatementSyntax(assignment))
        end
        if isEmpty then
          local function_ = getCurFunction(this)
          function_:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(temp))
          this.blocks_:Pop()
          PopFunction(this)
          return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(function_))
        else
          return temp
        end
      end
    end
    VisitMemberBindingExpression = function (this, node)
      local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node, System.default(SystemThreading.CancellationToken)):getSymbol()
      if IsDelegateInvoke(symbol, node:getName()) then
        return this.conditionalTemps_:Peek()
      end
      local nameExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      return CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(this.conditionalTemps_:Peek(), nameExpression, symbol:getKind() == 9 --[[SymbolKind.Method]])
    end
    VisitElementBindingExpression = function (this, node)
      local argumentList = System.cast(CSharpLuaLuaAst.LuaArgumentListSyntax, node:getArgumentList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local memberAccess = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(this.conditionalTemps_:Peek(), CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, "get" --[[Tokens.Get]]), true)
      local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess)
      invocation.ArgumentList.Arguments:AddRange(argumentList.Arguments)
      return invocation
    end
    VisitDefaultExpression = function (this, node)
      local constExpression = GetConstExpression(this, node)
      if constExpression ~= nil then
        return constExpression
      end

      local type = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getType(), System.default(SystemThreading.CancellationToken)):getType()
      return GetDefaultValueExpression(this, type)
    end
    VisitElementAccessExpression = function (this, node)
      local symbol = System.cast(MicrosoftCodeAnalysis.IPropertySymbol, MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetSymbolInfo(this.semanticModel_, node, System.default(SystemThreading.CancellationToken)):getSymbol())
      local expression = BuildMemberAccessTargetExpression(this, node:getExpression())
      local default
      if symbol == nil then
        default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.Empty
      else
        default = GetMemberName(this, symbol)
      end
      local baseName = default
      local identifierName = CSharpLuaLuaAst.LuaPropertyOrEventIdentifierNameSyntax:new(1, true, baseName)
      local propertyAdapter = CSharpLuaLuaAst.LuaPropertyAdapterExpressionSyntax:new(2, expression, identifierName, true)
      if symbol ~= nil then
        local arguments = BuildArgumentList(this, symbol, symbol:getParameters(), node:getArgumentList())
        propertyAdapter.ArgumentList:AddArguments(arguments)
      else
        local argumentList = System.cast(CSharpLuaLuaAst.LuaArgumentListSyntax, node:getArgumentList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        propertyAdapter.ArgumentList.Arguments:AddRange(argumentList.Arguments)
      end
      return propertyAdapter
    end
    VisitInterpolatedStringExpression = function (this, node)
      local index = 0
      local sb = SystemText.StringBuilder()
      local expressions = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)()
      for _, content in System.each(node:getContents()) do
        if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(content, 8919 --[[SyntaxKind.InterpolatedStringText]]) then
          local stringText = System.cast(MicrosoftCodeAnalysisCSharpSyntax.InterpolatedStringTextSyntax, content)
          sb:Append(stringText:getTextToken():getValueText())
        else
          local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, content:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
          expressions:Add(expression)
          sb:AppendChar(123 --[['{']])
          sb:Append(index)
          sb:AppendChar(125 --[['}']])
          index = index + 1
        end
      end

      local format
      if Linq.Contains(node:getStringStartToken():getValueText(), 64 --[['@']]) then
        format = BuildVerbatimStringExpression(this, sb:ToString())
      else
        format = BuildStringLiteralExpression(this, sb:ToString())
      end
      local memberAccessExpression = CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(CSharpLuaLuaAst.LuaParenthesizedExpressionSyntax(format), CSharpLuaLuaAst.LuaIdentifierNameSyntax.Format, true)
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(5, memberAccessExpression, expressions)
    end
    VisitInterpolation = function (this, node)
      return node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
    end
    VisitInterpolatedStringText = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    VisitAliasQualifiedName = function (this, node)
      return node:getName():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
    end
    BuildOperatorMethodDeclaration = function (this, node)
      local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(this.semanticModel_, node, System.default(SystemThreading.CancellationToken))
      this.methodInfos_:Push(class.MethodInfo:new(1, symbol))

      local isStatic = symbol:getIsStatic()
      local isPrivate = CSharpLua.Utility.IsPrivate(symbol)

      local name = GetMemberName(this, symbol)
      local parameterList = System.cast(CSharpLuaLuaAst.LuaParameterListSyntax, node:getParameterList():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local function_ = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      function_.ParameterList.Parameters:AddRange(parameterList.Parameters)
      PushFunction(this, function_)

      local comments = BuildDocumentationComment(this, node)
      local block = System.cast(CSharpLuaLuaAst.LuaBlockSyntax, node:getBody():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      function_:AddStatements(block.Statements)
      getCurType(this):AddMethod(name, function_, isPrivate, comments)

      PopFunction(this)
      this.methodInfos_:Pop()
    end
    VisitConversionOperatorDeclaration = function (this, node)
      BuildOperatorMethodDeclaration(this, node)
      return this.__base__.VisitConversionOperatorDeclaration(this, node)
    end
    VisitOperatorDeclaration = function (this, node)
      BuildOperatorMethodDeclaration(this, node)
      return this.__base__.VisitOperatorDeclaration(this, node)
    end
    VisitSizeOfExpression = function (this, node)
      local constExpression = GetConstExpression(this, node)
      assert(constExpression ~= nil)
      return constExpression
    end
    VisitStackAllocArrayCreationExpression = function (this, node)
      local arrayType = System.cast(CSharpLuaLuaAst.LuaArrayTypeAdapterExpressionSyntax, node:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      assert(arrayType:getIsSimapleArray())
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.StackAlloc, arrayType, arrayType.RankSpecifier.Sizes:get(0))
    end
    VisitUnsafeStatement = function (this, node)
      local statements = CSharpLuaLuaAst.LuaStatementListSyntax()
      statements.Statements:Add(CSharpLuaLuaAst.LuaShortCommentStatement(" " .. node:getUnsafeKeyword():ToString()))
      local block = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, node:getBlock():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      statements.Statements:Add(block)
      return statements
    end
    VisitFixedStatement = function (this, node)
      local statements = CSharpLuaLuaAst.LuaStatementListSyntax()
      statements.Statements:Add(CSharpLuaLuaAst.LuaShortCommentStatement(" " .. node:getFixedKeyword():ToString()))
      local block = CSharpLuaLuaAst.LuaBlockStatementSyntax()
      local declaration = System.cast(CSharpLuaLuaAst.LuaStatementSyntax, node:getDeclaration():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      block.Statements:Add(declaration)
      WriteStatementOrBlock(this, node:getStatement(), block)
      statements.Statements:Add(block)
      return statements
    end
    VisitLockStatement = function (this, node)
      local statements = CSharpLuaLuaAst.LuaStatementListSyntax()
      statements.Statements:Add(CSharpLuaLuaAst.LuaShortCommentStatement((" {0}({1})"):Format(node:getLockKeyword(), node:getExpression())))
      local block = CSharpLuaLuaAst.LuaBlockStatementSyntax()
      WriteStatementOrBlock(this, node:getStatement(), block)
      statements.Statements:Add(block)
      return statements
    end
    VisitArrowExpressionClause = function (this, node)
      return node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
    end
    VisitLocalFunctionStatement = function (this, node)
      local result = BuildMethodDeclaration(this, node, System.default(MicrosoftCodeAnalysis.SyntaxList_1(MicrosoftCodeAnalysisCSharpSyntax.AttributeListSyntax)), node:getParameterList(), node:getTypeParameterList(), node:getBody(), node:getExpressionBody(), node:getReturnType())
      local parentNode = FindParent(this, node, function (i)
        return MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i, 8875 --[[SyntaxKind.MethodDeclaration]]) or MicrosoftCodeAnalysis.CSharpExtensions.IsKind(i, 8830 --[[SyntaxKind.LocalFunctionStatement]])
      end)
      local default
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(parentNode, 8875 --[[SyntaxKind.MethodDeclaration]]) then
        default = (System.cast(MicrosoftCodeAnalysisCSharpSyntax.MethodDeclarationSyntax, parentNode)):getBody()
      else
        default = (System.cast(MicrosoftCodeAnalysisCSharpSyntax.LocalFunctionStatementSyntax, parentNode)):getBody()
      end
      local body = default
      local isOnlyOne = Linq.Count(SystemLinq.Enumerable.OfType(body:getStatements(), MicrosoftCodeAnalysisCSharpSyntax.LocalFunctionStatementSyntax)) == 1
      if isOnlyOne then
        return CSharpLuaLuaAst.LuaLocalFunctionSyntx(result.Name, result.Function, result.Document)
      else
        local block = this.blocks_:Peek()
        block:AddLocalArea(result.Name)
        local localVar = CSharpLua.Utility.ToStatement(CSharpLuaLuaAst.LuaAssignmentExpressionSyntax(result.Name, result.Function))
        if result.Document ~= nil and not result.Document:getIsEmpty() then
          local statementList = CSharpLuaLuaAst.LuaStatementListSyntax()
          statementList.Statements:Add(result.Document)
          statementList.Statements:Add(localVar)
          return statementList
        else
          return localVar
        end
      end
    end
    VisitDeclarationExpression = function (this, node)
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8638 --[[SyntaxKind.Argument]]) then
        --out var 
        local name = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, node:getDesignation():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        this.blocks_:Peek().Statements:Add(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, name))
        return name
      else
        --ValueTuple deconstruction
        return node:getDesignation():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
      end
    end
    VisitDiscardDesignation = function (this, node)
      return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getUnderscoreToken():getValueText())
    end
    VisitSingleVariableDesignation = function (this, node)
      local name = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText())
      name = CheckLocalVariableName(this, name, node)
      return name
    end
    VisitIsPatternExpression = function (this, node)
      local declarationPattern = System.cast(MicrosoftCodeAnalysisCSharpSyntax.DeclarationPatternSyntax, node:getPattern())
      local name = System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, declarationPattern:getDesignation():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      this.blocks_:Peek().Statements:Add(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, name, expression))

      local leftType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getExpression(), System.default(SystemThreading.CancellationToken)):getType()
      local rightType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, declarationPattern:getType(), System.default(SystemThreading.CancellationToken)):getType()
      if CSharpLua.Utility.IsSubclassOf(leftType, rightType) then
        return CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.True
      else
        local type = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, declarationPattern:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Is, name, type)
      end
    end
    VisitDeclarationPattern = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    VisitRefExpression = function (this, node)
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getExpression(), 8634 --[[SyntaxKind.InvocationExpression]]) then
        System.throw(CSharpLua.CompilationErrorException:new(2, node, "ref returns is not support"))
      end
      return node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode)
    end
    VisitTupleType = function (this, node)
      return CSharpLuaLuaAst.LuaIdentifierNameSyntax.ValueTupleType
    end
    BuildValueTupleCreateExpression = function (this, expressions)
      local table = CSharpLuaLuaAst.LuaTableInitializerExpression()
      table.Items:AddRange(Linq.Select(expressions, function (i)
        return CSharpLuaLuaAst.LuaSingleTableItemSyntax(i)
      end, CSharpLuaLuaAst.LuaSingleTableItemSyntax))
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax.ValueTupleTypeCreate, table)
    end
    VisitTupleExpression = function (this, node)
      local expressions = Linq.Select(node:getArguments(), function (i)
        return System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, i:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      end, CSharpLuaLuaAst.LuaExpressionSyntax)
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getParent(), 8714 --[[SyntaxKind.SimpleAssignmentExpression]]) then
        local assigment = System.cast(MicrosoftCodeAnalysisCSharpSyntax.AssignmentExpressionSyntax, node:getParent())
        if assigment:getLeft() == node then
          local list = CSharpLuaLuaAst.LuaSequenceListExpressionSyntax()
          list.Expressions:AddRange(expressions)
          return list
        end
      end
      return BuildValueTupleCreateExpression(this, expressions)
    end
    VisitParenthesizedVariableDesignation = function (this, node)
      local expression = CSharpLuaLuaAst.LuatLocalTupleVariableExpression()
      expression.Variables:AddRange(Linq.Select(node:getVariables(), function (i)
        return System.cast(CSharpLuaLuaAst.LuaIdentifierNameSyntax, i:Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      end, CSharpLuaLuaAst.LuaIdentifierNameSyntax))
      return expression
    end
    AddRangeIdentifier = function (this, identifier)
      local name = identifier:getValueText()
      if name == CSharpLuaLuaAst.LuaIdentifierNameSyntax.Placeholder.ValueText then
        if this.queryIdentifiers_:Exists(function (i)
          return i:getHasPack()
        end) then
          name = "as" --[[LuaSyntaxNodeTransform.kQueryPlaceholderConflictName]]
        end
      else
        local default
        default, name = CheckLocalBadWord(this, name, identifier:getParent())
      end
      local queryIdentifier = class.QueryIdentifier(identifier:__clone__(), CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name))
      this.queryIdentifiers_:Add(queryIdentifier)
      return queryIdentifier
    end
    GetRangeIdentifierName = function (this, name)
      local info = this.queryIdentifiers_:Find(function (i)
        return i.Identifier:getValueText() == name:getIdentifier():getValueText()
      end)
      assert(info ~= nil)
      return info:GetIdentifierName()
    end
    VisitQueryExpression = function (this, node)
      getCurCompilationUnit(this):ImportLinq()

      local rangeVariable = AddRangeIdentifier(this, node:getFromClause():getIdentifier())
      local collection = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getFromClause():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local queryExpression = BuildQueryBody(this, collection, node:getBody(), rangeVariable)
      this.queryIdentifiers_:Clear()
      return queryExpression
    end
    VisitFromClause = function (this, node)
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      if node:getType() ~= nil then
        local typeName = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getType():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        expression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.LinqCast, expression, typeName)
      end
      return expression
    end
    VisitWhereClause = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    VisitQueryBody = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    VisitSelectClause = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    VisitQueryContinuation = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    VisitLetClause = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    VisitJoinClause = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    VisitJoinIntoClause = function (this, node)
      System.throw(CSharpLua.InvalidOperationException())
    end
    BuildQueryWhere = function (this, collection, node, rangeVariable)
      local condition = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      if condition == CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.True then
        return collection
      end

      local whereFunction = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      whereFunction:AddParameter1(rangeVariable:getName())
      whereFunction:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(condition))
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLuaLuaAst.LuaIdentifierNameSyntax.LinqWhere, collection, whereFunction)
    end
    BuildOrdering = function (this, methodName, collection, node, rangeVariable)
      local type = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getExpression(), System.default(SystemThreading.CancellationToken)):getType()
      local typeName = GetTypeName(this, type)
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local keySelector = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      keySelector:AddParameter1(rangeVariable:getName())
      keySelector:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(expression))
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(6, methodName, System.Array(CSharpLuaLuaAst.LuaExpressionSyntax)(collection, keySelector, CSharpLuaLuaAst.LuaIdentifierNameSyntax.Nil, typeName))
    end
    BuildQueryOrderBy = function (this, collection, node, rangeVariable)
      for _, ordering in System.each(node:getOrderings()) do
        local isDescending = MicrosoftCodeAnalysis.CSharpExtensions.IsKind(ordering:getAscendingOrDescendingKeyword(), 8433 --[[SyntaxKind.DescendingKeyword]])
        if ordering == node:getOrderings():First() then
          local default
          if isDescending then
            default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.LinqOrderByDescending
          else
            default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.LinqOrderBy
          end
          local methodName = default
          collection = BuildOrdering(this, methodName, collection, ordering, rangeVariable)
        else
          local extern
          if isDescending then
            extern = CSharpLuaLuaAst.LuaIdentifierNameSyntax.LinqThenByDescending
          else
            extern = CSharpLuaLuaAst.LuaIdentifierNameSyntax.LinqThenBy
          end
          local methodName = extern
          collection = BuildOrdering(this, methodName, collection, ordering, rangeVariable)
        end
      end
      return collection
    end
    BuildQuerySelect = function (this, collection, node, rangeVariable)
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getExpression(), 8616 --[[SyntaxKind.IdentifierName]]) then
        local identifierName = expression
        if System.is(identifierName, CSharpLuaLuaAst.LuaIdentifierNameSyntax) and identifierName.ValueText == rangeVariable:getName().ValueText then
          return collection
        end
      end

      local selectFunction = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      selectFunction:AddParameter1(rangeVariable:getName())
      selectFunction:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(expression))
      local type = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getExpression(), System.default(SystemThreading.CancellationToken)):getType()
      local typeExpression = GetTypeName(this, type)
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(4, CSharpLuaLuaAst.LuaIdentifierNameSyntax.LinqSelect, collection, selectFunction, typeExpression)
    end
    BuildGroupClause = function (this, collection, node, rangeVariable)
      local keyType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getByExpression(), System.default(SystemThreading.CancellationToken)):getType()
      local keyTypeName = GetTypeName(this, keyType)
      local byExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getByExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local keySelector = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      keySelector:AddParameter1(rangeVariable:getName())
      keySelector:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(byExpression))

      local groupExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getGroupExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getGroupExpression(), 8616 --[[SyntaxKind.IdentifierName]]) then
        local groupIdentifierName = groupExpression
        if System.is(groupIdentifierName, CSharpLuaLuaAst.LuaIdentifierNameSyntax) and groupIdentifierName.ValueText == rangeVariable:getName().ValueText then
          return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(4, CSharpLuaLuaAst.LuaIdentifierNameSyntax.LinqGroupBy, collection, keySelector, keyTypeName)
        end
      end

      local elementType = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getGroupExpression(), System.default(SystemThreading.CancellationToken)):getType()
      local elementTypeName = GetTypeName(this, elementType)
      local elementSelector = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      elementSelector:AddParameter1(rangeVariable:getName())
      elementSelector:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(groupExpression))
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(6, CSharpLuaLuaAst.LuaIdentifierNameSyntax.LinqGroupBy, System.Array(CSharpLuaLuaAst.LuaExpressionSyntax)(collection, keySelector, elementSelector, keyTypeName, elementTypeName))
    end
    CreateQueryAnonymousType = function (this, key1, value1, key2, value2)
      local table = CSharpLuaLuaAst.LuaTableInitializerExpression()
      table.Items:Add(CSharpLuaLuaAst.LuaKeyValueTableItemSyntax(CSharpLuaLuaAst.LuaTableLiteralKeySyntax(key1), value1))
      table.Items:Add(CSharpLuaLuaAst.LuaKeyValueTableItemSyntax(CSharpLuaLuaAst.LuaTableLiteralKeySyntax(key2), value2))
      return table
    end
    IsSpecialQueryNode = function (this, node)
      return node:getClauses():getCount() == 1 and MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getSelectOrGroup(), 8784 --[[SyntaxKind.SelectClause]])
    end
    BuildFromClause = function (this, collection, node, rangeVariable, isOver)
      local collectionSelector = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      collectionSelector:AddParameter1(rangeVariable:getName())
      local expression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      collectionSelector:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(expression))

      local rangeVariable2 = AddRangeIdentifier(this, node:getIdentifier())
      local resultSelector = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      resultSelector:AddParameter1(rangeVariable:getName())
      resultSelector:AddParameter1(rangeVariable2:getName())
      local resultSelectorExpression
      local resultSelectorType
      local parentNode = System.cast(MicrosoftCodeAnalysisCSharpSyntax.QueryBodySyntax, node:getParent())
      if IsSpecialQueryNode(this, parentNode) then
        local selectClause = System.cast(MicrosoftCodeAnalysisCSharpSyntax.SelectClauseSyntax, parentNode:getSelectOrGroup())
        resultSelectorExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, selectClause:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        local type = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, selectClause:getExpression(), System.default(SystemThreading.CancellationToken)):getType()
        resultSelectorType = GetTypeName(this, type)
        isOver = true
      else
        resultSelectorExpression = CreateQueryAnonymousType(this, rangeVariable:getName(), rangeVariable:getName(), rangeVariable2:getName(), rangeVariable2:getName())
        resultSelectorType = CSharpLuaLuaAst.LuaIdentifierNameSyntax.AnonymousType
        rangeVariable = class.QueryPackVariable(rangeVariable, rangeVariable2)
        isOver = false
      end
      resultSelector:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(resultSelectorExpression))
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(6, CSharpLuaLuaAst.LuaIdentifierNameSyntax.LinqSelectMany, System.Array(CSharpLuaLuaAst.LuaExpressionSyntax)(collection, collectionSelector, resultSelector, resultSelectorType)), rangeVariable, isOver
    end
    BuildLetClause = function (this, collection, node, rangeVariable)
      local letExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local letRangeVariable = AddRangeIdentifier(this, node:getIdentifier())
      local anonymousType = CreateQueryAnonymousType(this, rangeVariable:getName(), rangeVariable:getName(), letRangeVariable:getName(), letExpression)

      local selectFunction = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      selectFunction:AddParameter1(rangeVariable:getName())
      selectFunction:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(anonymousType))

      rangeVariable = class.QueryPackVariable(rangeVariable, letRangeVariable)
      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(4, CSharpLuaLuaAst.LuaIdentifierNameSyntax.LinqSelect, collection, selectFunction, CSharpLuaLuaAst.LuaIdentifierNameSyntax.AnonymousType), rangeVariable
    end
    BuildQueryJoin = function (this, node, resultSelectorExpression, resultSelectorType, rangeVariable, queryIdentifier)
      local parentNode = System.cast(MicrosoftCodeAnalysisCSharpSyntax.QueryBodySyntax, node:getParent())
      if IsSpecialQueryNode(this, parentNode) then
        local selectClause = System.cast(MicrosoftCodeAnalysisCSharpSyntax.SelectClauseSyntax, parentNode:getSelectOrGroup())
        resultSelectorExpression = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, selectClause:getExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
        local typeSymbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, selectClause:getExpression(), System.default(SystemThreading.CancellationToken)):getType()
        resultSelectorType = GetTypeName(this, typeSymbol)
        return true, resultSelectorExpression, resultSelectorType, rangeVariable
      else
        resultSelectorExpression = CreateQueryAnonymousType(this, rangeVariable:getName(), rangeVariable:getName(), queryIdentifier:getName(), queryIdentifier:getName())
        resultSelectorType = CSharpLuaLuaAst.LuaIdentifierNameSyntax.AnonymousType
        rangeVariable = class.QueryPackVariable(rangeVariable, queryIdentifier)
        return false, resultSelectorExpression, resultSelectorType, rangeVariable
      end
    end
    BuildJoinClause = function (this, collection, node, rangeVariable, isOver)
      isOver = false

      local rangeVariable2 = AddRangeIdentifier(this, node:getIdentifier())
      local inner = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getInExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local left = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getLeftExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local outerKeySelector = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      outerKeySelector:AddParameter1(rangeVariable:getName())
      outerKeySelector:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(left))

      local keyTypeSymbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(this.semanticModel_, node:getLeftExpression(), System.default(SystemThreading.CancellationToken)):getType()
      local keyType = GetTypeName(this, keyTypeSymbol)

      local right = System.cast(CSharpLuaLuaAst.LuaExpressionSyntax, node:getRightExpression():Accept(this, CSharpLuaLuaAst.LuaSyntaxNode))
      local innerKeySelector = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      innerKeySelector:AddStatement1(rangeVariable2:getName())
      innerKeySelector:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(right))

      local resultSelector = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
      local resultSelectorExpression
      local resultSelectorType
      local methodName

      local parentNode = System.cast(MicrosoftCodeAnalysisCSharpSyntax.QueryBodySyntax, node:getParent())
      if node:getInto() == nil then
        methodName = CSharpLuaLuaAst.LuaIdentifierNameSyntax.LinqJoin
        resultSelector:AddParameter1(rangeVariable:getName())
        resultSelector:AddParameter1(rangeVariable2:getName())
        local default
        default, resultSelectorExpression, resultSelectorType, rangeVariable = BuildQueryJoin(this, node, nil, nil, rangeVariable, rangeVariable2)
        isOver = default
      else
        methodName = CSharpLuaLuaAst.LuaIdentifierNameSyntax.LinqGroupJoin
        local rangeVariableOfInto = AddRangeIdentifier(this, node:getInto():getIdentifier())
        resultSelector:AddParameter1(rangeVariable:getName())
        resultSelector:AddParameter1(rangeVariableOfInto:getName())
        local extern
        extern, resultSelectorExpression, resultSelectorType, rangeVariable = BuildQueryJoin(this, node, nil, nil, rangeVariable, rangeVariableOfInto)
        isOver = extern
      end

      return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(6, methodName, System.Array(CSharpLuaLuaAst.LuaExpressionSyntax)(collection, inner, outerKeySelector, innerKeySelector, resultSelector, CSharpLuaLuaAst.LuaIdentifierLiteralExpressionSyntax.Nil, keyType, resultSelectorType)), rangeVariable, isOver
    end
    BuildQueryBody = function (this, collection, node, rangeVariable)
      for _, clause in System.each(node:getClauses()) do
        repeat
          local default = clause:Kind()
          if default == 8776 --[[SyntaxKind.FromClause]] then
            do
              local isOver
              local extern
              extern, rangeVariable, isOver = BuildFromClause(this, collection, System.cast(MicrosoftCodeAnalysisCSharpSyntax.FromClauseSyntax, clause), rangeVariable)
              collection = extern
              if isOver then
                goto Continuation
              end
              break
            end
          elseif default == 8777 --[[SyntaxKind.LetClause]] then
            do
              local ref
              ref, rangeVariable = BuildLetClause(this, collection, System.cast(MicrosoftCodeAnalysisCSharpSyntax.LetClauseSyntax, clause), rangeVariable)
              collection = ref
              break
            end
          elseif default == 8778 --[[SyntaxKind.JoinClause]] then
            do
              local isOver
              local out
              out, rangeVariable, isOver = BuildJoinClause(this, collection, System.cast(MicrosoftCodeAnalysisCSharpSyntax.JoinClauseSyntax, clause), rangeVariable)
              collection = out
              if isOver then
                goto Continuation
              end
              break
            end
          elseif default == 8780 --[[SyntaxKind.WhereClause]] then
            do
              collection = BuildQueryWhere(this, collection, System.cast(MicrosoftCodeAnalysisCSharpSyntax.WhereClauseSyntax, clause), rangeVariable)
              break
            end
          elseif default == 8781 --[[SyntaxKind.OrderByClause]] then
            do
              collection = BuildQueryOrderBy(this, collection, System.cast(MicrosoftCodeAnalysisCSharpSyntax.OrderByClauseSyntax, clause), rangeVariable)
              break
            end
          else
            do
              System.throw(System.NotSupportedException())
            end
          end
        until 1
      end

      if MicrosoftCodeAnalysis.CSharpExtensions.IsKind(node:getSelectOrGroup(), 8784 --[[SyntaxKind.SelectClause]]) then
        local selectClause = System.cast(MicrosoftCodeAnalysisCSharpSyntax.SelectClauseSyntax, node:getSelectOrGroup())
        collection = BuildQuerySelect(this, collection, selectClause, rangeVariable)
      else
        local groupClause = System.cast(MicrosoftCodeAnalysisCSharpSyntax.GroupClauseSyntax, node:getSelectOrGroup())
        collection = BuildGroupClause(this, collection, groupClause, rangeVariable)
      end

      ::Continuation::
      if node:getContinuation() ~= nil then
        collection = BuildQueryContinuation(this, collection, node:getContinuation())
      end
      return collection
    end
    BuildQueryContinuation = function (this, collection, node)
      local rangeVariable = AddRangeIdentifier(this, node:getIdentifier())
      return BuildQueryBody(this, collection, node:getBody(), rangeVariable)
    end
    class = {
      __inherits__ = function (global)
        return {
          Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor_1(global.CSharpLua.LuaAst.LuaSyntaxNode)
        }
      end,
      inheritNameNodeCounter_ = 0,
      getIsGetInheritTypeName = getIsGetInheritTypeName,
      getCurTypeDeclaration = getCurTypeDeclaration,
      VisitCompilationUnit = VisitCompilationUnit,
      VisitNamespaceDeclaration = VisitNamespaceDeclaration,
      AcceptPartialType = AcceptPartialType,
      VisitClassDeclaration = VisitClassDeclaration,
      VisitStructDeclaration = VisitStructDeclaration,
      VisitInterfaceDeclaration = VisitInterfaceDeclaration,
      VisitEnumDeclaration = VisitEnumDeclaration,
      VisitDelegateDeclaration = VisitDelegateDeclaration,
      VisitMethodDeclaration = VisitMethodDeclaration,
      VisitFieldDeclaration = VisitFieldDeclaration,
      VisitPropertyDeclaration = VisitPropertyDeclaration,
      VisitEventDeclaration = VisitEventDeclaration,
      VisitEventFieldDeclaration = VisitEventFieldDeclaration,
      VisitEnumMemberDeclaration = VisitEnumMemberDeclaration,
      VisitIndexerDeclaration = VisitIndexerDeclaration,
      VisitBracketedParameterList = VisitBracketedParameterList,
      VisitParameterList = VisitParameterList,
      VisitParameter = VisitParameter,
      VisitBlock = VisitBlock,
      VisitReturnStatement = VisitReturnStatement,
      VisitExpressionStatement = VisitExpressionStatement,
      VisitAssignmentExpression = VisitAssignmentExpression,
      VisitInvocationExpression = VisitInvocationExpression,
      VisitMemberAccessExpression = VisitMemberAccessExpression,
      VisitIdentifierName = VisitIdentifierName,
      VisitQualifiedName = VisitQualifiedName,
      VisitArgumentList = VisitArgumentList,
      VisitArgument = VisitArgument,
      VisitLiteralExpression = VisitLiteralExpression,
      VisitLocalDeclarationStatement = VisitLocalDeclarationStatement,
      VisitVariableDeclaration = VisitVariableDeclaration,
      VisitVariableDeclarator = VisitVariableDeclarator,
      VisitEqualsValueClause = VisitEqualsValueClause,
      VisitPredefinedType = VisitPredefinedType,
      VisitIfStatement = VisitIfStatement,
      VisitElseClause = VisitElseClause,
      VisitSwitchStatement = VisitSwitchStatement,
      VisitSwitchSection = VisitSwitchSection,
      VisitCaseSwitchLabel = VisitCaseSwitchLabel,
      VisitCasePatternSwitchLabel = VisitCasePatternSwitchLabel,
      VisitWhenClause = VisitWhenClause,
      VisitConstantPattern = VisitConstantPattern,
      VisitBreakStatement = VisitBreakStatement,
      VisitBinaryExpression = VisitBinaryExpression,
      VisitPrefixUnaryExpression = VisitPrefixUnaryExpression,
      VisitPostfixUnaryExpression = VisitPostfixUnaryExpression,
      VisitContinueStatement = VisitContinueStatement,
      VisitForEachStatement = VisitForEachStatement,
      VisitForEachVariableStatement = VisitForEachVariableStatement,
      VisitWhileStatement = VisitWhileStatement,
      VisitForStatement = VisitForStatement,
      VisitDoStatement = VisitDoStatement,
      VisitYieldStatement = VisitYieldStatement,
      VisitParenthesizedExpression = VisitParenthesizedExpression,
      VisitConditionalExpression = VisitConditionalExpression,
      VisitGotoStatement = VisitGotoStatement,
      VisitLabeledStatement = VisitLabeledStatement,
      VisitEmptyStatement = VisitEmptyStatement,
      VisitCastExpression = VisitCastExpression,
      VisitCheckedStatement = VisitCheckedStatement,
      VisitCheckedExpression = VisitCheckedExpression,
      localMappingCounter_ = 0,
      ImportTypeName = ImportTypeName,
      VisitAttributeList = VisitAttributeList,
      VisitAttributeArgument = VisitAttributeArgument,
      VisitNameColon = VisitNameColon,
      VisitAttributeArgumentList = VisitAttributeArgumentList,
      VisitNameEquals = VisitNameEquals,
      VisitAttribute = VisitAttribute,
      VisitTypeParameterList = VisitTypeParameterList,
      CheckFieldNameOfProtobufnet = CheckFieldNameOfProtobufnet,
      VisitObjectCreationExpression = VisitObjectCreationExpression,
      VisitAnonymousObjectMemberDeclarator = VisitAnonymousObjectMemberDeclarator,
      VisitAnonymousObjectCreationExpression = VisitAnonymousObjectCreationExpression,
      VisitInitializerExpression = VisitInitializerExpression,
      VisitBracketedArgumentList = VisitBracketedArgumentList,
      VisitImplicitElementAccess = VisitImplicitElementAccess,
      VisitGenericName = VisitGenericName,
      VisitOmittedArraySizeExpression = VisitOmittedArraySizeExpression,
      VisitArrayRankSpecifier = VisitArrayRankSpecifier,
      VisitArrayType = VisitArrayType,
      VisitArrayCreationExpression = VisitArrayCreationExpression,
      VisitImplicitArrayCreationExpression = VisitImplicitArrayCreationExpression,
      VisitConstructorDeclaration = VisitConstructorDeclaration,
      VisitSimpleBaseType = VisitSimpleBaseType,
      VisitSimpleLambdaExpression = VisitSimpleLambdaExpression,
      VisitParenthesizedLambdaExpression = VisitParenthesizedLambdaExpression,
      VisitAnonymousMethodExpression = VisitAnonymousMethodExpression,
      VisitTypeParameter = VisitTypeParameter,
      VisitTypeOfExpression = VisitTypeOfExpression,
      VisitThrowStatement = VisitThrowStatement,
      VisitThrowExpression = VisitThrowExpression,
      VisitCatchFilterClause = VisitCatchFilterClause,
      VisitCatchClause = VisitCatchClause,
      VisitCatchDeclaration = VisitCatchDeclaration,
      VisitFinallyClause = VisitFinallyClause,
      VisitTryStatement = VisitTryStatement,
      VisitUsingStatement = VisitUsingStatement,
      VisitThisExpression = VisitThisExpression,
      VisitBaseExpression = VisitBaseExpression,
      VisitConditionalAccessExpression = VisitConditionalAccessExpression,
      VisitMemberBindingExpression = VisitMemberBindingExpression,
      VisitElementBindingExpression = VisitElementBindingExpression,
      VisitDefaultExpression = VisitDefaultExpression,
      VisitElementAccessExpression = VisitElementAccessExpression,
      VisitInterpolatedStringExpression = VisitInterpolatedStringExpression,
      VisitInterpolation = VisitInterpolation,
      VisitInterpolatedStringText = VisitInterpolatedStringText,
      VisitAliasQualifiedName = VisitAliasQualifiedName,
      VisitConversionOperatorDeclaration = VisitConversionOperatorDeclaration,
      VisitOperatorDeclaration = VisitOperatorDeclaration,
      VisitSizeOfExpression = VisitSizeOfExpression,
      VisitStackAllocArrayCreationExpression = VisitStackAllocArrayCreationExpression,
      VisitUnsafeStatement = VisitUnsafeStatement,
      VisitFixedStatement = VisitFixedStatement,
      VisitLockStatement = VisitLockStatement,
      VisitArrowExpressionClause = VisitArrowExpressionClause,
      VisitLocalFunctionStatement = VisitLocalFunctionStatement,
      VisitDeclarationExpression = VisitDeclarationExpression,
      VisitDiscardDesignation = VisitDiscardDesignation,
      VisitSingleVariableDesignation = VisitSingleVariableDesignation,
      VisitIsPatternExpression = VisitIsPatternExpression,
      VisitDeclarationPattern = VisitDeclarationPattern,
      VisitRefExpression = VisitRefExpression,
      VisitTupleType = VisitTupleType,
      VisitTupleExpression = VisitTupleExpression,
      VisitParenthesizedVariableDesignation = VisitParenthesizedVariableDesignation,
      VisitQueryExpression = VisitQueryExpression,
      VisitFromClause = VisitFromClause,
      VisitWhereClause = VisitWhereClause,
      VisitQueryBody = VisitQueryBody,
      VisitSelectClause = VisitSelectClause,
      VisitQueryContinuation = VisitQueryContinuation,
      VisitLetClause = VisitLetClause,
      VisitJoinClause = VisitJoinClause,
      VisitJoinIntoClause = VisitJoinIntoClause,
      __staticCtor__ = __staticCtor__,
      __ctor__ = __ctor__
    }
    return class
  end)
end)
