-- Generated by CSharp.lua Compiler
--[[
Copyright 2017 YANG Huan (sy.yanghuan@gmail.com).

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
]]
local System = System
local Linq = System.Linq.Enumerable
local MicrosoftCodeAnalysis = Microsoft.CodeAnalysis
local MicrosoftCodeAnalysisCSharp = Microsoft.CodeAnalysis.CSharp
local MicrosoftCodeAnalysisCSharpSyntax = Microsoft.CodeAnalysis.CSharp.Syntax
local SystemIO = System.IO
local SystemLinq = System.Linq
local SystemText = System.Text
local SystemThreading = System.Threading
local CSharpLua
local CSharpLuaLuaAst
System.usingDeclare(function (global)
  CSharpLua = global.CSharpLua
  CSharpLuaLuaAst = CSharpLua.LuaAst
end)
System.namespace("CSharpLua", function (namespace)
  namespace.class("PartialTypeDeclaration", function (namespace)
    local CompareTo, class
    CompareTo = function (this, other)
      local filePath = this.CompilationUnit.FilePath
      local otherFilePath = other.CompilationUnit.FilePath

      if filePath:Contains(otherFilePath) then
        return 1
      elseif otherFilePath:Contains(filePath) then
        return - 1
      else
        return other.Node:getMembers():getCount():CompareTo(this.Node:getMembers():getCount())
      end
    end
    class = {
      __inherits__ = function (global)
        return {
          System.IComparable_1(class)
        }
      end,
      CompareTo = CompareTo
    }
    return class
  end)

  namespace.class("LuaSyntaxGenerator", function (namespace)
    namespace.class("SettingInfo", function (namespace)
      local getIndent, setIndent, __ctor__
      __ctor__ = function (this)
        setIndent(this, 2)
        this.HasSemicolon = false
        this.IsNewest = true
      end
      getIndent = function (this)
        return this.indent_
      end
      setIndent = function (this, value)
        if value > 0 and this.indent_ ~= value then
          this.indent_ = value
          this.IndentString = System.String(32 --[[' ']], this.indent_)
        end
      end
      return {
        HasSemicolon = false,
        indent_ = 0,
        IsNewest = false,
        getIndent = getIndent,
        setIndent = setIndent,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("PretreatmentChecker", function (namespace)
      local GetDeclaredSymbol, VisitClassDeclaration, VisitStructDeclaration, VisitInterfaceDeclaration, VisitEnumDeclaration, Check, CheckImplicitInterfaceImplementation, IsExtendSelf, 
      CheckTypeName, RefactorTypeName, GetTypeOrNamespaceNewName, CheckTypeNameExists, CheckNamespace, RefactorNamespaceName, __init__, __ctor__
      __init__ = function (this)
        this.classTypes_ = System.HashSet(MicrosoftCodeAnalysis.INamedTypeSymbol)()
      end
      __ctor__ = function (this, generator)
        __init__(this)
        this.__base__.__ctor__(this)
        this.generator_ = generator
        for _, syntaxTree in System.each(generator.compilation_:getSyntaxTrees()) do
          this:Visit(syntaxTree:GetRoot(System.default(SystemThreading.CancellationToken)))
        end
        Check(this)
      end
      GetDeclaredSymbol = function (this, node)
        local semanticModel_ = this.generator_.compilation_:GetSemanticModel(node:getSyntaxTree(), false)
        return MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetDeclaredSymbol(semanticModel_, node, System.default(SystemThreading.CancellationToken))
      end
      VisitClassDeclaration = function (this, node)
        local typeSymbol = GetDeclaredSymbol(this, node)
        this.classTypes_:Add(typeSymbol)

        local types = SystemLinq.Enumerable.OfType(node:getMembers(), MicrosoftCodeAnalysisCSharpSyntax.BaseTypeDeclarationSyntax)
        for _, type in System.each(types) do
          type:Accept(this)
        end
      end
      VisitStructDeclaration = function (this, node)
        local typeSymbol = GetDeclaredSymbol(this, node)
        this.classTypes_:Add(typeSymbol)
      end
      VisitInterfaceDeclaration = function (this, node)
        local typeSymbol = GetDeclaredSymbol(this, node)
        this.classTypes_:Add(typeSymbol)
      end
      VisitEnumDeclaration = function (this, node)
        local typeSymbol = GetDeclaredSymbol(this, node)
        this.classTypes_:Add(typeSymbol)
      end
      Check = function (this)
        for _, type in System.each(this.classTypes_) do
          this.generator_:AddTypeSymbol(type)
          CheckImplicitInterfaceImplementation(this, type)
          CheckTypeName(this, type)
        end
        CheckNamespace(this)
      end
      CheckImplicitInterfaceImplementation = function (this, type)
        if type:getTypeKind() == 2 --[[TypeKind.Class]] and not type:getIsStatic() then
          for _, baseInterface in System.each(type:getAllInterfaces()) do
            local continue
            repeat
              for _, interfaceMember in System.each(baseInterface:GetMembers()) do
                local continue
                repeat
                  local implementationMember = type:FindImplementationForInterfaceMember(interfaceMember)
                  if implementationMember:getKind() == 9 --[[SymbolKind.Method]] then
                    local methodSymbol = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, implementationMember)
                    if methodSymbol:getMethodKind() ~= 10 --[[MethodKind.Ordinary]] then
                      continue = true
                      break
                    end
                  end

                  local implementationType = implementationMember:getContainingType()
                  if implementationType ~= type then
                    if not implementationType:getAllInterfaces():Contains(baseInterface) then
                      this.generator_:AddImplicitInterfaceImplementation(implementationMember, interfaceMember)
                      this.generator_:TryAddExtend(baseInterface, implementationType)
                    end
                  end
                  continue = true
                until 1
                if not continue then
                  break
                end
              end
              continue = true
            until 1
            if not continue then
              break
            end
          end

          if IsExtendSelf(this, type) then
            this.generator_.typesOfExtendSelf_:Add(type)
          end
        end
      end
      IsExtendSelf = function (this, typeSymbol)
        if typeSymbol:getBaseType() ~= nil then
          if CSharpLua.Utility.IsExtendSelf(typeSymbol, typeSymbol:getBaseType()) then
            return true
          end
        end

        for _, baseType in System.each(typeSymbol:getInterfaces()) do
          if CSharpLua.Utility.IsExtendSelf(typeSymbol, baseType) then
            return true
          end
        end

        return false
      end
      CheckTypeName = function (this, type)
        local name = type:getName()
        if type:getTypeParameters():getIsEmpty() then
          if CSharpLuaLuaAst.LuaSyntaxNode.IsReservedWord(name) then
            RefactorTypeName(this, type, type:getName(), 1)
            return
          end
        end

        local default
        default, name = CSharpLua.Utility.IsIdentifierIllegal(name)
        if default then
          RefactorTypeName(this, type, name, 0)
        end
      end
      RefactorTypeName = function (this, type, name, index)
        local newName = GetTypeOrNamespaceNewName(this, this.classTypes_, type, name, index)
        this.generator_.typeRefactorNames_:Add(type, newName)
      end
      GetTypeOrNamespaceNewName = function (this, allSymbols, symbol, name, index)
        while true do
          local newName = CSharpLua.Utility.GetNewIdentifierName(name, index)
          if not CheckTypeNameExists(allSymbols, symbol, newName) then
            return newName
          end
        end
      end
      CheckTypeNameExists = function (all, type, newName)
        return Linq.Any(Linq.Where(all, function (i)
          return i:getContainingNamespace() == type:getContainingNamespace()
        end), function (i)
          return i:getName() == newName
        end)
      end
      CheckNamespace = function (this)
        local all = Linq.ToArray(Linq.Distinct(Linq.SelectMany(this.classTypes_, function (i)
          return CSharpLua.Utility.GetAllNamespaces(i:getContainingNamespace())
        end, MicrosoftCodeAnalysis.INamespaceSymbol)))
        for _, symbol in System.each(all) do
          local name = symbol:getName()
          if CSharpLuaLuaAst.LuaSyntaxNode.IsReservedWord(name) then
            RefactorNamespaceName(this, all, symbol, symbol:getName(), 1)
          else
            local default
            default, name = CSharpLua.Utility.IsIdentifierIllegal(name)
            if default then
              RefactorNamespaceName(this, all, symbol, name, 0)
            end
          end
        end
      end
      RefactorNamespaceName = function (this, all, symbol, name, index)
        local newName = GetTypeOrNamespaceNewName(this, all, symbol, name, index)
        this.generator_.namespaceRefactorNames_:Add(symbol, newName)
      end
      return {
        __inherits__ = function (global)
          return {
            Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker
          }
        end,
        VisitClassDeclaration = VisitClassDeclaration,
        VisitStructDeclaration = VisitStructDeclaration,
        VisitInterfaceDeclaration = VisitInterfaceDeclaration,
        VisitEnumDeclaration = VisitEnumDeclaration,
        __ctor__ = __ctor__
      }
    end)
    local Encoding, Create, Write, Generate, RemoveBaseFolder, GetOutFilePath, getIsCheckedOverflow, IsEnumExport, 
    AddExportEnum, AddEnumDeclaration, AddIgnoreExportType, IsExportAttribute, CheckExportEnums, AddPartialTypeDeclaration, CheckPartialTypes, GetSemanticModel, 
    IsBaseType, IsTypeEnableExport, AddSuperTypeTo, GetExportTypes, SetMainEntryPoint, ExportManifestFile, FillManifestInitConf, AddTypeSymbol, 
    CheckExtends, TryAddExtend, AddTypeDeclarationAttribute, GetMemberName, CheckMemberBadName, InternalGetMemberName, GetAllTypeSameName, AddInnerName, 
    GetSymbolBaseName, GetStaticClassMemberName, GetMethodNameFromIndex, TryAddNewUsedName, GetStaticClassSameNameMembers, GetSameNameMembers, AddSimilarNameMembers, GetSymbolNames, 
    MemberSymbolBoolComparison, MemberSymbolComparison, MemberSymbolCommonComparison, CheckRefactorNames, RefactorCurTypeSymbol, RefactorInterfaceSymbol, RefactorName, RefactorChildrensOverridden, 
    UpdateName, GetRefactorCheckName, GetRefactorName, IsTypeNameUsed, IsNewNameEnable, IsNewNameEnable1, IsCurTypeNameEnable, IsNameEnableOfCurAndChildrens, 
    CheckRefactorInnerNames, GetInnerGetRefactorName, IsInnerNameEnable, IsInnerNameEnableOfChildrens, IsMonoBehaviourSpeicalMethod, DoPretreatment, AddImplicitInterfaceImplementation, FindImplicitImplementationForInterfaceMember, 
    IsImplicitInterfaceImplementation, IsPropertyField, IsEventFiled, IsPropertyFieldOrEventFiled, AllInterfaceImplementations, AllInterfaceImplementationsCount, HasStaticCtor, IsExtendExists, 
    IsSealed, GetTypeRefactorName, GetTypeDeclarationName, GetTypeName, GetTypeArguments, FillExternalTypeArgument, FillTypeArguments, GetNamespaceMapName, 
    GetTypeShortName, class, __staticCtor__, __init__, __ctor__
    __staticCtor__ = function (this)
      Encoding = SystemText.UTF8Encoding(false)
    end
    __init__ = function (this)
      this.exportEnums_ = System.HashSet(System.String)()
      this.ignoreExportTypes_ = System.HashSet(MicrosoftCodeAnalysis.INamedTypeSymbol)()
      this.enumDeclarations_ = System.List(CSharpLuaLuaAst.LuaEnumDeclarationSyntax)()
      this.partialTypes_ = System.Dictionary(MicrosoftCodeAnalysis.INamedTypeSymbol, System.List(CSharpLua.PartialTypeDeclaration))()
      this.memberNames_ = System.Dictionary(MicrosoftCodeAnalysis.ISymbol, CSharpLuaLuaAst.LuaSymbolNameSyntax)()
      this.typeNameUseds_ = System.Dictionary(MicrosoftCodeAnalysis.INamedTypeSymbol, System.HashSet(System.String))()
      this.refactorNames_ = System.HashSet(MicrosoftCodeAnalysis.ISymbol)()
      this.extends_ = System.Dictionary(MicrosoftCodeAnalysis.INamedTypeSymbol, System.HashSet(MicrosoftCodeAnalysis.INamedTypeSymbol))()
      this.types_ = System.List(MicrosoftCodeAnalysis.INamedTypeSymbol)()
      this.typeDeclarationAttributes_ = System.Dictionary(MicrosoftCodeAnalysis.INamedTypeSymbol, System.HashSet(MicrosoftCodeAnalysis.INamedTypeSymbol))()
      this.propertyOrEvnetInnerFieldNames_ = System.Dictionary(MicrosoftCodeAnalysis.ISymbol, CSharpLuaLuaAst.LuaSymbolNameSyntax)()
      this.memberIllegalNames_ = System.Dictionary(MicrosoftCodeAnalysis.ISymbol, System.String)()
      this.implicitInterfaceImplementations_ = System.Dictionary(MicrosoftCodeAnalysis.ISymbol, System.HashSet(MicrosoftCodeAnalysis.ISymbol))()
      this.implicitInterfaceTypes_ = System.Dictionary(MicrosoftCodeAnalysis.INamedTypeSymbol, System.Dictionary(MicrosoftCodeAnalysis.ISymbol, MicrosoftCodeAnalysis.ISymbol))()
      this.isFieldPropertys_ = System.Dictionary(MicrosoftCodeAnalysis.IPropertySymbol, System.Boolean)()
      this.typesOfExtendSelf_ = System.HashSet(MicrosoftCodeAnalysis.INamedTypeSymbol)()
      this.namespaceRefactorNames_ = System.Dictionary(MicrosoftCodeAnalysis.INamespaceSymbol, System.String)()
      this.typeRefactorNames_ = System.Dictionary(MicrosoftCodeAnalysis.INamedTypeSymbol, System.String)()
    end
    __ctor__ = function (this, syntaxTrees, references, options, metas, setting, attributes, baseFolder)
      __init__(this)
      local compilation = MicrosoftCodeAnalysisCSharp.CSharpCompilation.Create("_", syntaxTrees, references, options:WithOutputKind(2 --[[OutputKind.DynamicallyLinkedLibrary]]))
      System.using(SystemIO.MemoryStream(), function (ms)
        local result = compilation:Emit(ms, nil, nil, nil, nil, nil, nil, nil, nil, nil, System.default(SystemThreading.CancellationToken))
        if not result:getSuccess() then
          local errors = SystemLinq.ImmutableArrayExtensions.Where(result:getDiagnostics(), function (i)
            return i:getSeverity() == 3 --[[DiagnosticSeverity.Error]]
          end, MicrosoftCodeAnalysis.Diagnostic)
          local message = System.String.Join("\n", errors, MicrosoftCodeAnalysis.Diagnostic)
          System.throw(CSharpLua.CompilationErrorException:new(1, message))
        end
      end)
      this.compilation_ = compilation
      this.BaseFolder = baseFolder
      this.XmlMetaProvider = CSharpLua.XmlMetaProvider(metas)
      this.Setting = setting
      if attributes ~= nil then
        if #attributes == 0 then
          this.isExportAttributesAll_ = true
        else
          this.exportAttributes_ = System.HashSet(System.String)(attributes)
        end
      end
      if Linq.Any(compilation:getReferencedAssemblyNames(), function (i)
        return i:getName():Contains("UnityEngine")
      end) then
        this.monoBehaviourTypeSymbol_ = compilation:GetTypeByMetadataName("UnityEngine.MonoBehaviour")
        if this.monoBehaviourTypeSymbol_ ~= nil then
          this.monoBehaviourSpeicalMethodNames_ = System.create(System.HashSet(System.String)(), function (default)
            default:Add("Awake")
            default:Add("Start")
            default:Add("Update")
            default:Add("FixedUpdate")
            default:Add("LateUpdate")
          end)
        end
      end
      DoPretreatment(this)
    end
    Create = function (this)
      local luaCompilationUnits = System.List(CSharpLuaLuaAst.LuaCompilationUnitSyntax)()
      for _, syntaxTree in System.each(this.compilation_:getSyntaxTrees()) do
        local semanticModel = GetSemanticModel(this, syntaxTree)
        local compilationUnitSyntax = System.cast(MicrosoftCodeAnalysisCSharpSyntax.CompilationUnitSyntax, syntaxTree:GetRoot(System.default(SystemThreading.CancellationToken)))
        local transfor = CSharpLua.LuaSyntaxNodeTransform(this, semanticModel)
        local luaCompilationUnit = System.cast(CSharpLuaLuaAst.LuaCompilationUnitSyntax, compilationUnitSyntax:Accept(transfor, CSharpLuaLuaAst.LuaSyntaxNode))
        luaCompilationUnits:Add(luaCompilationUnit)
      end
      CheckExportEnums(this)
      CheckPartialTypes(this)
      CheckRefactorNames(this)
      return Linq.Where(luaCompilationUnits, function (i)
        return not i:getIsEmpty()
      end)
    end
    Write = function (this, luaCompilationUnit, outFile)
      System.using(SystemIO.StreamWriter(outFile, false, Encoding), function (writer)
        local rener = CSharpLua.LuaRenderer(this, writer)
        luaCompilationUnit:Render(rener)
      end)
    end
    Generate = function (this, outFolder)
      local modules = System.List(System.String)()
      for _, luaCompilationUnit in System.each(Create(this)) do
        local module
        local default
        default, module = GetOutFilePath(this, luaCompilationUnit.FilePath, outFolder)
        local outFile = default
        Write(this, luaCompilationUnit, outFile)
        modules:Add(module)
      end
      ExportManifestFile(this, modules, outFolder)
    end
    RemoveBaseFolder = function (this, patrh)
      return patrh:Remove(0, #this.BaseFolder):TrimStart(SystemIO.Path.DirectorySeparatorChar, 47 --[['/']])
    end
    GetOutFilePath = function (this, inFilePath, output_, module)
      local path = RemoveBaseFolder(this, inFilePath)
      local extend = SystemIO.Path.GetExtension(path)
      path = path:Remove(#path - #extend, #extend)
      path = path:Replace(46 --[['.']], 95 --[['_']])
      local outPath = SystemIO.Path.Combine(output_, path .. ".lua" --[[LuaSyntaxGenerator.kLuaSuffix]])
      local dir = SystemIO.Path.GetDirectoryName(outPath)
      if not SystemIO.Directory.Exists(dir) then
        SystemIO.Directory.CreateDirectory(dir)
      end
      module = path:Replace(SystemIO.Path.DirectorySeparatorChar, 46 --[['.']])
      return outPath, module
    end
    getIsCheckedOverflow = function (this)
      return this.compilation_:getOptions():getCheckOverflow()
    end
    IsEnumExport = function (this, enumTypeSymbol)
      return this.exportEnums_:Contains(enumTypeSymbol)
    end
    AddExportEnum = function (this, enumTypeSymbol)
      this.exportEnums_:Add(enumTypeSymbol)
    end
    AddEnumDeclaration = function (this, enumDeclaration)
      this.enumDeclarations_:Add(enumDeclaration)
    end
    AddIgnoreExportType = function (this, type)
      this.ignoreExportTypes_:Add(type)
    end
    IsExportAttribute = function (this, attributeTypeSymbol)
      if this.isExportAttributesAll_ then
        return true
      else
        if this.exportAttributes_ ~= nil and this.exportAttributes_:getCount() > 0 then
          if this.exportAttributes_:Contains(attributeTypeSymbol:ToString()) then
            return true
          end
        end
        if this.XmlMetaProvider:IsExportAttribute(attributeTypeSymbol) then
          return true
        end
      end
      return false
    end
    CheckExportEnums = function (this)
      for _, enumDeclaration in System.each(this.enumDeclarations_) do
        if IsEnumExport(this, enumDeclaration.FullName) then
          enumDeclaration.IsExport = true
          enumDeclaration.CompilationUnit:AddTypeDeclarationCount()
        end
      end
    end
    AddPartialTypeDeclaration = function (this, typeSymbol, node, luaNode, compilationUnit)
      local list = CSharpLua.Utility.GetOrDefault1(this.partialTypes_, typeSymbol, nil, MicrosoftCodeAnalysis.INamedTypeSymbol, System.List(CSharpLua.PartialTypeDeclaration))
      if list == nil then
        list = System.List(CSharpLua.PartialTypeDeclaration)()
        this.partialTypes_:Add(typeSymbol, list)
      end
      list:Add(System.create(CSharpLua.PartialTypeDeclaration(), function (default)
        default.Symbol = typeSymbol
        default.Node = node
        default.TypeDeclaration = luaNode
        default.CompilationUnit = compilationUnit
      end))
    end
    CheckPartialTypes = function (this)
      while this.partialTypes_:getCount() > 0 do
        local types = Linq.ToArray(this.partialTypes_:getValues())
        this.partialTypes_:Clear()
        for _, typeDeclarations in System.each(types) do
          local major = Linq.Min(typeDeclarations)
          local transfor = CSharpLua.LuaSyntaxNodeTransform(this)
          transfor:AcceptPartialType(major, typeDeclarations)
        end
      end
    end
    GetSemanticModel = function (this, syntaxTree)
      return this.compilation_:GetSemanticModel(syntaxTree, false)
    end
    IsBaseType = function (this, type)
      local syntaxTree = type:getSyntaxTree()
      local semanticModel = GetSemanticModel(this, syntaxTree)
      local symbol = MicrosoftCodeAnalysisCSharp.CSharpExtensions.GetTypeInfo(semanticModel, type:getType(), System.default(SystemThreading.CancellationToken)):getType()
      assert(symbol ~= nil)
      return symbol:getTypeKind() ~= 7 --[[TypeKind.Interface]]
    end
    IsTypeEnableExport = function (this, type)
      local isExport = true
      if type:getTypeKind() == 5 --[[TypeKind.Enum]] then
        isExport = IsEnumExport(this, type:ToString())
      end
      if this.ignoreExportTypes_:Contains(type) then
        isExport = false
      end
      return isExport
    end
    AddSuperTypeTo = function (this, parentTypes, rootType, superType)
      if CSharpLua.Utility.IsFromCode(superType) then
        if superType:getIsGenericType() then
          parentTypes:Add(superType:getOriginalDefinition())
          for _, typeArgument in System.each(superType:getTypeArguments()) do
            if typeArgument:getKind() ~= 17 --[[SymbolKind.TypeParameter]] then
              if not CSharpLua.Utility.IsAssignableFrom(rootType, typeArgument) then
                local typeArgumentType = System.cast(MicrosoftCodeAnalysis.INamedTypeSymbol, typeArgument)
                AddSuperTypeTo(this, parentTypes, rootType, typeArgumentType)
              end
            end
          end
        else
          parentTypes:Add(superType)
        end
      end
    end
    GetExportTypes = function (this)
      local allTypes = System.List(MicrosoftCodeAnalysis.INamedTypeSymbol)()
      if #this.types_ > 0 then
        this.types_:Sort(function (x, y)
          return x:ToString():CompareTo(y:ToString())
        end)

        local typesList = System.create(System.List(System.List(MicrosoftCodeAnalysis.INamedTypeSymbol))(), function (default)
          default:Add(this.types_)
        end)
        while true do
          local parentTypes = System.HashSet(MicrosoftCodeAnalysis.INamedTypeSymbol)()
          local lastTypes = CSharpLua.Utility.Last(typesList, System.List(MicrosoftCodeAnalysis.INamedTypeSymbol))
          for _, type in System.each(lastTypes) do
            if type:getBaseType() ~= nil then
              AddSuperTypeTo(this, parentTypes, type, type:getBaseType())
            end

            for _, interfaceType in System.each(type:getInterfaces()) do
              AddSuperTypeTo(this, parentTypes, type, interfaceType)
            end

            local attributes = CSharpLua.Utility.GetOrDefault1(this.typeDeclarationAttributes_, type, nil, MicrosoftCodeAnalysis.INamedTypeSymbol, System.HashSet(MicrosoftCodeAnalysis.INamedTypeSymbol))
            if attributes ~= nil then
              for _, attribute in System.each(attributes) do
                AddSuperTypeTo(this, parentTypes, type, attribute)
              end
            end
          end

          if parentTypes:getCount() == 0 then
            break
          end

          typesList:Add(Linq.ToList(parentTypes))
        end

        typesList:Reverse()
        local types = Linq.Where(Linq.Distinct(Linq.SelectMany(typesList, function (i)
          return i
        end, MicrosoftCodeAnalysis.INamedTypeSymbol)), System.bind(this, IsTypeEnableExport))
        allTypes:AddRange(types)
      end
      return allTypes
    end
    SetMainEntryPoint = function (this, sybmol)
      if this.mainEntryPoint_ == nil then
        this.mainEntryPoint_ = sybmol
        return true
      end
      return false
    end
    ExportManifestFile = function (this, modules, outFolder)
      local kDirInitCode = "dir = (dir and #dir > 0) and (dir .. '.') or \"\""
      local kLoadCode = "local load = function(module) return require(dir .. module) end"

      if #modules > 0 then
        modules:Sort()
        local types = GetExportTypes(this)
        if #types > 0 then
          local functionExpression = CSharpLuaLuaAst.LuaFunctionExpressionSyntax()
          functionExpression:AddParameter1(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, "dir" --[[kDir]]))
          functionExpression:AddStatement1(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, kDirInitCode))

          local requireIdentifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, "require" --[[kRequire]])
          functionExpression:AddStatement(CSharpLuaLuaAst.LuaLocalVariableDeclaratorSyntax:new(2, requireIdentifier, requireIdentifier))

          functionExpression:AddStatement1(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, kLoadCode))
          functionExpression:AddStatement(CSharpLuaLuaAst.LuaBlankLinesStatement.One)

          local loadIdentifier = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, "load" --[[kLoad]])
          for _, module in System.each(modules) do
            local argument = CSharpLuaLuaAst.LuaStringLiteralExpressionSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, module))
            local invocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, loadIdentifier, argument)
            functionExpression:AddStatement1(invocation)
          end
          functionExpression:AddStatement(CSharpLuaLuaAst.LuaBlankLinesStatement.One)

          local typeTable = CSharpLuaLuaAst.LuaTableInitializerExpression()
          for _, type in System.each(types) do
            local typeName = GetTypeShortName(this, type)
            typeTable.Items:Add(CSharpLuaLuaAst.LuaSingleTableItemSyntax(CSharpLuaLuaAst.LuaStringLiteralExpressionSyntax(typeName)))
          end

          local initInvocation = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, "System.init" --[[kInit]]), typeTable)
          FillManifestInitConf(this, initInvocation)
          functionExpression:AddStatement1(initInvocation)

          local luaCompilationUnit = CSharpLuaLuaAst.LuaCompilationUnitSyntax("")
          luaCompilationUnit:AddStatement(CSharpLuaLuaAst.LuaReturnStatementSyntax(functionExpression))

          local outFile = SystemIO.Path.Combine(outFolder, "manifest.lua" --[[kManifestFile]])
          Write(this, luaCompilationUnit, outFile)
        end
      end
    end
    FillManifestInitConf = function (this, invocation)
      local confTable = CSharpLuaLuaAst.LuaTableInitializerExpression()
      if this.mainEntryPoint_ ~= nil then
        local methodName = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, this.mainEntryPoint_:getName())
        local methodTypeName = GetTypeName(this, this.mainEntryPoint_:getContainingType())
        local quote = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, "\"" --[[Tokens.Quote]])

        local codeTemplate = CSharpLuaLuaAst.LuaCodeTemplateExpressionSyntax()
        codeTemplate.Expressions:Add(quote)
        codeTemplate.Expressions:Add(CSharpLuaLuaAst.LuaMemberAccessExpressionSyntax(methodTypeName, methodName, false))
        codeTemplate.Expressions:Add(quote)

        confTable.Items:Add(CSharpLuaLuaAst.LuaKeyValueTableItemSyntax(CSharpLuaLuaAst.LuaTableLiteralKeySyntax(methodName), codeTemplate))
      end
      if #confTable.Items > 0 then
        invocation:AddArgument(confTable)
      end
    end
    AddTypeSymbol = function (this, typeSymbol)
      this.types_:Add(typeSymbol)
      CheckExtends(this, typeSymbol)
    end
    CheckExtends = function (this, typeSymbol)
      if typeSymbol:getSpecialType() ~= 1 --[[SpecialType.System_Object]] then
        if typeSymbol:getBaseType() ~= nil then
          local super = typeSymbol:getBaseType()
          TryAddExtend(this, super, typeSymbol)
        end
      end

      for _, super in System.each(typeSymbol:getAllInterfaces()) do
        TryAddExtend(this, super, typeSymbol)
      end
    end
    TryAddExtend = function (this, super, children)
      if CSharpLua.Utility.IsFromCode(super) then
        if super:getIsGenericType() then
          super = super:getOriginalDefinition()
        end
        CSharpLua.Utility.TryAdd(this.extends_, super, children, MicrosoftCodeAnalysis.INamedTypeSymbol, MicrosoftCodeAnalysis.INamedTypeSymbol)
      end
    end
    AddTypeDeclarationAttribute = function (this, typeDeclarationSymbol, attributeSymbol)
      CSharpLua.Utility.TryAdd(this.typeDeclarationAttributes_, typeDeclarationSymbol, attributeSymbol, MicrosoftCodeAnalysis.INamedTypeSymbol, MicrosoftCodeAnalysis.INamedTypeSymbol)
    end
    GetMemberName = function (this, symbol)
      symbol = CSharpLua.Utility.CheckOriginalDefinition(symbol)
      local name = CSharpLua.Utility.GetOrDefault1(this.memberNames_, symbol, nil, MicrosoftCodeAnalysis.ISymbol, CSharpLuaLuaAst.LuaSymbolNameSyntax)
      if name == nil then
        local identifierName = InternalGetMemberName(this, symbol)
        local symbolName = CSharpLuaLuaAst.LuaSymbolNameSyntax(identifierName)
        this.memberNames_:Add(symbol, symbolName)
        name = symbolName
        CheckMemberBadName(this, identifierName.ValueText, symbol)
      end
      return name
    end
    CheckMemberBadName = function (this, originalString, symbol)
      if CSharpLua.Utility.IsFromCode(symbol) then
        local isCheckNeedReserved = false
        local isCheckIllegalIdentifier = true
        repeat
          local default = symbol:getKind()
          if default == 6 --[[SymbolKind.Field]] or default == 9 --[[SymbolKind.Method]] then
            isCheckNeedReserved = true
            break
          elseif default == 15 --[[SymbolKind.Property]] then
            local propertySymbol = System.cast(MicrosoftCodeAnalysis.IPropertySymbol, symbol)
            if propertySymbol:getIsIndexer() then
              isCheckIllegalIdentifier = false
            else
              isCheckNeedReserved = true
            end
            break
          elseif default == 5 --[[SymbolKind.Event]] then
            if IsEventFiled(this, System.cast(MicrosoftCodeAnalysis.IEventSymbol, symbol)) then
              isCheckNeedReserved = true
            end
            break
          end
        until 1

        if isCheckNeedReserved then
          if CSharpLuaLuaAst.LuaSyntaxNode.IsMethodReservedWord(originalString) then
            this.refactorNames_:Add(symbol)
            isCheckIllegalIdentifier = false
          end
        end

        if isCheckIllegalIdentifier then
          local extern
          extern, originalString = CSharpLua.Utility.IsIdentifierIllegal(originalString)
          if extern then
            this.refactorNames_:Add(symbol)
            this.memberIllegalNames_:Add(symbol, originalString)
          end
        end
      end
    end
    InternalGetMemberName = function (this, symbol)
      if symbol:getKind() == 9 --[[SymbolKind.Method]] then
        local name = this.XmlMetaProvider:GetMethodMapName(System.cast(MicrosoftCodeAnalysis.IMethodSymbol, symbol))
        if name ~= nil then
          return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name)
        end
      end

      if not CSharpLua.Utility.IsFromCode(symbol) or symbol:getContainingType():getTypeKind() == 7 --[[TypeKind.Interface]] then
        return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, GetSymbolBaseName(this, symbol))
      end

      if symbol:getIsStatic() then
        if symbol:getContainingType():getIsStatic() then
          return GetStaticClassMemberName(this, symbol)
        end
      end

      while symbol:getIsOverride() do
        local overriddenSymbol = CSharpLua.Utility.OverriddenSymbol(symbol)
        if not CSharpLua.Utility.IsFromCode(overriddenSymbol) then
          break
        end
        symbol = overriddenSymbol
      end

      return GetAllTypeSameName(this, symbol)
    end
    GetAllTypeSameName = function (this, symbol)
      local sameNameMembers = GetSameNameMembers(this, symbol)
      local symbolExpression = nil
      local index = 0
      for _, member in System.each(sameNameMembers) do
        if member:Equals(symbol) then
          symbolExpression = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, GetSymbolBaseName(this, symbol))
        else
          if not this.memberNames_:ContainsKey(member) then
            local identifierName = CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, GetSymbolBaseName(this, member))
            this.memberNames_:Add(member, CSharpLuaLuaAst.LuaSymbolNameSyntax(identifierName))
          end
        end
        if index > 0 then
          assert(CSharpLua.Utility.IsFromCode(member))
          local refactorSymbol = member
          refactorSymbol = CSharpLua.Utility.CheckOriginalDefinition(refactorSymbol)
          this.refactorNames_:Add(refactorSymbol)
        end
        index = index + 1
      end
      if symbolExpression == nil then
        System.throw(CSharpLua.InvalidOperationException())
      end
      return symbolExpression
    end
    AddInnerName = function (this, symbol)
      local name = GetSymbolBaseName(this, symbol)
      local symbolName = CSharpLuaLuaAst.LuaSymbolNameSyntax(CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name))
      this.propertyOrEvnetInnerFieldNames_:Add(symbol, symbolName)
      return symbolName
    end
    GetSymbolBaseName = function (this, symbol)
      repeat
        local default = symbol:getKind()
        if default == 9 --[[SymbolKind.Method]] then
          do
            local method = System.cast(MicrosoftCodeAnalysis.IMethodSymbol, symbol)
            local name = this.XmlMetaProvider:GetMethodMapName(method)
            if name ~= nil then
              return name
            end
            local implementation = SystemLinq.ImmutableArrayExtensions.FirstOrDefault(method:getExplicitInterfaceImplementations(), MicrosoftCodeAnalysis.IMethodSymbol)
            if implementation ~= nil then
              return implementation:getName()
            end
            break
          end
        elseif default == 15 --[[SymbolKind.Property]] then
          do
            local property = System.cast(MicrosoftCodeAnalysis.IPropertySymbol, symbol)
            if property:getIsIndexer() then
              return ""
            else
              local implementation = SystemLinq.ImmutableArrayExtensions.FirstOrDefault(property:getExplicitInterfaceImplementations(), MicrosoftCodeAnalysis.IPropertySymbol)
              if implementation ~= nil then
                return implementation:getName()
              end
            end
            break
          end
        elseif default == 5 --[[SymbolKind.Event]] then
          do
            local eventSymbol = System.cast(MicrosoftCodeAnalysis.IEventSymbol, symbol)
            local implementation = SystemLinq.ImmutableArrayExtensions.FirstOrDefault(eventSymbol:getExplicitInterfaceImplementations(), MicrosoftCodeAnalysis.IEventSymbol)
            if implementation ~= nil then
              return implementation:getName()
            end
            break
          end
        end
      until 1
      return symbol:getName()
    end
    GetStaticClassMemberName = function (this, symbol)
      local sameNameMembers = GetStaticClassSameNameMembers(this, symbol)
      local symbolExpression = nil

      local index = 0
      for _, member in System.each(sameNameMembers) do
        local identifierName = GetMethodNameFromIndex(this, symbol, index)
        if member:Equals(symbol) then
          symbolExpression = identifierName
        else
          if not this.memberNames_:ContainsKey(member) then
            this.memberNames_:Add(member, CSharpLuaLuaAst.LuaSymbolNameSyntax(identifierName))
          end
        end
        index = index + 1
      end

      if symbolExpression == nil then
        System.throw(CSharpLua.InvalidOperationException())
      end
      return symbolExpression
    end
    GetMethodNameFromIndex = function (this, symbol, index)
      assert(index ~= - 1)
      if index == 0 then
        return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, symbol:getName())
      else
        while true do
          local newName = symbol:getName() .. index
          if IsCurTypeNameEnable(this, symbol:getContainingType(), newName) then
            TryAddNewUsedName(this, symbol:getContainingType(), newName)
            return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, newName)
          end
          index = index + 1
        end
      end
    end
    TryAddNewUsedName = function (this, type, newName)
      return CSharpLua.Utility.TryAdd(this.typeNameUseds_, type, newName, MicrosoftCodeAnalysis.INamedTypeSymbol, System.String)
    end
    GetStaticClassSameNameMembers = function (this, symbol)
      local members = System.List(MicrosoftCodeAnalysis.ISymbol)()
      local names = GetSymbolNames(this, symbol)
      AddSimilarNameMembers(this, symbol:getContainingType(), names, members, false)
      return members
    end
    GetSameNameMembers = function (this, symbol)
      local members = System.List(MicrosoftCodeAnalysis.ISymbol)()
      local names = GetSymbolNames(this, symbol)
      local rootType = symbol:getContainingType()
      local curTypeSymbol = rootType
      while true do
        AddSimilarNameMembers(this, curTypeSymbol, names, members, rootType ~= curTypeSymbol)
        local baseTypeSymbol = curTypeSymbol:getBaseType()
        if baseTypeSymbol ~= nil and CSharpLua.Utility.IsFromCode(baseTypeSymbol) then
          curTypeSymbol = baseTypeSymbol
        else
          break
        end
      end
      members:Sort(System.bind(this, MemberSymbolComparison))
      return members
    end
    AddSimilarNameMembers = function (this, typeSymbol, names, outList, isWithoutPrivate)
      assert(CSharpLua.Utility.IsFromCode(typeSymbol))
      for _, member in System.each(typeSymbol:GetMembers()) do
        local continue
        repeat
          if member:getIsOverride() then
            local overriddenSymbol = CSharpLua.Utility.OverriddenSymbol(member)
            if CSharpLua.Utility.IsFromCode(overriddenSymbol) then
              continue = true
              break
            end
          end

          if not isWithoutPrivate or not CSharpLua.Utility.IsPrivate(member) then
            local memberNames = GetSymbolNames(this, member)
            if memberNames:Exists(function (i)
              return names:Contains(i)
            end) then
              outList:Add(member)
            end
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    GetSymbolNames = function (this, symbol)
      local names = System.List(System.String)()
      if symbol:getKind() == 15 --[[SymbolKind.Property]] then
        local propertySymbol = System.cast(MicrosoftCodeAnalysis.IPropertySymbol, symbol)
        if IsPropertyField(this, propertySymbol) then
          names:Add(symbol:getName())
        else
          local baseName = GetSymbolBaseName(this, symbol)
          if propertySymbol:getIsReadOnly() then
            names:Add("get" --[[Tokens.Get]] .. baseName)
          elseif propertySymbol:getIsWriteOnly() then
            names:Add("set" --[[Tokens.Set]] .. baseName)
          else
            names:Add("get" --[[Tokens.Get]] .. baseName)
            names:Add("set" --[[Tokens.Set]] .. baseName)
          end
        end
      elseif symbol:getKind() == 5 --[[SymbolKind.Event]] then
        local eventSymbol = System.cast(MicrosoftCodeAnalysis.IEventSymbol, symbol)
        if IsEventFiled(this, eventSymbol) then
          names:Add(symbol:getName())
        else
          local baseName = GetSymbolBaseName(this, symbol)
          names:Add("add" --[[Tokens.Add]] .. baseName)
          names:Add("remove" --[[Tokens.Remove]] .. baseName)
        end
      else
        names:Add(GetSymbolBaseName(this, symbol))
      end
      return names
    end
    MemberSymbolBoolComparison = function (this, a, b, boolFunc, v)
      local boolOfA = boolFunc(a)
      local boolOfB = boolFunc(b)

      if boolOfA then
        if boolOfB then
          v = MemberSymbolCommonComparison(this, a, b)
        else
          v = - 1
        end
        return true, v
      end

      if b:getIsAbstract() then
        v = 1
        return true, v
      end

      v = 0
      return false, v
    end
    MemberSymbolComparison = function (this, a, b)
      local isFromCodeOfA = CSharpLua.Utility.IsFromCode(a:getContainingType())
      local isFromCodeOfB = CSharpLua.Utility.IsFromCode(b:getContainingType())

      if not isFromCodeOfA then
        if not isFromCodeOfB then
          return 0
        else
          return - 1
        end
      end

      if not isFromCodeOfB then
        return 1
      end

      local countOfA = AllInterfaceImplementationsCount(this, a)
      local countOfB = AllInterfaceImplementationsCount(this, b)
      if countOfA > 0 or countOfB > 0 then
        if countOfA ~= countOfB then
          return countOfA > countOfB and - 1 or 1
        end

        if countOfA == 1 then
          local implementationOfA = Linq.First(CSharpLua.Utility.InterfaceImplementations(a, MicrosoftCodeAnalysis.ISymbol))
          local implementationOfB = Linq.First(CSharpLua.Utility.InterfaceImplementations(b, MicrosoftCodeAnalysis.ISymbol))
          local result
          local default
          default, result = MemberSymbolBoolComparison(this, implementationOfA, implementationOfB, function (i)
            return not CSharpLua.Utility.IsExplicitInterfaceImplementation(i)
          end)
          if default then
            return result
          end
        end

        return MemberSymbolCommonComparison(this, a, b)
      end

      local v
      local extern
      extern, v = MemberSymbolBoolComparison(this, a, b, function (i)
        return i:getIsAbstract()
      end)
      if extern then
        return v
      end
      local ref
      ref, v = MemberSymbolBoolComparison(this, a, b, function (i)
        return i:getIsVirtual()
      end)
      if ref then
        return v
      end
      local out
      out, v = MemberSymbolBoolComparison(this, a, b, function (i)
        return i:getIsOverride()
      end)
      if out then
        return v
      end

      return MemberSymbolCommonComparison(this, a, b)
    end
    MemberSymbolCommonComparison = function (this, a, b)
      if a:getContainingType():Equals(b:getContainingType()) then
        local type = a:getContainingType()
        local names = GetSymbolNames(this, a)
        local members = System.List(MicrosoftCodeAnalysis.ISymbol)()
        AddSimilarNameMembers(this, type, names, members, false)
        local indexOfA = members:IndexOf(a)
        assert(indexOfA ~= - 1)
        local indexOfB = members:IndexOf(b)
        assert(indexOfB ~= - 1)
        assert(indexOfA ~= indexOfB)
        return indexOfA:CompareTo(indexOfB)
      else
        local isSubclassOf = CSharpLua.Utility.IsSubclassOf(a:getContainingType(), b:getContainingType())
        return isSubclassOf and 1 or - 1
      end
    end
    CheckRefactorNames = function (this)
      local alreadyRefactorSymbols = System.HashSet(MicrosoftCodeAnalysis.ISymbol)()
      for _, symbol in System.each(this.refactorNames_) do
        local hasImplementation = false
        for _, implementation in System.each(AllInterfaceImplementations(this, symbol)) do
          hasImplementation = RefactorInterfaceSymbol(this, implementation, alreadyRefactorSymbols)
        end

        if not hasImplementation then
          RefactorCurTypeSymbol(this, symbol, alreadyRefactorSymbols)
        end
      end

      CheckRefactorInnerNames(this)
    end
    RefactorCurTypeSymbol = function (this, symbol, alreadyRefactorSymbols)
      local typeSymbol = symbol:getContainingType()
      local childrens = CSharpLua.Utility.GetOrDefault1(this.extends_, typeSymbol, nil, MicrosoftCodeAnalysis.INamedTypeSymbol, System.HashSet(MicrosoftCodeAnalysis.INamedTypeSymbol))
      local newName = GetRefactorName(this, typeSymbol, childrens, symbol)
      RefactorName(this, symbol, newName, alreadyRefactorSymbols)
    end
    RefactorInterfaceSymbol = function (this, symbol, alreadyRefactorSymbols)
      if CSharpLua.Utility.IsFromCode(symbol) then
        local typeSymbol = symbol:getContainingType()
        assert(typeSymbol:getTypeKind() == 7 --[[TypeKind.Interface]])
        local childrens = this.extends_:get(typeSymbol)
        local newName = GetRefactorName(this, nil, childrens, symbol)
        for _, children in System.each(childrens) do
          local childrenSymbol = children:FindImplementationForInterfaceMember(symbol)
          if childrenSymbol == nil then
            childrenSymbol = FindImplicitImplementationForInterfaceMember(this, children, symbol)
          end
          assert(childrenSymbol ~= nil)
          RefactorName(this, childrenSymbol, newName, alreadyRefactorSymbols)
        end
        return true
      end
      return false
    end
    RefactorName = function (this, symbol, newName, alreadyRefactorSymbols)
      if not alreadyRefactorSymbols:Contains(symbol) then
        if CSharpLua.Utility.IsOverridable(symbol) then
          RefactorChildrensOverridden(this, symbol, symbol:getContainingType(), newName, alreadyRefactorSymbols)
        end
        UpdateName(this, symbol, newName, alreadyRefactorSymbols)
      end
    end
    RefactorChildrensOverridden = function (this, originalSymbol, curType, newName, alreadyRefactorSymbols)
      local childrens = CSharpLua.Utility.GetOrDefault1(this.extends_, curType, nil, MicrosoftCodeAnalysis.INamedTypeSymbol, System.HashSet(MicrosoftCodeAnalysis.INamedTypeSymbol))
      if childrens ~= nil then
        for _, children in System.each(childrens) do
          local curSymbol = SystemLinq.ImmutableArrayExtensions.FirstOrDefault(children:GetMembers(originalSymbol:getName()), function (i)
            return CSharpLua.Utility.IsOverridden(i, originalSymbol)
          end, MicrosoftCodeAnalysis.ISymbol)
          if curSymbol ~= nil then
            UpdateName(this, curSymbol, newName, alreadyRefactorSymbols)
          end
          RefactorChildrensOverridden(this, originalSymbol, children, newName, alreadyRefactorSymbols)
        end
      end
    end
    UpdateName = function (this, symbol, newName, alreadyRefactorSymbols)
      this.memberNames_:get(symbol):Update(newName)
      local checkName1
      local checkName2
      checkName1, checkName2 = GetRefactorCheckName(this, symbol, newName)
      TryAddNewUsedName(this, symbol:getContainingType(), checkName1)
      if checkName2 ~= nil then
        TryAddNewUsedName(this, symbol:getContainingType(), checkName2)
      end
      alreadyRefactorSymbols:Add(symbol)
    end
    GetRefactorCheckName = function (this, symbol, newName, checkName1, checkName2)
      checkName1 = newName
      checkName2 = nil
      if symbol:getKind() == 15 --[[SymbolKind.Property]] then
        local property = System.cast(MicrosoftCodeAnalysis.IPropertySymbol, symbol)
        local isField = IsPropertyField(this, property)
        if not isField then
          checkName1 = "get" --[[Tokens.Get]] .. newName
          checkName2 = "set" --[[Tokens.Set]] .. newName
        end
      elseif symbol:getKind() == 5 --[[SymbolKind.Event]] then
        local evnetSymbol = System.cast(MicrosoftCodeAnalysis.IEventSymbol, symbol)
        local isField = IsEventFiled(this, evnetSymbol)
        if not isField then
          checkName1 = "add" --[[Tokens.Add]] .. newName
          checkName2 = "remove" --[[Tokens.Remove]] .. newName
        end
      end
      return checkName1, checkName2
    end
    GetRefactorName = function (this, typeSymbol, childrens, symbol)
      local isPrivate = CSharpLua.Utility.IsPrivate(symbol)
      local index
      local originalName
      local default
      default, originalName = this.memberIllegalNames_:TryGetValue(symbol)
      if default then
        index = 0
      else
        originalName = GetSymbolBaseName(this, symbol)
        index = 1
      end
      while true do
        local extern
        if index ~= 0 then
          extern = originalName .. index
        else
          extern = originalName
        end
        local newName = extern
        local checkName1
        local checkName2
        checkName1, checkName2 = GetRefactorCheckName(this, symbol, newName)

        local isEnable = true
        if typeSymbol ~= nil then
          isEnable = IsNewNameEnable(this, typeSymbol, checkName1, checkName2, isPrivate)
        else
          if not isPrivate and childrens ~= nil then
            isEnable = Linq.All(childrens, function (i)
              return IsNewNameEnable(this, i, checkName1, checkName2, isPrivate)
            end)
          end
        end
        if isEnable then
          return newName
        end
        index = index + 1
      end
    end
    IsTypeNameUsed = function (this, typeSymbol, newName)
      local set = CSharpLua.Utility.GetOrDefault1(this.typeNameUseds_, typeSymbol, nil, MicrosoftCodeAnalysis.INamedTypeSymbol, System.HashSet(System.String))
      return set ~= nil and set:Contains(newName)
    end
    IsNewNameEnable = function (this, typeSymbol, checkName1, checkName2, isPrivate)
      local isEnable = IsNewNameEnable1(this, typeSymbol, checkName1, isPrivate)
      if isEnable then
        if checkName2 ~= nil then
          isEnable = IsNewNameEnable1(this, typeSymbol, checkName2, isPrivate)
        end
      end
      return isEnable
    end
    IsNewNameEnable1 = function (this, typeSymbol, newName, isPrivate)
      local isEnable = IsNameEnableOfCurAndChildrens(this, typeSymbol, newName, isPrivate)
      if isEnable then
        if not isPrivate then
          local p = typeSymbol:getBaseType()
          while p ~= nil do
            if not IsCurTypeNameEnable(this, p, newName) then
              return false
            end
            p = p:getBaseType()
          end
        end
        return true
      end
      return false
    end
    IsCurTypeNameEnable = function (this, typeSymbol, newName)
      return not IsTypeNameUsed(this, typeSymbol, newName) and typeSymbol:GetMembers(newName):getIsEmpty()
    end
    IsNameEnableOfCurAndChildrens = function (this, typeSymbol, newName, isPrivate)
      if not IsCurTypeNameEnable(this, typeSymbol, newName) then
        return false
      end

      if not isPrivate then
        local childrens = CSharpLua.Utility.GetOrDefault1(this.extends_, typeSymbol, nil, MicrosoftCodeAnalysis.INamedTypeSymbol, System.HashSet(MicrosoftCodeAnalysis.INamedTypeSymbol))
        if childrens ~= nil then
          for _, children in System.each(childrens) do
            if not IsNameEnableOfCurAndChildrens(this, children, newName, isPrivate) then
              return false
            end
          end
        end
      end

      return true
    end
    CheckRefactorInnerNames = function (this)
      for _, innerName in System.each(this.propertyOrEvnetInnerFieldNames_) do
        local symbol = innerName.Key
        local newName = GetInnerGetRefactorName(this, symbol)
        innerName.Value:Update(newName)
        TryAddNewUsedName(this, symbol:getContainingType(), newName)
      end
    end
    GetInnerGetRefactorName = function (this, symbol)
      local isPrivate = CSharpLua.Utility.IsPrivate(symbol)
      local originalName = GetSymbolBaseName(this, symbol)

      local index = 0
      while true do
        local default
        if index == 0 then
          default = originalName
        else
          default = originalName .. index
        end
        local newName = default
        local isEnable = IsInnerNameEnable(this, symbol:getContainingType(), newName, isPrivate)
        if isEnable then
          return newName
        end
        index = index + 1
      end
    end
    IsInnerNameEnable = function (this, typeSymbol, newName, isPrivate)
      local isEnable = IsInnerNameEnableOfChildrens(this, typeSymbol, newName, isPrivate)
      if isEnable then
        if not isPrivate then
          local p = typeSymbol:getBaseType()
          while p ~= nil do
            if not IsCurTypeNameEnable(this, p, newName) then
              return false
            end
            p = p:getBaseType()
          end
        end
        return true
      end
      return false
    end
    IsInnerNameEnableOfChildrens = function (this, typeSymbol, newName, isPrivate)
      local childrens = CSharpLua.Utility.GetOrDefault1(this.extends_, typeSymbol, nil, MicrosoftCodeAnalysis.INamedTypeSymbol, System.HashSet(MicrosoftCodeAnalysis.INamedTypeSymbol))
      if childrens ~= nil then
        for _, children in System.each(childrens) do
          if not IsNameEnableOfCurAndChildrens(this, children, newName, isPrivate) then
            return false
          end
        end
      end
      return true
    end
    IsMonoBehaviourSpeicalMethod = function (this, symbol)
      if this.monoBehaviourSpeicalMethodNames_ ~= nil and this.monoBehaviourSpeicalMethodNames_:Contains(symbol:getName()) then
        return CSharpLua.Utility.IsAssignableFrom(this.monoBehaviourTypeSymbol_, symbol:getContainingType())
      end
      return false
    end
    DoPretreatment = function (this)
      class.PretreatmentChecker(this)
    end
    AddImplicitInterfaceImplementation = function (this, implementationMember, interfaceMember)
      local success = CSharpLua.Utility.TryAdd(this.implicitInterfaceImplementations_, implementationMember, interfaceMember, MicrosoftCodeAnalysis.ISymbol, MicrosoftCodeAnalysis.ISymbol)
      if success then
        local containingType = implementationMember:getContainingType()
        local mapps = CSharpLua.Utility.GetOrDefault1(this.implicitInterfaceTypes_, containingType, nil, MicrosoftCodeAnalysis.INamedTypeSymbol, System.Dictionary(MicrosoftCodeAnalysis.ISymbol, MicrosoftCodeAnalysis.ISymbol))
        if mapps == nil then
          mapps = System.Dictionary(MicrosoftCodeAnalysis.ISymbol, MicrosoftCodeAnalysis.ISymbol)()
          this.implicitInterfaceTypes_:Add(containingType, mapps)
        end
        mapps:Add(interfaceMember, implementationMember)
      end
    end
    FindImplicitImplementationForInterfaceMember = function (this, typeSymbol, interfaceMember)
      local mapps = CSharpLua.Utility.GetOrDefault1(this.implicitInterfaceTypes_, typeSymbol, nil, MicrosoftCodeAnalysis.INamedTypeSymbol, System.Dictionary(MicrosoftCodeAnalysis.ISymbol, MicrosoftCodeAnalysis.ISymbol))
      local default = mapps
      if default ~= nil then
        default = CSharpLua.Utility.GetOrDefault1(default, interfaceMember, nil, MicrosoftCodeAnalysis.ISymbol, MicrosoftCodeAnalysis.ISymbol)
      end
      return default
    end
    IsImplicitInterfaceImplementation = function (this, symbol)
      return this.implicitInterfaceImplementations_:ContainsKey(symbol)
    end
    IsPropertyField = function (this, symbol)
      local isAutoField
      local default
      default, isAutoField = this.isFieldPropertys_:TryGetValue(symbol)
      if not default then
        local isMateField = this.XmlMetaProvider:IsPropertyField(symbol)
        if System.HasValueOfNull(isMateField) then
          isAutoField = isMateField:getValue()
        else
          if IsImplicitInterfaceImplementation(this, symbol) then
            isAutoField = false
          else
            isAutoField = CSharpLua.Utility.IsPropertyField(symbol)
          end
        end
        this.isFieldPropertys_:Add(symbol, isAutoField)
      end
      return isAutoField
    end
    IsEventFiled = function (this, symbol)
      return not IsImplicitInterfaceImplementation(this, symbol) and CSharpLua.Utility.IsEventFiled(symbol)
    end
    IsPropertyFieldOrEventFiled = function (this, symbol)
      local propertySymbol = symbol
      local eventSymbol = symbol
      if System.is(propertySymbol, MicrosoftCodeAnalysis.IPropertySymbol) then
        return IsPropertyField(this, propertySymbol)
      elseif System.is(eventSymbol, MicrosoftCodeAnalysis.IEventSymbol) then
        return IsEventFiled(this, eventSymbol)
      end
      return false
    end
    AllInterfaceImplementations = function (this, symbol)
      local interfaceImplementations = CSharpLua.Utility.InterfaceImplementations(symbol, MicrosoftCodeAnalysis.ISymbol)
      local implicitImplementations = CSharpLua.Utility.GetOrDefault1(this.implicitInterfaceImplementations_, symbol, nil, MicrosoftCodeAnalysis.ISymbol, System.HashSet(MicrosoftCodeAnalysis.ISymbol))
      if implicitImplementations ~= nil then
        interfaceImplementations = Linq.Concat(interfaceImplementations, implicitImplementations)
      end
      return interfaceImplementations
    end
    AllInterfaceImplementationsCount = function (this, symbol)
      local count = 0
      local implicitImplementations = CSharpLua.Utility.GetOrDefault1(this.implicitInterfaceImplementations_, symbol, nil, MicrosoftCodeAnalysis.ISymbol, System.HashSet(MicrosoftCodeAnalysis.ISymbol))
      if implicitImplementations ~= nil then
        count = implicitImplementations:getCount()
      end
      count = count + Linq.Count(CSharpLua.Utility.InterfaceImplementations(symbol, MicrosoftCodeAnalysis.ISymbol))
      return count
    end
    HasStaticCtor = function (this, typeSymbol)
      return CSharpLua.Utility.HasStaticCtor(typeSymbol) or this.typesOfExtendSelf_:Contains(typeSymbol)
    end
    IsExtendExists = function (this, typeSymbol)
      local set = CSharpLua.Utility.GetOrDefault1(this.extends_, typeSymbol, nil, MicrosoftCodeAnalysis.INamedTypeSymbol, System.HashSet(MicrosoftCodeAnalysis.INamedTypeSymbol))
      return set ~= nil and set:getCount() > 0
    end
    IsSealed = function (this, typeSymbol)
      return typeSymbol:getIsSealed() or not IsExtendExists(this, typeSymbol)
    end
    GetTypeRefactorName = function (this, symbol)
      return CSharpLua.Utility.GetOrDefault1(this.typeRefactorNames_, symbol, nil, MicrosoftCodeAnalysis.INamedTypeSymbol, System.String)
    end
    GetTypeDeclarationName = function (this, typeSymbol)
      local name = typeSymbol:getName()
      local typeParametersCount = typeSymbol:getTypeParameters():getLength()
      if typeParametersCount > 0 then
        name = name .. ("_" .. typeParametersCount)
      end
      return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, GetTypeRefactorName(this, typeSymbol) or name)
    end
    GetTypeName = function (this, symbol, transfor)
      if symbol:getKind() == 17 --[[SymbolKind.TypeParameter]] then
        return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, symbol:getName())
      end

      if symbol:getKind() == 1 --[[SymbolKind.ArrayType]] then
        local arrayType = System.cast(MicrosoftCodeAnalysis.IArrayTypeSymbol, symbol)
        local elementTypeExpression = GetTypeName(this, arrayType:getElementType(), transfor)
        local default
        if arrayType:getRank() == 1 then
          default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.Array
        else
          default = CSharpLuaLuaAst.LuaIdentifierNameSyntax.MultiArray
        end
        return CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(2, default, elementTypeExpression)
      end

      local namedTypeSymbol = System.cast(MicrosoftCodeAnalysis.INamedTypeSymbol, symbol)
      if namedTypeSymbol:getTypeKind() == 5 --[[TypeKind.Enum]] then
        return CSharpLuaLuaAst.LuaIdentifierNameSyntax.Int
      end

      if CSharpLua.Utility.IsDelegateType(namedTypeSymbol) then
        return CSharpLuaLuaAst.LuaIdentifierNameSyntax.Delegate
      end

      if namedTypeSymbol:getIsAnonymousType() then
        return CSharpLuaLuaAst.LuaIdentifierNameSyntax.AnonymousType
      end

      if namedTypeSymbol:getIsTupleType() then
        return CSharpLuaLuaAst.LuaIdentifierNameSyntax.ValueTupleType
      end

      if CSharpLua.Utility.IsSystemTuple(namedTypeSymbol) then
        return CSharpLuaLuaAst.LuaIdentifierNameSyntax.TupleType
      end

      if transfor ~= nil then
        local curTypeDeclaration = transfor:getCurTypeDeclaration()
        local classIdentifier
        local extern
        extern, classIdentifier = curTypeDeclaration:CheckTypeName(namedTypeSymbol)
        if curTypeDeclaration ~= nil and extern then
          return classIdentifier
        end
      end

      local typeName = GetTypeShortName(this, namedTypeSymbol, transfor)
      local typeArguments = GetTypeArguments(this, namedTypeSymbol, transfor)
      if #typeArguments == 0 then
        return typeName
      else
        local invocationExpression = CSharpLuaLuaAst.LuaInvocationExpressionSyntax:new(1, typeName)
        invocationExpression:AddArguments(typeArguments)
        return invocationExpression
      end
    end
    GetTypeArguments = function (this, typeSymbol, transfor)
      local typeArguments = System.List(CSharpLuaLuaAst.LuaExpressionSyntax)()
      FillExternalTypeArgument(this, typeArguments, typeSymbol, transfor)
      FillTypeArguments(this, typeArguments, typeSymbol, transfor)
      return typeArguments
    end
    FillExternalTypeArgument = function (this, typeArguments, typeSymbol, transfor)
      local externalType = typeSymbol:getContainingType()
      if externalType ~= nil then
        FillExternalTypeArgument(this, typeArguments, externalType, transfor)
        FillTypeArguments(this, typeArguments, externalType, transfor)
      end
    end
    FillTypeArguments = function (this, typeArguments, typeSymbol, transfor)
      for _, typeArgument in System.each(typeSymbol:getTypeArguments()) do
        if typeArgument:getKind() == 4 --[[SymbolKind.ErrorType]] then
          break
        end
        local typeArgumentExpression = GetTypeName(this, typeArgument, transfor)
        typeArguments:Add(typeArgumentExpression)
      end
    end
    GetNamespaceMapName = function (this, symbol, original)
      if CSharpLua.Utility.IsFromCode(symbol) then
        local names = Linq.Select(CSharpLua.Utility.GetAllNamespaces(symbol), function (i)
          return CSharpLua.Utility.GetOrDefault1(this.namespaceRefactorNames_, i, i:getName(), MicrosoftCodeAnalysis.INamespaceSymbol, System.String)
        end, System.String)
        return System.String.Join(".", names)
      else
        return this.XmlMetaProvider:GetNamespaceMapName(symbol, original)
      end
    end
    GetTypeShortName = function (this, symbol, transfor)
      local typeSymbol = System.cast(MicrosoftCodeAnalysis.INamedTypeSymbol, symbol:getOriginalDefinition())
      local name = CSharpLua.Utility.GetTypeShortName(typeSymbol, System.bind(this, GetNamespaceMapName), System.bind(this, GetTypeRefactorName), transfor)
      local newName = this.XmlMetaProvider:GetTypeMapName(typeSymbol, name)
      if newName ~= nil then
        name = newName
      end
      if transfor ~= nil then
        if transfor:getIsGetInheritTypeName() and CSharpLua.Utility.IsFromCode(typeSymbol) then
          name = (CSharpLuaLuaAst.LuaIdentifierNameSyntax.Global.ValueText .. '.') .. name
        else
          name = transfor:ImportTypeName(name, symbol)
        end
      end
      return CSharpLuaLuaAst.LuaIdentifierNameSyntax:new(1, name)
    end
    class = {
      isExportAttributesAll_ = false,
      Generate = Generate,
      RemoveBaseFolder = RemoveBaseFolder,
      getIsCheckedOverflow = getIsCheckedOverflow,
      IsEnumExport = IsEnumExport,
      AddExportEnum = AddExportEnum,
      AddEnumDeclaration = AddEnumDeclaration,
      AddIgnoreExportType = AddIgnoreExportType,
      IsExportAttribute = IsExportAttribute,
      AddPartialTypeDeclaration = AddPartialTypeDeclaration,
      GetSemanticModel = GetSemanticModel,
      IsBaseType = IsBaseType,
      SetMainEntryPoint = SetMainEntryPoint,
      AddTypeSymbol = AddTypeSymbol,
      AddTypeDeclarationAttribute = AddTypeDeclarationAttribute,
      GetMemberName = GetMemberName,
      AddInnerName = AddInnerName,
      IsMonoBehaviourSpeicalMethod = IsMonoBehaviourSpeicalMethod,
      IsPropertyField = IsPropertyField,
      IsEventFiled = IsEventFiled,
      IsPropertyFieldOrEventFiled = IsPropertyFieldOrEventFiled,
      HasStaticCtor = HasStaticCtor,
      IsExtendExists = IsExtendExists,
      IsSealed = IsSealed,
      GetTypeDeclarationName = GetTypeDeclarationName,
      GetTypeName = GetTypeName,
      GetTypeShortName = GetTypeShortName,
      __staticCtor__ = __staticCtor__,
      __ctor__ = __ctor__
    }
    return class
  end)
end)
